# Korean translation for GNU coreutils
# Copyright (C) 1996, 2001, 2002 Free Software Foundation, Inc.
# This file is distributed under the same license as the coreutils package.
# Bang Jun-Young <bangjy@nownuri.nowcom.co.kr>, 1996-1997.
# Changwoo Ryu <cwryu@debian.org>, 2001-2002.
# Seong-ho Cho <darkcircle.0426@gmail.com>, 2021, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: coreutils 9.1-pre1\n"
"Report-Msgid-Bugs-To: bug-coreutils@gnu.org\n"
"POT-Creation-Date: 2022-04-15 22:14+0100\n"
"PO-Revision-Date: 2022-04-11 13:07+0900\n"
"Last-Translator: Seong-ho Cho <darkcircle.0426@gmail.com>\n"
"Language-Team: Korean <translation-team-ko@googlegroups.com>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 2.3\n"

#: lib/argmatch.c:147
#, c-format
msgid "invalid argument %s for %s"
msgstr "%2$s에 대해 부적절한 인자 %1$s"

#: lib/argmatch.c:148
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "%2$s에 대해 애매한 인자 %1$s"

#: lib/argmatch.c:167 lib/argmatch.h:238
msgid "Valid arguments are:"
msgstr "적절한 인자:"

#: lib/closein.c:100
msgid "error closing file"
msgstr "파일 닫기 오류"

#: lib/closeout.c:122 src/basenc.c:929 src/basenc.c:939 src/basenc.c:945
#: src/basenc.c:1002 src/basenc.c:1065 src/cat.c:182 src/cat.c:197
#: src/cat.c:261 src/cat.c:798 src/expand.c:149 src/expand.c:174
#: src/factor.c:2365 src/mktemp.c:339 src/od.c:970 src/paste.c:162
#: src/seq.c:295 src/shuf.c:596 src/split.c:940 src/split.c:1196
#: src/split.c:1201 src/tail.c:1294 src/tail.c:1448 src/tail.c:2486
#: src/tr.c:1590 src/tr.c:1816 src/tr.c:1908 src/unexpand.c:233
#: src/unexpand.c:249
#, c-format
msgid "write error"
msgstr "쓰기 오류"

#: lib/copy-acl.c:54 src/copy.c:1444 src/copy.c:3044
#, c-format
msgid "preserving permissions for %s"
msgstr "%s의 권한 유지"

#: lib/error.c:195
msgid "Unknown system error"
msgstr "알 수 없는 시스템 오류"

#: lib/file-type.c:40
msgid "regular empty file"
msgstr "일반 빈 파일"

#: lib/file-type.c:40
msgid "regular file"
msgstr "일반 파일"

#: lib/file-type.c:43
msgid "directory"
msgstr "디렉터리"

#: lib/file-type.c:46
msgid "symbolic link"
msgstr "심볼릭 링크"

#: lib/file-type.c:52
msgid "message queue"
msgstr "메시지 큐"

#: lib/file-type.c:55
msgid "semaphore"
msgstr "세마포어"

#: lib/file-type.c:58
msgid "shared memory object"
msgstr "공유 메모리 오브젝트"

#: lib/file-type.c:61
msgid "typed memory object"
msgstr "형식 지정 메모리 오브젝트"

#: lib/file-type.c:66
msgid "block special file"
msgstr "블록 특수 파일"

#: lib/file-type.c:69
msgid "character special file"
msgstr "문자 특수 파일"

#: lib/file-type.c:72
msgid "contiguous data"
msgstr "연속 데이터"

#: lib/file-type.c:75
msgid "fifo"
msgstr "FIFO"

#: lib/file-type.c:78
msgid "door"
msgstr "door"

#: lib/file-type.c:81
msgid "multiplexed block special file"
msgstr "복합 블록 특수 파일"

#: lib/file-type.c:84
msgid "multiplexed character special file"
msgstr "복합 문자 특수 파일"

#: lib/file-type.c:87
msgid "multiplexed file"
msgstr "복합화 파일"

#: lib/file-type.c:90
msgid "named file"
msgstr "명명한 파일"

#: lib/file-type.c:93
msgid "network special file"
msgstr "네트워크 특수 파일"

#: lib/file-type.c:96
msgid "migrated file with data"
msgstr "데이터와 파일을 함께 가져옴"

#: lib/file-type.c:99
msgid "migrated file without data"
msgstr "데이터를 제외하고 파일만 가져옴"

#: lib/file-type.c:102
msgid "port"
msgstr "포트"

#: lib/file-type.c:105
msgid "socket"
msgstr "소켓"

#: lib/file-type.c:108
msgid "whiteout"
msgstr "허용후보 처리"

#: lib/file-type.c:110
msgid "weird file"
msgstr "괴상한 파일"

#: lib/gai_strerror.c:57
msgid "Address family for hostname not supported"
msgstr "이 호스트 이름의 주소 체계를 지원하지 않습니다"

#: lib/gai_strerror.c:58
msgid "Temporary failure in name resolution"
msgstr "일시적 이름 해석 실패"

#: lib/gai_strerror.c:59
msgid "Bad value for ai_flags"
msgstr "AI_FLAGS의 잘못된 값"

#: lib/gai_strerror.c:60
msgid "Non-recoverable failure in name resolution"
msgstr "복원할 수 없는 이름 해석 실패"

#: lib/gai_strerror.c:61
msgid "ai_family not supported"
msgstr "AI_FAMILY를 지원하지 않습니다"

#: lib/gai_strerror.c:62
msgid "Memory allocation failure"
msgstr "메모리 할당 실패"

#: lib/gai_strerror.c:63
msgid "No address associated with hostname"
msgstr "호스트 이름에 할당한 주소가 없습니다"

#: lib/gai_strerror.c:64
msgid "Name or service not known"
msgstr "알 수 없는 이름 또는 서비스"

#: lib/gai_strerror.c:65
msgid "Servname not supported for ai_socktype"
msgstr "AI_SOCKTYPE에 서버 이름을 지원하지 않습니다"

#: lib/gai_strerror.c:66
msgid "ai_socktype not supported"
msgstr "AI_SOCKTYPE을 지원하지 않습니다"

#: lib/gai_strerror.c:67
msgid "System error"
msgstr "시스템 오류"

#: lib/gai_strerror.c:68
msgid "Argument buffer too small"
msgstr "인자 버퍼가 너무 작습니다"

#: lib/gai_strerror.c:70
msgid "Processing request in progress"
msgstr "처리 요청 진행중"

#: lib/gai_strerror.c:71
msgid "Request canceled"
msgstr "요청을 취소했습니다"

#: lib/gai_strerror.c:72
msgid "Request not canceled"
msgstr "요청을 취소하지 않았습니다"

#: lib/gai_strerror.c:73
msgid "All requests done"
msgstr "모든 요청을 처리했습니다"

#: lib/gai_strerror.c:74
msgid "Interrupted by a signal"
msgstr "시그널로 중단함"

#: lib/gai_strerror.c:75
msgid "Parameter string not correctly encoded"
msgstr "매개변수 문자열을 제대로 인코딩하지 않았습니다"

#: lib/gai_strerror.c:87
msgid "Unknown error"
msgstr "알 수 없는 오류"

#: lib/getopt.c:278
#, c-format
msgid "%s: option '%s%s' is ambiguous\n"
msgstr "%s: '%s%s' 옵션이 모호합니다\n"

#: lib/getopt.c:284
#, c-format
msgid "%s: option '%s%s' is ambiguous; possibilities:"
msgstr "%s: '%s%s' 옵션이 모호합니다. 가능한 옵션:"

#: lib/getopt.c:319
#, c-format
msgid "%s: unrecognized option '%s%s'\n"
msgstr "%s: '%s%s' 옵션을 인식할 수 없습니다\n"

#: lib/getopt.c:345
#, c-format
msgid "%s: option '%s%s' doesn't allow an argument\n"
msgstr "%s: '%s%s' 옵션은 인자를 허용하지 않습니다\n"

#: lib/getopt.c:360
#, c-format
msgid "%s: option '%s%s' requires an argument\n"
msgstr "%s: '%s%s' 옵션에 인자가 필요합니다\n"

#: lib/getopt.c:621
#, c-format
msgid "%s: invalid option -- '%c'\n"
msgstr "%s: 부적절한 '%c' 옵션\n"

#: lib/getopt.c:636 lib/getopt.c:682
#, c-format
msgid "%s: option requires an argument -- '%c'\n"
msgstr "%s: '%c' 옵션에 인자가 필요합니다\n"

#: lib/mkdir-p.c:162 src/copy.c:1991 src/copy.c:2067 src/copy.c:2663
#: src/copy.c:3030 src/find-mount-point.c:84 src/install.c:648
#: src/realpath.c:146 src/stat.c:1483 src/truncate.c:325
#, c-format
msgid "cannot stat %s"
msgstr "%s 상태 정보 확인 불가"

#: lib/mkdir-p.c:190 src/install.c:455
#, c-format
msgid "cannot change permissions of %s"
msgstr "%s의 권한을 바꿀 수 없습니다"

#: lib/mkdir-p.c:200 src/copy.c:2651 src/install.c:686 src/install.c:699
#, c-format
msgid "cannot create directory %s"
msgstr "%s 디렉터리를 만들 수 없습니다"

#: lib/obstack.c:337 lib/obstack.c:339 lib/xalloc-die.c:34 src/csplit.c:229
#: src/tac.c:442
#, c-format
msgid "memory exhausted"
msgstr "메모리가 바닥남"

#: lib/openat-die.c:38
#, c-format
msgid "unable to record current working directory"
msgstr "현재 작업 디렉터리를 기록할 수 없습니다"

#: lib/openat-die.c:57 src/find-mount-point.c:107
#, c-format
msgid "failed to return to initial working directory"
msgstr "초기 작업 디렉터리 복귀 실패"

#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  For example, a French Unicode local should translate
#. these to U+00AB (LEFT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE
#. QUOTATION MARK), respectively.
#.
#. If the catalog has no translation, we will try to
#. use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and
#. Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the
#. current locale is not Unicode, locale_quoting_style
#. will quote 'like this', and clocale_quoting_style will
#. quote "like this".  You should always include translations
#. for "`" and "'" even if U+2018 and U+2019 are appropriate
#. for your locale.
#.
#. If you don't know what to put here, please see
#. <https://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>
#. and use glyphs suitable for your language.
#: lib/quotearg.c:355
msgid "`"
msgstr "`"

#: lib/quotearg.c:356
msgid "'"
msgstr "'"

#: lib/randread.c:110
#, c-format
msgid "%s: end of file"
msgstr "%s: 파일의 끝"

#: lib/randread.c:110 src/du.c:1074 src/digest.c:1190 src/tac.c:251
#: src/tac.c:357 src/tac.c:515 src/tac.c:596 src/wc.c:931
#, c-format
msgid "%s: read error"
msgstr "%s: 읽기 오류"

#: lib/regcomp.c:122
msgid "Success"
msgstr "성공"

#: lib/regcomp.c:125
msgid "No match"
msgstr "일치하는 항목 없음"

#: lib/regcomp.c:128
msgid "Invalid regular expression"
msgstr "부적절한 정규식"

#: lib/regcomp.c:131
msgid "Invalid collation character"
msgstr "부적절한 조합 문자"

#: lib/regcomp.c:134
msgid "Invalid character class name"
msgstr "부적절한 문자 클래스 이름"

#: lib/regcomp.c:137
msgid "Trailing backslash"
msgstr "백 슬래시 문자가 따라옴"

#: lib/regcomp.c:140
msgid "Invalid back reference"
msgstr "부적절한 후위 참조"

#: lib/regcomp.c:143
msgid "Unmatched [, [^, [:, [., or [="
msgstr "일치하지 않는 [, [^, [:, [., [="

#: lib/regcomp.c:146
msgid "Unmatched ( or \\("
msgstr "일치하지 않는 ( 또는 \\( 괄호"

#: lib/regcomp.c:149
msgid "Unmatched \\{"
msgstr "일치하지 않는 \\{ 괄호"

#: lib/regcomp.c:152
msgid "Invalid content of \\{\\}"
msgstr "부적절한 \\{\\} 내용"

#: lib/regcomp.c:155
msgid "Invalid range end"
msgstr "부적절한 범위 끝"

#: lib/regcomp.c:158
msgid "Memory exhausted"
msgstr "메모리가 바닥남"

#: lib/regcomp.c:161
msgid "Invalid preceding regular expression"
msgstr "부적절한 선행 정규 표현식"

#: lib/regcomp.c:164
msgid "Premature end of regular expression"
msgstr "정규 표현식 마감 표현이 앞서있습니다"

#: lib/regcomp.c:167
msgid "Regular expression too big"
msgstr "정규 표현식이 너무 깁니다"

#: lib/regcomp.c:170
msgid "Unmatched ) or \\)"
msgstr "일치하지 않는 ) 또는 \\) 괄호"

#: lib/regcomp.c:650
msgid "No previous regular expression"
msgstr "이전 정규 표현식 없음"

#: lib/root-dev-ino.h:37
#, c-format
msgid "it is dangerous to operate recursively on %s"
msgstr "%s에서의 하위 연속 처리는 위험합니다"

#: lib/root-dev-ino.h:41
#, c-format
msgid "it is dangerous to operate recursively on %s (same as %s)"
msgstr "%s에서의 하위 연속 처리는 위험합니다 (%s와(과) 동일)"

#: lib/root-dev-ino.h:43
#, c-format
msgid "use --no-preserve-root to override this failsafe"
msgstr "안전 설정을 무시하려면 --no-preserve-root 옵션을 사용하십시오"

#. TRANSLATORS: A regular expression testing for an affirmative answer
#. (english: "yes").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^yesexpr='
#: lib/rpmatch.c:150
msgid "^[yY]"
msgstr "^[yY]"

#. TRANSLATORS: A regular expression testing for a negative answer
#. (english: "no").  Testing the first character may be sufficient.
#. Take care to consider upper and lower case.
#. To enquire the regular expression that your system uses for this
#. purpose, you can use the command
#. locale -k LC_MESSAGES | grep '^noexpr='
#: lib/rpmatch.c:163
msgid "^[nN]"
msgstr "^[nN]"

#: lib/set-acl.c:46 src/copy.c:2675 src/cp.c:520
#, c-format
msgid "setting permissions for %s"
msgstr "%s 권한 설정"

#: lib/siglist.h:31
msgid "Hangup"
msgstr "끊어짐"

#: lib/siglist.h:34
msgid "Interrupt"
msgstr "인터럽트"

#: lib/siglist.h:37
msgid "Quit"
msgstr "끝내기"

#: lib/siglist.h:40
msgid "Illegal instruction"
msgstr "명령어가 잘못됨"

#: lib/siglist.h:43
msgid "Trace/breakpoint trap"
msgstr "추적/중단점 함정"

#: lib/siglist.h:46
msgid "Aborted"
msgstr "중지함"

#: lib/siglist.h:49
msgid "Floating point exception"
msgstr "부동 소수점 예외"

#: lib/siglist.h:52
msgid "Killed"
msgstr "죽었음"

#: lib/siglist.h:55
msgid "Bus error"
msgstr "버스 오류"

#: lib/siglist.h:58
msgid "Segmentation fault"
msgstr "세그멘테이션 오류"

#: lib/siglist.h:61
msgid "Broken pipe"
msgstr "파이프 깨짐"

#: lib/siglist.h:64
msgid "Alarm clock"
msgstr "자명종 시계"

#: lib/siglist.h:67
msgid "Terminated"
msgstr "중단함"

#: lib/siglist.h:70
msgid "Urgent I/O condition"
msgstr "긴급 입출력 상태"

#: lib/siglist.h:73
msgid "Stopped (signal)"
msgstr "정지 (시그널)"

#: lib/siglist.h:76
msgid "Stopped"
msgstr "정지"

#: lib/siglist.h:79
msgid "Continued"
msgstr "계속함"

#: lib/siglist.h:82
msgid "Child exited"
msgstr "하위 프로세스 나감"

#: lib/siglist.h:85
msgid "Stopped (tty input)"
msgstr "정지 (tty 입력)"

#: lib/siglist.h:88
msgid "Stopped (tty output)"
msgstr "정지 (tty 출력)"

#: lib/siglist.h:91
msgid "I/O possible"
msgstr "입출력 가능"

#: lib/siglist.h:94
msgid "CPU time limit exceeded"
msgstr "CPU 시간 제한 초과"

#: lib/siglist.h:97
msgid "File size limit exceeded"
msgstr "파일 크기 제한 초과"

#: lib/siglist.h:100
msgid "Virtual timer expired"
msgstr "가상 타이머 초과"

#: lib/siglist.h:103
msgid "Profiling timer expired"
msgstr "프로파일링 타이머 경과"

#: lib/siglist.h:106
msgid "Window changed"
msgstr "윈도우 바뀜"

#: lib/siglist.h:109
msgid "User defined signal 1"
msgstr "사용자 지정 시그널 1"

#: lib/siglist.h:112
msgid "User defined signal 2"
msgstr "사용자 지정 시그널 2"

#: lib/siglist.h:117
msgid "EMT trap"
msgstr "EMT 함정"

#: lib/siglist.h:120
msgid "Bad system call"
msgstr "잘못된 시스템 호출"

#: lib/siglist.h:123
msgid "Stack fault"
msgstr "스택 오류"

#: lib/siglist.h:126
msgid "Information request"
msgstr "정보 요청"

#: lib/siglist.h:128
msgid "Power failure"
msgstr "전원 끊어짐"

#: lib/siglist.h:131
msgid "Resource lost"
msgstr "자원을 잃었습니다"

#: lib/strsignal.c:114
#, c-format
msgid "Real-time signal %d"
msgstr "실시간 시그널 %d"

#: lib/strsignal.c:118
#, c-format
msgid "Unknown signal %d"
msgstr "알 수 없는 시그널 %d"

#: lib/unicodeio.c:102
msgid "iconv function not usable"
msgstr "iconv 함수를 사용할 수 없습니다"

# not usable과 not available의 차이는?
#: lib/unicodeio.c:104
msgid "iconv function not available"
msgstr "iconv 함수를 사용할 수 없습니다"

#: lib/unicodeio.c:111
msgid "character out of range"
msgstr "범위를 벗어난 문자"

#: lib/unicodeio.c:198
#, c-format
msgid "cannot convert U+%04X to local character set"
msgstr "U+%04X을(를) 로컬 문자셋으로 변환할 수 없습니다"

#: lib/unicodeio.c:200
#, c-format
msgid "cannot convert U+%04X to local character set: %s"
msgstr "U+%04X을(를) 로컬 문자셋으로 변환할 수 없습니다: %s"

#: lib/userspec.c:165
msgid "invalid spec"
msgstr "잘못된 사양"

#: lib/userspec.c:174
msgid "invalid user"
msgstr "부적절한 사용자"

#: lib/userspec.c:207
msgid "invalid group"
msgstr "부적절한 그룹"

#: lib/userspec.c:279
msgid "warning: '.' should be ':'"
msgstr "경고: '.' 문자는 ':'으로 바꾸어야 합니다"

#: lib/verror.c:76
#, c-format
msgid "unable to display error message"
msgstr "오류 메시지를 표시할 수 없습니다"

#: lib/version-etc.c:73
#, c-format
msgid "Packaged by %s (%s)\n"
msgstr "%s(%s)(으)로 패키지 구성함\n"

#: lib/version-etc.c:76
#, c-format
msgid "Packaged by %s\n"
msgstr "%s(으)로 패키지 구성함\n"

#. TRANSLATORS: Translate "(C)" to the copyright symbol
#. (C-in-a-circle), if this symbol is available in the user's
#. locale.  Otherwise, do not translate "(C)"; leave it as-is.
#: lib/version-etc.c:83
msgid "(C)"
msgstr "©"

#. TRANSLATORS: The %s placeholder is the web address of the GPL license.
#: lib/version-etc.c:88
#, c-format
msgid ""
"License GPLv3+: GNU GPL version 3 or later <%s>.\n"
"This is free software: you are free to change and redistribute it.\n"
"There is NO WARRANTY, to the extent permitted by law.\n"
msgstr ""
"라이선스 GPLv3+: GNU GPL 버전 3 이상 <%s>.\n"
"이 프로그램은 자유 소프트웨어입니다: 자유롭게 바꾸고 재배포할 수 있습니다.\n"
"법률이 허용하는 모든 범위내의 보증은 없습니다.\n"

#. TRANSLATORS: %s denotes an author name.
#: lib/version-etc.c:105
#, c-format
msgid "Written by %s.\n"
msgstr "%s이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:109
#, c-format
msgid "Written by %s and %s.\n"
msgstr "%s, %s이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#: lib/version-etc.c:113
#, c-format
msgid "Written by %s, %s, and %s.\n"
msgstr "%s, %s, %s이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:120
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"%s, %s, %s,\n"
"%s이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:127
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"%s, %s, %s, %s,\n"
"%s이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:134
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, and %s.\n"
msgstr ""
"%s, %s, %s, %s,\n"
"%s, %s이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:142
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, and %s.\n"
msgstr ""
"%s, %s, %s, %s,\n"
"%s, %s, %s이(가)\n"
"작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:150
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"and %s.\n"
msgstr ""
"%s, %s,%s, %s,\n"
"%s, %s, %s, %s\n"
"이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:159
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, and %s.\n"
msgstr ""
"%s, %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s이(가) 작성함.\n"

#. TRANSLATORS: Each %s denotes an author name.
#. You can use line breaks, estimating that each author name occupies
#. ca. 16 screen columns and that a screen line has ca. 80 columns.
#: lib/version-etc.c:170
#, c-format
msgid ""
"Written by %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s, %s, and others.\n"
msgstr ""
"%s, %s, %s, %s,\n"
"%s, %s, %s, %s,\n"
"%s 등이 작성함.\n"

#. TRANSLATORS: The placeholder indicates the bug-reporting address
#. for this package.  Please add _another line_ saying
#. "Report translation bugs to <...>\n" with the address for translation
#. bugs (typically your translation team's web or email address).
#: lib/version-etc.c:249
#, c-format
msgid "Report bugs to: %s\n"
msgstr "버그 보고 주소: %s\n"

#: lib/version-etc.c:251
#, c-format
msgid "Report %s bugs to: %s\n"
msgstr "%s 버그 보고 주소: %s\n"

#: lib/version-etc.c:255 lib/version-etc.c:257
#, c-format
msgid "%s home page: <%s>\n"
msgstr "%s 홈페이지: <%s>\n"

#: lib/version-etc.c:260
#, c-format
msgid "General help using GNU software: <%s>\n"
msgstr "GNU 프로그램 사용 일반 도움말: <%s>\n"

#: lib/xbinary-io.c:37
#, c-format
msgid "failed to set file descriptor text/binary mode"
msgstr "텍스트/바이너리 모드 파일 서술자 지정 실패"

#: lib/xmemcoll.c:39 src/expr.c:926
#, c-format
msgid "string comparison failed"
msgstr "문자열 비교를 실패했습니다"

#: lib/xmemcoll.c:40
#, c-format
msgid "Set LC_ALL='C' to work around the problem."
msgstr "이 문제를 피해 가려면 LC_ALL='C' 설정하십시오."

#: lib/xmemcoll.c:42
#, c-format
msgid "The strings compared were %s and %s."
msgstr "비교한 문자열은 %s과(와) %s입니다."

#: lib/xprintf.c:50 lib/xprintf.c:76
#, c-format
msgid "cannot perform formatted output"
msgstr "형식 지정 출력을 수행할 수 없습니다"

#: lib/xstrtol-error.c:63
#, c-format
msgid "invalid %s%s argument '%s'"
msgstr "부적절한 %s%s 인자값 '%s'"

#: lib/xstrtol-error.c:68
#, c-format
msgid "invalid suffix in %s%s argument '%s'"
msgstr "%s%s 인자값 '%s'에 부적절한 접미사"

#: lib/xstrtol-error.c:72
#, c-format
msgid "%s%s argument '%s' too large"
msgstr "%s%s 인자값 '%s'이(가) 너무 큽니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/basename.c:29 src/chgrp.c:38 src/chmod.c:39 src/chown.c:37 src/comm.c:39
#: src/cp.c:45 src/csplit.c:46 src/cut.c:45 src/date.c:40 src/dd.c:44
#: src/df.c:49 src/dirname.c:32 src/du.c:55 src/env.c:39 src/expand.c:48
#: src/fold.c:36 src/groups.c:36 src/head.c:47 src/id.c:42 src/install.c:52
#: src/ln.c:46 src/ls.c:133 src/digest.c:136 src/mkdir.c:39 src/mkfifo.c:36
#: src/mknod.c:37 src/mv.c:44 src/nice.c:40 src/nl.c:42 src/paste.c:53
#: src/pathchk.c:32 src/pinky.c:38 src/printenv.c:44 src/printf.c:69
#: src/rm.c:41 src/rmdir.c:37 src/stty.c:68 src/tac.c:58 src/tail.c:78
#: src/tee.c:38 src/touch.c:45 src/tty.c:44 src/uname.c:56 src/unexpand.c:49
#: src/uniq.c:41 src/uptime.c:46 src/users.c:36 src/wc.c:54 src/who.c:51
#: src/yes.c:32
msgid "David MacKenzie"
msgstr "David MacKenzie"

#: src/basename.c:48
#, c-format
msgid ""
"Usage: %s NAME [SUFFIX]\n"
"  or:  %s OPTION... NAME...\n"
msgstr ""
"사용법: %s <이름>[<접미부>]...\n"
"  또는:  %s <옵션>... <이름>...\n"

#: src/basename.c:53
msgid ""
"Print NAME with any leading directory components removed.\n"
"If specified, also remove a trailing SUFFIX.\n"
msgstr ""
"디렉터리 이름이 모두 빠진 파일 <이름>만 출력합니다.\n"
"접미어를 지정했을 경우 뒤따라오는 <접미어> 부분도 제거합니다.\n"

#: src/basename.c:60
msgid ""
"  -a, --multiple       support multiple arguments and treat each as a NAME\n"
"  -s, --suffix=SUFFIX  remove a trailing SUFFIX; implies -a\n"
"  -z, --zero           end each output line with NUL, not newline\n"
msgstr ""
"  -a, --multiple       다중 인자를 지원하며 각 인자를 <이름>으로 취급합니다\n"
"  -s, --suffix=<접미사>  뒤 <접미사>부를 제거합니다. -a 옵션 사용을 내포합니"
"다\n"
"  -z, --zero           각 출력 행을 개행 문자가 아닌 NUL로 끝냅니다\n"

#: src/basename.c:67
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" followed by \"str2\"\n"
msgstr ""
"\n"
"예시:\n"
"  %s /usr/bin/sort          -> \"sort\"\n"
"  %s include/stdio.h .h     -> \"stdio\"\n"
"  %s -s .h include/stdio.h  -> \"stdio\"\n"
"  %s -a any/str1 any/str2   -> \"str1\" 다음 \"str2\"\n"

#: src/basename.c:170 src/chcon.c:537 src/chgrp.c:279 src/chmod.c:530
#: src/chown.c:281 src/chroot.c:279 src/comm.c:488 src/csplit.c:1367
#: src/dirname.c:116 src/expr.c:347 src/join.c:1163 src/link.c:76
#: src/mkdir.c:261 src/mkfifo.c:135 src/mknod.c:176 src/nohup.c:107
#: src/pathchk.c:147 src/printf.c:709 src/readlink.c:145 src/realpath.c:237
#: src/rm.c:338 src/rmdir.c:239 src/seq.c:635 src/sleep.c:116 src/stat.c:1950
#: src/stdbuf.c:371 src/tr.c:1756 src/unlink.c:74
#, c-format
msgid "missing operand"
msgstr "피연산자 빠짐"

#: src/basename.c:176 src/basenc.c:1221 src/comm.c:496 src/cp.c:599
#: src/date.c:518 src/dircolors.c:477 src/du.c:1019 src/hostid.c:72
#: src/hostname.c:93 src/install.c:944 src/join.c:973 src/link.c:84
#: src/ln.c:594 src/logname.c:70 src/mknod.c:187 src/mv.c:396 src/nproc.c:115
#: src/od.c:1872 src/ptx.c:1978 src/seq.c:641 src/shuf.c:491 src/sort.c:4679
#: src/split.c:1559 src/tr.c:1771 src/tsort.c:547 src/tty.c:113 src/uname.c:265
#: src/uniq.c:521 src/uniq.c:538 src/unlink.c:80 src/uptime.c:252
#: src/users.c:145 src/wc.c:865 src/who.c:831 src/whoami.c:78
#, c-format
msgid "extra operand %s"
msgstr "추가 피연산자 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:38 src/basenc.c:41
msgid "Simon Josefsson"
msgstr "Simon Josefsson"

#. This is a proper name. See the gettext manual, section Names.
#: src/basenc.c:39 src/env.c:40 src/numfmt.c:42
msgid "Assaf Gordon"
msgstr "Assaf Gordon"

#: src/basenc.c:102 src/dircolors.c:102 src/uptime.c:199 src/users.c:105
#, c-format
msgid "Usage: %s [OPTION]... [FILE]\n"
msgstr "사용법: %s [<옵션>]... [<파일>]\n"

#: src/basenc.c:107
msgid "basenc encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"<파일> 또는 표준 입력을 basenc로 인코딩/디코딩 후 표준 출력으로 내보냅니다.\n"

#: src/basenc.c:111
#, c-format
msgid "Base%d encode or decode FILE, or standard input, to standard output.\n"
msgstr ""
"<파일> 또는 표준 입력을 Base%d(으)로 인코딩/디코딩 후 표준 출력으로 내보냅니"
"다.\n"

#: src/basenc.c:119
msgid "      --base64          same as 'base64' program (RFC4648 section 4)\n"
msgstr "      --base64          'base64' 프로그램과 동일 (RFC4648 섹션 4)\n"

#: src/basenc.c:122
msgid "      --base64url       file- and url-safe base64 (RFC4648 section 5)\n"
msgstr "      --base64url       파일, URL 보호 base64 (RFC4648 섹션 5)\n"

#: src/basenc.c:125
msgid "      --base32          same as 'base32' program (RFC4648 section 6)\n"
msgstr "      --base32          'base32' 프로그램과 동일 (RFC4648 섹션 6)\n"

#: src/basenc.c:128
msgid ""
"      --base32hex       extended hex alphabet base32 (RFC4648 section 7)\n"
msgstr "      --base32hex       확장 16진수 알파벳 base32 (RFC4648 섹션 7)\n"

#: src/basenc.c:131
msgid "      --base16          hex encoding (RFC4648 section 8)\n"
msgstr "      --base16          16진수 인코딩 (RFC4648 섹션 8)\n"

#: src/basenc.c:134
msgid ""
"      --base2msbf       bit string with most significant bit (msb) first\n"
msgstr "      --base2msbf       최상위 비트(msb) 우선 비트 문자열\n"

#: src/basenc.c:137
msgid ""
"      --base2lsbf       bit string with least significant bit (lsb) first\n"
msgstr "      --base2lsbf       최하위 비트(lsb) 우선 비트 문자열\n"

#: src/basenc.c:141
msgid ""
"  -d, --decode          decode data\n"
"  -i, --ignore-garbage  when decoding, ignore non-alphabet characters\n"
"  -w, --wrap=COLS       wrap encoded lines after COLS character (default "
"76).\n"
"                          Use 0 to disable line wrapping\n"
msgstr ""
"  -d, --decode          데이터를 디코딩합니다\n"
"  -i, --ignore-garbage  디코딩 수행시, 알파벳이 아닌 문자 무시\n"
"  -w, --wrap=<열>       <열> 문자 이상 넘어갔을 경우 인코딩한 행 줄바꿈(기본 "
"76).\n"
"                          0값을 설정하면 줄 바꿈을 하지 않습니다\n"

#: src/basenc.c:148
msgid ""
"      --z85             ascii85-like encoding (ZeroMQ spec:32/Z85);\n"
"                        when encoding, input length must be a multiple of "
"4;\n"
"                        when decoding, input length must be a multiple of 5\n"
msgstr ""
"      --z85             ascii85 유사 인코딩 (ZeroMQ spec:32/Z85);\n"
"                        인코딩 입력 길이는 4의 배수여야 하며\n"
"                        디코딩 입력 길이는 5의 배수여야 합니다\n"

#: src/basenc.c:157
msgid ""
"\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"디코딩을 수행할 때 입력 값에 일반 알파벳 바이트 내용 다음 개행 문자가\n"
"들어있을 수 있습니다.  인코딩 스트림의 비 알파벳 바이트 내용 복원을\n"
"시도하려면 --ignore-garbage 옵션을 사용해보십시오.\n"

#: src/basenc.c:164
#, c-format
msgid ""
"\n"
"The data are encoded as described for the %s alphabet in RFC 4648.\n"
"When decoding, the input may contain newlines in addition to the bytes of\n"
"the formal %s alphabet.  Use --ignore-garbage to attempt to recover\n"
"from any other non-alphabet bytes in the encoded stream.\n"
msgstr ""
"\n"
"RFC 4648의 %s 알파벳에서 설명한 바와 같이 데이터를 인코딩합니다.\n"
"디코딩할 때는, %s 알파벳 바이트열에 개행 문자가 추가로 들어갈 수 \n"
"있습니다. 인코딩 스트림에 비 알파벳 표현 바이트 복원을 시도하려면\n"
"--ignore-garbage 옵션을 사용해보십시오.\n"

#: src/basenc.c:618
msgid "invalid input (length must be multiple of 4 characters)"
msgstr "잘못된 입력 (4의 배수 글자 길이여야 함)"

#: src/basenc.c:958 src/cat.c:802 src/fmt.c:451
msgid "closing standard input"
msgstr "표준 입력을 닫습니다"

#: src/basenc.c:1005 src/basenc.c:1049 src/csplit.c:273 src/csplit.c:1434
#: src/fmt.c:503 src/join.c:469 src/shuf.c:233 src/shuf.c:279 src/shuf.c:560
#: src/tac-pipe.c:76 src/tee.c:263 src/tr.c:1614
#, c-format
msgid "read error"
msgstr "읽기 오류"

#: src/basenc.c:1068
msgid "invalid input"
msgstr "부적절한 입력"

#: src/basenc.c:1115
msgid "invalid wrap size"
msgstr "부적절한 줄바꿈 길이"

#: src/basenc.c:1214
#, c-format
msgid "missing encoding type"
msgstr "인코딩 형식 빠짐"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:50 src/cp.c:44 src/df.c:48 src/du.c:54 src/factor.c:123
#: src/split.c:50
msgid "Torbjorn Granlund"
msgstr "Torbjorn Granlund"

#. This is a proper name. See the gettext manual, section Names.
#: src/cat.c:51 src/comm.c:38 src/ls.c:132 src/rm.c:42 src/split.c:51
#: src/tee.c:37 src/uniq.c:40
msgid "Richard M. Stallman"
msgstr "Richard M. Stallman"

#: src/cat.c:93 src/df.c:1534 src/expand.c:68 src/fold.c:66 src/head.c:110
#: src/ls.c:5402 src/digest.c:405 src/nl.c:179 src/paste.c:433 src/pr.c:2745
#: src/rm.c:133 src/tac.c:132 src/tail.c:266 src/tee.c:87 src/unexpand.c:77
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "사용법: %s [<옵션>]... [<파일>]...\n"

#: src/cat.c:97
msgid "Concatenate FILE(s) to standard output.\n"
msgstr "<파일> 내용을 표준 출력으로 결합합니다.\n"

#: src/cat.c:103
msgid ""
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonempty output lines, overrides -n\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      suppress repeated empty output lines\n"
msgstr ""
"\n"
"  -A, --show-all           -vET 옵션과 동일\n"
"  -b, --number-nonblank    비어있지 않은 출력 행에 번호를 부여합니다. -n보다 "
"우선함.\n"
"  -e                       -vE 옵션과 동일\n"
"  -E, --show-ends          각 행의 마지막에 $ 기호를 표시합니다\n"
"  -n, --number             모든 행에 행 번호를 부여합니다\n"
"  -s, --squeeze-blank      반복 공백행의 출력을 숨깁니다\n"

#: src/cat.c:112
msgid ""
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
msgstr ""
"  -t                       -vT와 같음\n"
"  -T, --show-tabs          탭 문자를 ^I로 표시합니다\n"
"  -u                       (무시됨)\n"
"  -v, --show-nonprinting   ^ 와 M- 표기법을 사용합니다 (LFD와 TAB 제외)\n"

#: src/cat.c:120
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s f - g  Output f's contents, then standard input, then g's contents.\n"
"  %s        Copy standard input to standard output.\n"
msgstr ""
"\n"
"예제:\n"
"  %s f - g  f의 내용을, 그 다음 표준 입력의 내용을, 그 다음 g의 내용을 출력합"
"니다.\n"
"  %s        표준 입력의 내용을 그대로 표준 출력으로 복사합니다.\n"

#: src/cat.c:301
#, c-format
msgid "cannot do ioctl on %s"
msgstr "%s에서 ioctl 처리할 수 없습니다"

#: src/cat.c:646 src/dd.c:2470 src/sort.c:408 src/tail.c:2427 src/tee.c:207
#: src/yes.c:128
#, c-format
msgid "standard output"
msgstr "표준 출력"

#: src/cat.c:715
#, c-format
msgid "%s: input file is output file"
msgstr "%s: 입력 파일이 출력 파일입니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:37 src/runcon.c:57
msgid "Russell Coker"
msgstr "Russell Coker"

#. This is a proper name. See the gettext manual, section Names.
#: src/chcon.c:38 src/chgrp.c:39 src/chmod.c:40 src/chown.c:38 src/cp.c:46
#: src/cut.c:46 src/dirname.c:33 src/du.c:57 src/head.c:48 src/hostid.c:32
#: src/hostname.c:33 src/mktemp.c:36 src/mv.c:45 src/nohup.c:34 src/od.c:40
#: src/pathchk.c:33 src/pwd.c:32 src/rm.c:43 src/sleep.c:34 src/sync.c:33
#: src/tail.c:80 src/tr.c:38 src/true.c:33
msgid "Jim Meyering"
msgstr "Jim Meyering"

#: src/chcon.c:101 src/runcon.c:201 src/runcon.c:232
#, c-format
msgid "failed to create security context: %s"
msgstr "보안 컨텍스트 만들기 실패: %s"

#: src/chcon.c:113
#, c-format
msgid "failed to set %s security context component to %s"
msgstr "%2$s(으)로의 %1$s 보안 컨텍스트 요소 설정에 실패했습니다"

#: src/chcon.c:157 src/chcon.c:548 src/copy.c:947 src/runcon.c:215
#: src/stat.c:848
#, c-format
msgid "failed to get security context of %s"
msgstr "%s 보안 컨텍스트 가져오기 실패"

#: src/chcon.c:167
#, c-format
msgid "can't apply partial context to unlabeled file %s"
msgstr "레이블 없는 %s 파일에 일부 컨텍스트를 적용할 수 없습니다"

#: src/chcon.c:191
#, c-format
msgid "failed to change context of %s to %s"
msgstr "%s에서 %s(으)로의 보안 컨텍스트 전환 실패"

#: src/chcon.c:256 src/chmod.c:232 src/chown-core.c:340 src/copy.c:744
#: src/du.c:533 src/ls.c:3461
#, c-format
msgid "cannot access %s"
msgstr "%s에 접근할 수 없음"

#: src/chcon.c:267 src/chmod.c:243 src/chown-core.c:353 src/du.c:513
#, c-format
msgid "cannot read directory %s"
msgstr "%s 디렉터리를 읽을 수 없음"

#: src/chcon.c:294
#, c-format
msgid "changing security context of %s\n"
msgstr "%s의 보안 컨텍스트 전환 중\n"

#: src/chcon.c:328 src/chmod.c:350 src/chown-core.c:564 src/remove.c:603
#, c-format
msgid "fts_read failed"
msgstr "fts_read 실패"

#: src/chcon.c:339 src/chmod.c:361 src/chown-core.c:576 src/du.c:714
#: src/remove.c:617
#, c-format
msgid "fts_close failed"
msgstr "fts_close 실패"

#: src/chcon.c:353
#, c-format
msgid ""
"Usage: %s [OPTION]... CONTEXT FILE...\n"
"  or:  %s [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"사용법: %s [<옵션>]... <컨텍스트> <파일>...\n"
"  또는: %s [<옵션>]... [-u <사용자>] [-r <역할>] [-l <범위>] [-t <형식>] <파"
"일>...\n"
"  또는: %s [<옵션>]... --reference=<참조파일> <파일>...\n"

#: src/chcon.c:359
msgid ""
"Change the SELinux security context of each FILE to CONTEXT.\n"
"With --reference, change the security context of each FILE to that of "
"RFILE.\n"
msgstr ""
"각 <파일>의 SELinux 보안 컨텍스트를 <컨텍스트>로 설정합니다.\n"
"--reference 옵션을 주면 각 <파일>의 보안 컨텍스트를 <참조파일>\n"
"의 보안 컨텍스트로 바꿉니다.\n"

#: src/chcon.c:366 src/chgrp.c:125 src/chown.c:95
msgid ""
"      --dereference      affect the referent of each symbolic link (this is\n"
"                         the default), rather than the symbolic link itself\n"
"  -h, --no-dereference   affect symbolic links instead of any referenced "
"file\n"
msgstr ""
"      --dereference      심볼릭 링크 자체에 영향을 주기보다는, 각 심볼릭 링크"
"의\n"
"                          참조에 영향을 줍니다(기본값) \n"
"  -h, --no-dereference   참조 파일 대신 심볼릭 링크에 영향을 줍니다\n"

#: src/chcon.c:371
msgid ""
"  -u, --user=USER        set user USER in the target security context\n"
"  -r, --role=ROLE        set role ROLE in the target security context\n"
"  -t, --type=TYPE        set type TYPE in the target security context\n"
"  -l, --range=RANGE      set range RANGE in the target security context\n"
msgstr ""
"  -u, --user=<사용자>    대상 보안 컨텍스트의 <사용자>를 설정합니다\n"
"  -r, --role=<역할>      대상 보안 컨텍스트의 <역할>을 설정합니다\n"
"  -t, --type=<형식>      대상 보안 컨텍스트의 <형식>을 설정합니다\n"
"  -l, --range=<범위>     대상 보안 컨텍스트의 <범위>를 설정합니다\n"

#: src/chcon.c:377 src/chgrp.c:134 src/chmod.c:391 src/chown.c:111
msgid ""
"      --no-preserve-root  do not treat '/' specially (the default)\n"
"      --preserve-root    fail to operate recursively on '/'\n"
msgstr ""
"      --no-preserve-root  '/'를 특별하게 다루지 않습니다 (기본)\n"
"      --preserve-root    '/' 경로의 하위 연속 처리 요청에 실패를 반환합니다\n"

#: src/chcon.c:381
msgid ""
"      --reference=RFILE  use RFILE's security context rather than "
"specifying\n"
"                         a CONTEXT value\n"
msgstr ""
"      --reference=<참조파일>  지정한 <컨텍스트> 값 대신 <참조파일>의\n"
"                         컨텍스트로 바꿉니다\n"

#: src/chcon.c:385 src/chgrp.c:142 src/chown.c:119
msgid "  -R, --recursive        operate on files and directories recursively\n"
msgstr "  -R, --recursive        하위 파일과 디렉터리도 처리합니다\n"

#: src/chcon.c:388
msgid "  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -v, --verbose          모든 파일 처리 과정에 대한 판별 가능 내용을 출력합니"
"다\n"

#: src/chcon.c:391 src/chgrp.c:145 src/chown.c:122
msgid ""
"\n"
"The following options modify how a hierarchy is traversed when the -R\n"
"option is also specified.  If more than one is specified, only the final\n"
"one takes effect.\n"
"\n"
"  -H                     if a command line argument is a symbolic link\n"
"                         to a directory, traverse it\n"
"  -L                     traverse every symbolic link to a directory\n"
"                         encountered\n"
"  -P                     do not traverse any symbolic links (default)\n"
"\n"
msgstr ""
"\n"
"다음 옵션은 -R 옵션도 지정했을 때 계층을 순회하는 방식을 조정합니다.\n"
"하나 이상 지정하면 마지막 옵션 하나만 동작합니다.\n"
"\n"
"  -H                     명령행 인자가 디렉터리 대상 심볼릭 링크라면\n"
"                         방문 진입합니다\n"
"  -L                     확인한 모든 디렉터리 심볼릭 링크를 방문 진입\n"
"                         합니다\n"
"  -P                     어떤 심볼릭 링크에도 방문 진입하지 않습니다(기본"
"값)\n"
"\n"

#: src/chcon.c:518 src/chgrp.c:266 src/chown.c:268
msgid "-R --dereference requires either -H or -L"
msgstr "-R --dereference 옵션에 -H 또는 -L 옵션이 필요합니다"

#: src/chcon.c:524
msgid "-R -h requires -P"
msgstr "-R -h 옵션에 -P 옵션이 필요합니다"

#: src/chcon.c:539 src/chgrp.c:281 src/chmod.c:532 src/chown.c:283
#: src/comm.c:490 src/csplit.c:1369 src/join.c:1165 src/link.c:78
#: src/mknod.c:178 src/tr.c:1759
#, c-format
msgid "missing operand after %s"
msgstr "%s 뒤 피연산자 빠짐"

#: src/chcon.c:563 src/runcon.c:249
#, c-format
msgid "invalid context: %s"
msgstr "부적절한 컨텍스트: %s"

#: src/chcon.c:569
#, c-format
msgid "conflicting security context specifiers given"
msgstr "겹치는 보안 컨텍스트 지정자를 제시했습니다"

#: src/chcon.c:578 src/chgrp.c:289 src/chgrp.c:307 src/chmod.c:540
#: src/chmod.c:559 src/chown.c:291 src/chown.c:322 src/cp.c:427 src/cp.c:494
#: src/mv.c:97 src/pwd.c:276 src/rm.c:348 src/touch.c:352
#, c-format
msgid "failed to get attributes of %s"
msgstr "%s 속성 가져오기 실패"

#: src/chgrp.c:93
#, c-format
msgid "invalid group: %s"
msgstr "잘못된 그룹: %s"

#: src/chgrp.c:110
#, c-format
msgid ""
"Usage: %s [OPTION]... GROUP FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"사용법: %s [<옵션>]... <그룹> <파일>...\n"
"  또는:  %s [<옵션>]... --reference=<참조파일> <파일>...\n"

#: src/chgrp.c:115
msgid ""
"Change the group of each FILE to GROUP.\n"
"With --reference, change the group of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"각 <파일>의 그룹을 <그룹>으로 바꿉니다.\n"
"--reference 옵션을 주면 각 <파일>의 그룹을 <참조파일>\n"
"의 그룹으로 바꿉니다.\n"
"\n"
"\n"

#: src/chgrp.c:120 src/chmod.c:386 src/chown.c:90
msgid ""
"  -c, --changes          like verbose but report only when a change is made\n"
"  -f, --silent, --quiet  suppress most error messages\n"
"  -v, --verbose          output a diagnostic for every file processed\n"
msgstr ""
"  -c, --changes          자세한 출력 모드와 같지만 바뀐 내용이 있을 때만 알립"
"니다\n"
"  -f, --silent, --quiet  대부분의 오류메시지를 숨깁니다\n"
"  -v, --verbose          처리되는 모든 파일에 대해 진단 메시지를 출력합니다\n"

#: src/chgrp.c:130 src/chown.c:100
msgid ""
"                         (useful only on systems that can change the\n"
"                         ownership of a symlink)\n"
msgstr ""
"                         (심볼릭 링크 소유권을 바꿀 수 있는 시스템에만\n"
"                         해당합니다)\n"

#: src/chgrp.c:138
msgid ""
"      --reference=RFILE  use RFILE's group rather than specifying a\n"
"                         GROUP value\n"
msgstr ""
"      --reference=<참조파일>  지정한 <그룹> 값 대신 <참조파일>의\n"
"                         그룹으로 바꿉니다\n"

#: src/chgrp.c:160
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s staff /u      Change the group of /u to \"staff\".\n"
"  %s -hR staff /u  Change the group of /u and subfiles to \"staff\".\n"
msgstr ""
"\n"
"예제:\n"
"  %s staff /u      /u의 그룹을 \"staff\"으로 바꿉니다.\n"
"  %s -hR staff /u  /u와 하위 파일의 그룹을 \"staff\"으로 바꿉니다.\n"

#: src/chmod.c:134
#, c-format
msgid "getting new attributes of %s"
msgstr "%s의 새 속성 가져오는 중"

#: src/chmod.c:159 src/chown-core.c:162
#, c-format
msgid "neither symbolic link %s nor referent has been changed\n"
msgstr "심볼릭 링크 %s도, 이를 가리키는 원래 파일도 바뀌지 않았습니다\n"

#: src/chmod.c:164
#, c-format
msgid "%s could not be accessed\n"
msgstr "%s에 접근할 수 없습니다\n"

#: src/chmod.c:184
#, c-format
msgid "mode of %s changed from %04lo (%s) to %04lo (%s)\n"
msgstr "%s의 모드를 %04lo (%s)에서 %04lo (%s)(으)로 바꾸었습니다\n"

#: src/chmod.c:187
#, c-format
msgid "failed to change mode of %s from %04lo (%s) to %04lo (%s)\n"
msgstr "%s의 모드를 %04lo (%s)에서 %04lo (%s)(으)로 바꾸기 실패\n"

#: src/chmod.c:190
#, c-format
msgid "mode of %s retained as %04lo (%s)\n"
msgstr "%s의 모드를 %04lo(%s)으로 유지하였습니다\n"

#: src/chmod.c:249
#, c-format
msgid "cannot operate on dangling symlink %s"
msgstr "%s 연속 심볼릭 링크를 처리할 수 없습니다"

#: src/chmod.c:286
#, c-format
msgid "changing permissions of %s"
msgstr "%s의 권한 바꾸는 중"

#: src/chmod.c:315
#, c-format
msgid "%s: new permissions are %s, not %s"
msgstr "%1$s: 새 권한은 %3$s이(가) 아닌 %2$s 입니다"

#: src/chmod.c:375
#, c-format
msgid ""
"Usage: %s [OPTION]... MODE[,MODE]... FILE...\n"
"  or:  %s [OPTION]... OCTAL-MODE FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"사용법: %s [옵션]... <모드>[,<모드>]... <파일>...\n"
"  또는: %s [옵션]... 8진수-<모드> <파일>...\n"
"  또는: %s [옵션]... --reference=<참조파일> <파일>...\n"

#: src/chmod.c:381
msgid ""
"Change the mode of each FILE to MODE.\n"
"With --reference, change the mode of each FILE to that of RFILE.\n"
"\n"
msgstr ""
"각 <파일>의 모드를 <모드>로 바꿉니다.\n"
"--reference 옵션을 주면 각 <파일>의 모드를 <참조파일>\n"
"의 모드로 바꿉니다.\n"
"\n"

#: src/chmod.c:395
msgid "      --reference=RFILE  use RFILE's mode instead of MODE values\n"
msgstr ""
"      --reference=<참조파일>  지정한 <모드> 값 대신 <참조파일>의\n"
"                         모드로 바꿉니다\n"

#: src/chmod.c:398
msgid "  -R, --recursive        change files and directories recursively\n"
msgstr "  -R, --recursive        하위 파일과 디렉터리의 값도 바꿉니다\n"

#: src/chmod.c:403
msgid ""
"\n"
"Each MODE is of the form '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+'.\n"
msgstr ""
"\n"
"각 <모드> 값은 '[ugoa]*([-+=]([rwxXst]*|[ugo]))+|[-+=][0-7]+' 형태를 지닙니"
"다.\n"

#: src/chmod.c:517
#, c-format
msgid "cannot combine mode and --reference options"
msgstr "모드와 --reference 옵션을 혼용할 수 없습니다"

#: src/chmod.c:548
#, c-format
msgid "invalid mode: %s"
msgstr "부적절한 모드: %s"

#: src/chown-core.c:173
#, c-format
msgid "changed ownership of %s from %s to %s\n"
msgstr "%s의 소유권을 %s에서 %s(으)로 바꾸었습니다\n"

#: src/chown-core.c:174
#, c-format
msgid "changed group of %s from %s to %s\n"
msgstr "%s의 그룹을 %s에서 %s(으)로 바꾸었습니다\n"

#: src/chown-core.c:175
#, c-format
msgid "no change to ownership of %s\n"
msgstr "%s의 소유권을 바꾸지 않음\n"

#: src/chown-core.c:180
#, c-format
msgid "failed to change ownership of %s from %s to %s\n"
msgstr "%s의 소유권을 %s에서 %s(으)로 바꾸기 실패\n"

#: src/chown-core.c:181
#, c-format
msgid "failed to change group of %s from %s to %s\n"
msgstr "%s의 그룹을 %s에서 %s(으)로 바꾸기 실패\n"

#: src/chown-core.c:182 src/chown-core.c:188
#, c-format
msgid "failed to change ownership of %s\n"
msgstr "%s의 소유권 바꾸기 실패\n"

#: src/chown-core.c:186
#, c-format
msgid "failed to change ownership of %s to %s\n"
msgstr "%s의 소유권을 %s(으)로 바꾸기 실패\n"

#: src/chown-core.c:187
#, c-format
msgid "failed to change group of %s to %s\n"
msgstr "%s의 그룹을 %s(으)로 바꾸기 실패\n"

#: src/chown-core.c:195
#, c-format
msgid "ownership of %s retained as %s\n"
msgstr "%s의 소유권을 %s(으)로 유지함\n"

#: src/chown-core.c:196
#, c-format
msgid "group of %s retained as %s\n"
msgstr "%s의 그룹을 %s(으)로 유지했습니다\n"

#: src/chown-core.c:197
#, c-format
msgid "ownership of %s retained\n"
msgstr "%s의 소유권 유지함\n"

#: src/chown-core.c:394
#, c-format
msgid "cannot dereference %s"
msgstr "%s을(를) 역참조할 수 없음"

#: src/chown-core.c:482
#, c-format
msgid "changing ownership of %s"
msgstr "%s의 소유권 바꾸는 중"

#: src/chown-core.c:483
#, c-format
msgid "changing group of %s"
msgstr "%s 그룹 바꾸는 중"

#: src/chown.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... [OWNER][:[GROUP]] FILE...\n"
"  or:  %s [OPTION]... --reference=RFILE FILE...\n"
msgstr ""
"사용법: %s [<옵션>]... [<소유자>][:[<그룹>]] <파일>...\n"
"  또는:  %s [<옵션>]... --reference=<참조파일> <파일>...\n"

#: src/chown.c:85
msgid ""
"Change the owner and/or group of each FILE to OWNER and/or GROUP.\n"
"With --reference, change the owner and group of each FILE to those of "
"RFILE.\n"
"\n"
msgstr ""
"각 <파일>의 소유자와(또는) 그룹을 <소유자>와 <그룹>으로 바꿉니다.\n"
"--reference 옵션을 주면 각 <파일>의 소유자와 그룹을 <참조파일>\n"
"의 소유자와 그룹으로 바꿉니다.\n"
"\n"

#: src/chown.c:104
msgid ""
"      --from=CURRENT_OWNER:CURRENT_GROUP\n"
"                         change the owner and/or group of each file only if\n"
"                         its current owner and/or group match those "
"specified\n"
"                         here.  Either may be omitted, in which case a "
"match\n"
"                         is not required for the omitted attribute\n"
msgstr ""
"      --from=<현재_소유자>:<현재_그룹>\n"
"                         이 옵션으로 지정한 소유주와 그룹 값이 일치하는 경우"
"에만\n"
"                         소유주와 그룹 설정을 바꿉니다. 속성을 생략하여 조건"
"을\n"
"                         일치할 필요가 없을 경우 이 옵션을 생략할 수 있습니"
"다\n"

#: src/chown.c:115
msgid ""
"      --reference=RFILE  use RFILE's owner and group rather than\n"
"                         specifying OWNER:GROUP values\n"
msgstr ""
"      --reference=<참조파일>  지정한 <소유자:그룹> 값 대신 <참조파일>의\n"
"                         소유자:그룹으로 바꿉니다\n"

#: src/chown.c:137
msgid ""
"\n"
"Owner is unchanged if missing.  Group is unchanged if missing, but changed\n"
"to login group if implied by a ':' following a symbolic OWNER.\n"
"OWNER and GROUP may be numeric as well as symbolic.\n"
msgstr ""
"\n"
"소유자 값이 빠지면 바뀌지 않습니다.  그룹 값이 빠지면 바뀌지 않지만\n"
"심볼릭 <소유자> 뒤에 ':'을 입력 후 생략할 때는 바뀔 수 있습니다.\n"
"<소유자>와 <그룹>은 심볼릭 값일 수도 있고 숫자 값일 수도 있습니다.\n"

#: src/chown.c:143
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s root /u        Change the owner of /u to \"root\".\n"
"  %s root:staff /u  Likewise, but also change its group to \"staff\".\n"
"  %s -hR root /u    Change the owner of /u and subfiles to \"root\".\n"
msgstr ""
"\n"
"예제:\n"
"  %s root /u        /u 디렉터리의 소유자를 \"root\"로 바꿉니다.\n"
"  %s root:staff /u  마찬가지이며, 또한 그룹을\"staff\"으로 바꿉니다.\n"
"  %s -hR root /u    /u 디렉터리와 하위 파일의 소유자를 \"root\"로 바꿉니다.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/chroot.c:39
msgid "Roland McGrath"
msgstr "Roland McGrath"

#: src/chroot.c:139 src/install.c:552
#, c-format
msgid "invalid group %s"
msgstr "잘못된 그룹 %s"

#: src/chroot.c:154
#, c-format
msgid "invalid group list %s"
msgstr "잘못된 그룹 목록 %s"

#: src/chroot.c:187
#, c-format
msgid ""
"Usage: %s [OPTION] NEWROOT [COMMAND [ARG]...]\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s [<옵션>] <새루트> [<명령> [<인자>]...]\n"
"  또는:  %s <옵션>\n"

#: src/chroot.c:192
msgid ""
"Run COMMAND with root directory set to NEWROOT.\n"
"\n"
msgstr ""
"루트 디렉터리를 <새루트>로 지정하는 <명령>을 실행합니다.\n"
"\n"

#: src/chroot.c:197
msgid ""
"      --groups=G_LIST        specify supplementary groups as g1,g2,..,gN\n"
msgstr ""
"      --groups=<그룹목록>        g1,g2,..,gN과 같이 여러 그룹을 지정합니다\n"

#: src/chroot.c:200
msgid ""
"      --userspec=USER:GROUP  specify user and group (ID or name) to use\n"
msgstr ""
"      --userspec=<사용자>:<그룹>  사용할 사용자와 그룹(ID또는 이름)을 지정합"
"니다\n"

#: src/chroot.c:203
#, c-format
msgid "      --skip-chdir           do not change working directory to %s\n"
msgstr ""
"      --skip-chdir           %s(으)로 작업 디렉터리를 바꾸지 않습니다\n"

#: src/chroot.c:209
msgid ""
"\n"
"If no command is given, run '\"$SHELL\" -i' (default: '/bin/sh -i').\n"
msgstr ""
"\n"
"지정한 명령이 없다면 '\"$SHELL\" -i'를 실행합니다 (기본: '/bin/sh -i').\n"

#: src/chroot.c:288
#, c-format
msgid "option --skip-chdir only permitted if NEWROOT is old %s"
msgstr "--skip-chdir 옵션은 <새루트>가 이전 %s 위치일 경우에만 적용합니다"

#: src/chroot.c:331
#, c-format
msgid "cannot change root directory to %s"
msgstr "%s(으)로 루트 디렉터리 위치를 바꿀 수 없습니다"

#: src/chroot.c:335
msgid "cannot chdir to root directory"
msgstr "루트 디렉터리로 chdir 명령을 수행할 수 없습니다"

#: src/chroot.c:378
#, c-format
msgid "no group specified for unknown uid: %d"
msgstr "알 수 없는 uid에 지정한 그룹이 없습니다: %d"

#: src/chroot.c:403
msgid "failed to get supplemental groups"
msgstr "추가 그룹 정보를 가져올 수 없습니다"

#: src/chroot.c:415
msgid "failed to set supplemental groups"
msgstr "추가 그룹 정보를 설정할 수 없습니다"

#: src/chroot.c:421
msgid "failed to set group-ID"
msgstr "그룹 ID 설정 실패"

#: src/chroot.c:424
msgid "failed to set user-ID"
msgstr "사용자 ID 설정 실패"

#: src/chroot.c:430 src/nohup.c:222 src/stdbuf.c:392 src/timeout.c:552
#, c-format
msgid "failed to run command %s"
msgstr "%s 명령 실행 실패"

#: src/cksum.c:170 src/wc.c:166
msgid "failed to get cpuid"
msgstr "CPUID 가져오기 실패"

#: src/cksum.c:177
msgid "pclmul support not detected"
msgstr "pclmul 지원을 발견하지 못했습니다"

#: src/cksum.c:182
msgid "using pclmul hardware support"
msgstr "pclmul 하드웨어 지원 사용"

#: src/cksum.c:187
msgid "using generic hardware support"
msgstr "일반 하드웨어 지원 사용"

#: src/comm.c:112 src/join.c:192
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "사용법: %s [<옵션>]... <파일1> <파일2>\n"

#: src/comm.c:116
msgid "Compare sorted files FILE1 and FILE2 line by line.\n"
msgstr "정렬한 <파일1>과 <파일2>를 행별로 비교합니다.\n"

#: src/comm.c:119 src/join.c:201
msgid ""
"\n"
"When FILE1 or FILE2 (not both) is -, read standard input.\n"
msgstr ""
"\n"
"<파일1> 또는 <파일2> (둘 다는 아님) 값이 - 일 경우, \n"
"표준 입력에서 데이터를 읽습니다.\n"

#: src/comm.c:123
msgid ""
"\n"
"With no options, produce three-column output.  Column one contains\n"
"lines unique to FILE1, column two contains lines unique to FILE2,\n"
"and column three contains lines common to both files.\n"
msgstr ""
"\n"
"어떤 옵션도 지정하지 않으면, 3열 출력을 나타냅니다.  첫번째 열에는\n"
"<파일1>에 유일하게 들어있는 행, 두번째 열에는 <파일2>에 유일하게 \n"
"들어있는 행, 세번째 열에는 두 파일에 들어있는 행이 나타납니다.\n"

#: src/comm.c:129
msgid ""
"\n"
"  -1                      suppress column 1 (lines unique to FILE1)\n"
"  -2                      suppress column 2 (lines unique to FILE2)\n"
"  -3                      suppress column 3 (lines that appear in both "
"files)\n"
msgstr ""
"\n"
"  -1                      첫번째 열 숨김 (<파일1>에만 있는 행)\n"
"  -2                      두번째 열 숨김 (<파일2>에만 있는 행)\n"
"  -3                      세번째 열 숨김 (두 파일에 있는 행)\n"

#: src/comm.c:135
msgid ""
"\n"
"      --check-order       check that the input is correctly sorted, even\n"
"                            if all input lines are pairable\n"
"      --nocheck-order     do not check that the input is correctly sorted\n"
msgstr ""
"\n"
"      --check-order       모든 입력 행을 짝지을 수 있는 상황에서\n"
"                            입력을 제대로 정렬했는지 확인합니다\n"
"      --nocheck-order     입력을 제대로 정렬했는지 확인하지 않음\n"

#: src/comm.c:141
msgid "      --output-delimiter=STR  separate columns with STR\n"
msgstr "      --output-delimiter=<문자열>  열을 <문자열>로 분리합니다\n"

#: src/comm.c:144
msgid "      --total             output a summary\n"
msgstr "      --total             요약을 출력합니다\n"

#: src/comm.c:147
msgid "  -z, --zero-terminated   line delimiter is NUL, not newline\n"
msgstr "  -z, --zero-terminated   행 종결자는 개행 문자가 아닌 NUL입니다\n"

#: src/comm.c:152
msgid ""
"\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
msgstr ""
"\n"
"참고로, 비교 우선순위 규칙은 'LC_COLLATE'로 지정합니다.\n"

#: src/comm.c:156
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s -12 file1 file2  Print only lines present in both file1 and file2.\n"
"  %s -3 file1 file2  Print lines in file1 not in file2, and vice versa.\n"
msgstr ""
"\n"
"예제:\n"
"  %s -12 파일1 파일2  파일1과 파일2에 둘 다 있는 행만 출력합니다.\n"
"  %s -3 파일1 파일2  파일2에 없는 파일1의 내용, 또는 그 반대 경우의 행만 출력"
"합니다.\n"

#: src/comm.c:238
#, c-format
msgid "file %d is not in sorted order"
msgstr "%d 파일은 정렬 상태가 아닙니다"

#: src/comm.c:403 src/du.c:1137 src/ls.c:3097 src/wc.c:992
msgid "total"
msgstr "합계"

#: src/comm.c:407 src/join.c:1199
msgid "input is not in sorted order"
msgstr "입력이 정렬 상태가 아닙니다"

#: src/comm.c:465
msgid "multiple output delimiters specified"
msgstr "다중 출력 구분자를 지정했습니다"

#: src/copy.c:209 src/copy.c:581 src/copy.c:1311
#, c-format
msgid "cannot lseek %s"
msgstr "%s을(를) 좌측 방향 탐색(lseek)할 수 없습니다"

#: src/copy.c:219 src/copy.c:574
#, c-format
msgid "error deallocating %s"
msgstr "%s 할당 해제 중 오류"

#: src/copy.c:287
#, c-format
msgid "error copying %s to %s"
msgstr "%s을(를) %s(으)로 복사 오류"

#: src/copy.c:309 src/dd.c:1894 src/dd.c:2218 src/du.c:1134 src/head.c:157
#: src/head.c:308 src/head.c:390 src/head.c:587 src/head.c:669 src/head.c:738
#: src/head.c:788 src/head.c:811 src/tail.c:469 src/tail.c:562 src/tail.c:610
#: src/tail.c:703 src/tail.c:830 src/tail.c:878 src/tail.c:915 src/tail.c:2023
#: src/tail.c:2056 src/uniq.c:462
#, c-format
msgid "error reading %s"
msgstr "%s 읽는 중 오류"

#: src/copy.c:342 src/dd.c:2281 src/dd.c:2344 src/head.c:185 src/tail.c:443
#, c-format
msgid "error writing %s"
msgstr "%s 쓰는 중 오류"

#: src/copy.c:371
#, c-format
msgid "overflow reading %s"
msgstr "%s 읽는 중 오버플로우"

#: src/copy.c:517
#, c-format
msgid "%s: write failed"
msgstr "%s: 쓰기 실패"

#: src/copy.c:567 src/copy.c:1371
#, c-format
msgid "failed to extend %s"
msgstr "%s 확장 실패"

#: src/copy.c:829
#, c-format
msgid "clearing permissions for %s"
msgstr "%s 권한 지우는 중"

#: src/copy.c:864 src/copy.c:2890 src/cp.c:312
#, c-format
msgid "failed to preserve ownership for %s"
msgstr "%s 소유권 유지 실패"

#: src/copy.c:890
#, c-format
msgid "failed to lookup file %s"
msgstr "%s 파일 탐색 실패"

#: src/copy.c:895
#, c-format
msgid "failed to preserve authorship for %s"
msgstr "%s 작성권 유지 실패"

#: src/copy.c:932 src/cp.c:1202 src/install.c:918 src/mkdir.c:278
#: src/mkfifo.c:149 src/mknod.c:205
#, c-format
msgid "failed to set default file creation context to %s"
msgstr "%s로의 기본 파일 생성 컨텍스트 지정 실패"

#: src/copy.c:962
#, c-format
msgid "failed to set default file creation context for %s"
msgstr "%s의 기본 파일 생성 컨텍스트 지정 실패"

#: src/copy.c:988
#, c-format
msgid "failed to set the security context of %s"
msgstr "%s의 보안 컨텍스트 지정 실패"

#: src/copy.c:1101 src/csplit.c:620 src/du.c:1026 src/fmt.c:442 src/head.c:890
#: src/split.c:1575 src/tail.c:1997 src/wc.c:877
#, c-format
msgid "cannot open %s for reading"
msgstr "%s을(를) 읽기 용도로 열 수 없습니다"

#: src/copy.c:1107 src/copy.c:1286 src/dd.c:1818 src/dd.c:2356 src/dd.c:2515
#: src/head.c:849 src/tail.c:1837 src/tail.c:1900 src/truncate.c:114
#, c-format
msgid "cannot fstat %s"
msgstr "%s 파일 상태 정보 확인 불가"

#: src/copy.c:1117
#, c-format
msgid "skipping file %s, as it was replaced while being copied"
msgstr "복사중 내용이 바뀌어 %s 파일 건너뜀"

#: src/copy.c:1158 src/copy.c:1882 src/copy.c:2304 src/remove.c:376
#, c-format
msgid "removed %s\n"
msgstr "%s을(를) 제거했습니다\n"

#: src/copy.c:1162 src/copy.c:2299 src/remove.c:263 src/remove.c:280
#: src/remove.c:407 src/remove.c:433
#, c-format
msgid "cannot remove %s"
msgstr "%s을(를) 제거할 수 없습니다"

#: src/copy.c:1241
#, c-format
msgid "not writing through dangling symlink %s"
msgstr "%s 연속 심볼릭 링크에 쓰지 않음"

#: src/copy.c:1262
#, c-format
msgid "cannot create regular file %s"
msgstr "%s 일반 파일을 만들 수 없습니다"

#: src/copy.c:1275
#, c-format
msgid "failed to clone %s from %s"
msgstr "%2$s에서 %1$s 복제 실패"

#: src/copy.c:1385 src/copy.c:2962
#, c-format
msgid "preserving times for %s"
msgstr "%s의 시간을 유지합니다"

#: src/copy.c:1454 src/copy.c:1460 src/head.c:898 src/sync.c:164
#: src/touch.c:168 src/truncate.c:378
#, c-format
msgid "failed to close %s"
msgstr "%s 닫기 실패"

#: src/copy.c:1741
#, c-format
msgid "%s: replace %s, overriding mode %04lo (%s)? "
msgstr "%s: %s에 모드 %04lo (%s)(으)로 덮어쓸까요? "

#: src/copy.c:1742
#, c-format
msgid "%s: unwritable %s (mode %04lo, %s); try anyway? "
msgstr "%s: %s 기록할 수 없음 (모드 %04lo, %s); 그래도 시도할까요? "

#: src/copy.c:1749
#, c-format
msgid "%s: overwrite %s? "
msgstr "%s: %s을(를) 덮어쓸까요? "

#: src/copy.c:1826
#, c-format
msgid " (backup: %s)"
msgstr " (백업: %s)"

#: src/copy.c:1836
msgid "failed to restore the default file creation context"
msgstr "기본 파일 생성 컨텍스트 복원에 실패했습니다"

#: src/copy.c:1876
#, c-format
msgid "cannot create hard link %s to %s"
msgstr "%s -> %s 하드 링크를 만들 수 없습니다"

#: src/copy.c:2000
#, c-format
msgid "-r not specified; omitting directory %s"
msgstr "-r을 지정하지 않음. %s 디렉터리 생략"

#: src/copy.c:2001
#, c-format
msgid "omitting directory %s"
msgstr "%s 디렉터리 생략"

#: src/copy.c:2024
#, c-format
msgid "warning: source file %s specified more than once"
msgstr "경고: %s 원본 파일을 한 번 이상 지정했습니다"

#: src/copy.c:2083 src/ln.c:269
#, c-format
msgid "%s and %s are the same file"
msgstr "%s와(과) %s은(는) 동일한 파일입니다"

#: src/copy.c:2177
#, c-format
msgid "cannot overwrite non-directory %s with directory %s"
msgstr "디렉터리가 아닌 %s을(를) %s 디렉터리에 덮어쓸 수 없습니다"

#: src/copy.c:2195 src/ln.c:240
#, c-format
msgid "will not overwrite just-created %s with %s"
msgstr "바로 만든 %s을(를) %s(으)로 덮어쓰기 하지 않음"

#: src/copy.c:2213
#, c-format
msgid "cannot overwrite directory %s with non-directory"
msgstr "%s 디렉터리를 디렉터리가 아닌 대상에 덮어 쓸 수 없습니다"

#: src/copy.c:2227
#, c-format
msgid "cannot move directory onto non-directory: %s -> %s"
msgstr "디렉터리를 디렉터리가 아닌 곳으로 이동할 수 없습니다: %s -> %s"

#: src/copy.c:2255
#, c-format
msgid "backing up %s might destroy source;  %s not moved"
msgstr "%s 백업은 원본을 망가뜨립니다. %s을(를) 이동하지 않음"

#: src/copy.c:2256
#, c-format
msgid "backing up %s might destroy source;  %s not copied"
msgstr "%s 백업은 원본을 망가뜨립니다. %s을(를) 복사하지 않음"

#: src/copy.c:2282 src/ln.c:302
#, c-format
msgid "cannot backup %s"
msgstr "%s 백업할 수 없음"

#: src/copy.c:2339
#, c-format
msgid "will not copy %s through just-created symlink %s"
msgstr "%s에 붙인 %s 심볼릭 링크에 복사하지 않음"

#: src/copy.c:2421
#, c-format
msgid "cannot copy a directory, %s, into itself, %s"
msgstr "%s 디렉터리를 자신의 디렉터리 %s(으)로 복사할 수 없습니다"

#: src/copy.c:2430
#, c-format
msgid "warning: source directory %s specified more than once"
msgstr "경고: %s 원본 디렉터리를 한 번 이상 지정했습니다"

#: src/copy.c:2458
#, c-format
msgid "will not create hard link %s to directory %s"
msgstr "%s 디렉터리에 %s 하드 링크를 만들지 않음"

#: src/copy.c:2486
#, c-format
msgid "renamed "
msgstr "이름 바꿈 "

#: src/copy.c:2524
#, c-format
msgid "cannot move %s to a subdirectory of itself, %s"
msgstr "%s을(를) 자체 하위 디렉터리 %s(으)로 이동할 수 없습니다"

#: src/copy.c:2567
#, c-format
msgid "cannot move %s to %s"
msgstr "%s을(를) %s(으)로 이동할 수 없습니다"

#: src/copy.c:2585
#, c-format
msgid "inter-device move failed: %s to %s; unable to remove target"
msgstr "장치간 이동 실패: %s → %s. 대상 제거 실패."

#: src/copy.c:2593
#, c-format
msgid "copied "
msgstr "복사함 "

#: src/copy.c:2630
#, c-format
msgid "cannot copy cyclic symbolic link %s"
msgstr "%s 순환 심볼릭 링크를 복사할 수 없습니다"

#: src/copy.c:2694
#, c-format
msgid "created directory %s\n"
msgstr "%s 디렉터리를 만들 수 없습니다\n"

#: src/copy.c:2758
#, c-format
msgid "%s: can make relative symbolic links only in current directory"
msgstr "%s: 현재 디렉터리 안에서만 상대적인 심볼릭 링크를 만들 수 있습니다"

#: src/copy.c:2768
#, c-format
msgid "cannot create symbolic link %s to %s"
msgstr "%s -> %s 심볼릭 링크를 만들 수 없습니다"

#: src/copy.c:2826 src/mkfifo.c:175
#, c-format
msgid "cannot create fifo %s"
msgstr "%s의 FIFO 버퍼를 만들 수 없습니다"

#: src/copy.c:2835
#, c-format
msgid "cannot create special file %s"
msgstr "%s 특수 파일을 만들 수 없습니다"

#: src/copy.c:2846 src/ls.c:3676 src/stat.c:1520
#, c-format
msgid "cannot read symbolic link %s"
msgstr "%s 심볼릭 링크를 읽을 수 없습니다"

#: src/copy.c:2872
#, c-format
msgid "cannot create symbolic link %s"
msgstr "%s 심볼릭 링크를 만들 수 없습니다"

#: src/copy.c:2906
#, c-format
msgid "%s has unknown file type"
msgstr "%s 파일의 형식을 알 수 없습니다"

#: src/copy.c:3072 src/ln.c:390
#, c-format
msgid "cannot un-backup %s"
msgstr "%s 백업을 복원할 수 없습니다"

#: src/copy.c:3076
#, c-format
msgid "%s -> %s (unbackup)\n"
msgstr "%s -> %s (백업 복원)\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/coreutils.c:48
msgid "Alex Deymo"
msgstr "Alex Deymo"

#: src/coreutils.c:65
#, c-format
msgid "Usage: %s --coreutils-prog=PROGRAM_NAME [PARAMETERS]... \n"
msgstr "사용법: %s --coreutils-prog=<프로그램_이름> [<매개변수>]... \n"

#: src/coreutils.c:68
msgid ""
"Execute the PROGRAM_NAME built-in program with the given PARAMETERS.\n"
"\n"
msgstr ""
"<프로그램_이름> 내장 프로그램을 주어진 <매개변수>로 실행합니다.\n"
"\n"

#: src/coreutils.c:86
#, c-format
msgid ""
"\n"
"Use: '%s --coreutils-prog=PROGRAM_NAME --help' for individual program help.\n"
msgstr ""
"\n"
"사용: 개별 프로그램 도움말을 보려면 '%s --coreutils-prog=<프로그램_이름> --"
"help' 명령을 사용하십시오.\n"

#: src/coreutils.c:179 src/coreutils.c:204
#, c-format
msgid "unknown program %s"
msgstr "알 수 없는 %s 프로그램"

#: src/cp.c:145 src/mv.c:241
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
msgstr ""
"사용법: %s [<옵션>]... <원본> <대상>\n"
"  또는: %s [<옵션>]... <원본>... <디렉터리>\n"
"  또는: %s -d [<옵션>]... --target-directory=<디렉터리> <원본>...\n"

#: src/cp.c:151
msgid "Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\n"
msgstr "<원본>을 <대상>으로, 또는 다중 <원본>을 <디렉터리>로 복사합니다.\n"

#: src/cp.c:157
msgid ""
"  -a, --archive                same as -dR --preserve=all\n"
"      --attributes-only        don't copy the file data, just the "
"attributes\n"
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"      --copy-contents          copy contents of special files when "
"recursive\n"
"  -d                           same as --no-dereference --preserve=links\n"
msgstr ""
"  -a, --archive                -dR --preserve=all 옵션과 동일\n"
"      --attributes-only        파일 데이터를 복사하지 않고 속성 값만 복사\n"
"      --backup[=<컨트롤>]       기존 대상 파일의 백업을 만듬\n"
"  -b                           --backup 옵션과 유사하나 인자를 받지 않음\n"
"      --copy-contents          하위 연속 복사시 특수 파일의 내용 복사\n"
"  -d                           --no-dereference --preserve=links 옵션과 동"
"일\n"

#: src/cp.c:166
msgid ""
"  -f, --force                  if an existing destination file cannot be\n"
"                                 opened, remove it and try again (this "
"option\n"
"                                 is ignored when the -n option is also "
"used)\n"
"  -i, --interactive            prompt before overwrite (overrides a previous "
"-n\n"
"                                  option)\n"
"  -H                           follow command-line symbolic links in SOURCE\n"
msgstr ""
"  -f, --force                  기존 대상 파일을 열 수 없을 경우, 해당 파일"
"을\n"
"                                 제거하고 다시 시도합니다 (-n 옵션을 함께 사"
"용하면\n"
"                                 이 옵션은 무시합니다)\n"
"  -i, --interactive            덮어쓰기 전에 질문합니다 (-n 옵션을 덮어씀)\n"
"  -H                           <원본>의 명령행 심볼릭 링크를 따라갑니다\n"

#: src/cp.c:175
msgid ""
"  -l, --link                   hard link files instead of copying\n"
"  -L, --dereference            always follow symbolic links in SOURCE\n"
msgstr ""
"  -l, --link                   복사하는 대신 파일의 하드 링크를 만듭니다\n"
"  -L, --dereference            <원본>의 심볼릭 링크를 따라갑니다\n"

#: src/cp.c:179
msgid ""
"  -n, --no-clobber             do not overwrite an existing file (overrides\n"
"                                 a previous -i option)\n"
"  -P, --no-dereference         never follow symbolic links in SOURCE\n"
msgstr ""
"  -n, --no-clobber             기존 파일을 덮어쓰지 않습니다 (-i 옵션 덮어"
"씀)\n"
"  -P, --no-dereference         <원본>의 심볼릭 링크를 따라가지 않습니다\n"

#: src/cp.c:184
msgid ""
"  -p                           same as --preserve=mode,ownership,timestamps\n"
"      --preserve[=ATTR_LIST]   preserve the specified attributes (default:\n"
"                                 mode,ownership,timestamps), if possible\n"
"                                 additional attributes: context, links, "
"xattr,\n"
"                                 all\n"
msgstr ""
"  -p                           --preserve=mode,ownership,timestamps 옵션과 동"
"일\n"
"      --preserve[=<속성_목록>]   지정 속성을 보존합니다 (기본:\n"
"                                 mode,ownership,timestamps), 가능한 경우\n"
"                                 추가 속성을 지정할 수 있습니: context, "
"links, xattr,\n"
"                                 all\n"

#: src/cp.c:192
msgid ""
"      --no-preserve=ATTR_LIST  don't preserve the specified attributes\n"
"      --parents                use full source file name under DIRECTORY\n"
msgstr ""
"      --no-preserve=<속성_목록>  지정 속성을 보존하지 않습니다\n"
"      --parents                <디렉터리>의 전체 원본 파일 이름을 활용합니"
"다\n"

#: src/cp.c:196
msgid ""
"  -R, -r, --recursive          copy directories recursively\n"
"      --reflink[=WHEN]         control clone/CoW copies. See below\n"
"      --remove-destination     remove each existing destination file before\n"
"                                 attempting to open it (contrast with --"
"force)\n"
msgstr ""
"  -R, -r, --recursive          디렉터리의 하위 요소도 복사합니다\n"
"      --reflink[=<시기>]         클론/CoW 복제를 제어합니다. 아래 참고\n"
"      --remove-destination     각 기존 대상 파일을 열기 전 제거합니다\n"
"                                 (--force 옵션과는 반대임)\n"

#: src/cp.c:202
msgid ""
"      --sparse=WHEN            control creation of sparse files. See below\n"
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
msgstr ""
"      --sparse=<시기>            희소 파일 생성을 제어합니다. 하단 참조\n"
"      --strip-trailing-slashes  각 <원본>인자의 마지막 슬래시를 제거합니다\n"

#: src/cp.c:207
msgid ""
"  -s, --symbolic-link          make symbolic links instead of copying\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
msgstr ""
"  -s, --symbolic-link          복사하는 대신 심볼릭 링크를 만듭니다\n"
"  -S, --suffix=<접미사>          일반적인 백업 접미사 대신 지정 <접미사>를 적"
"용합니다\n"
"  -t, --target-directory=<디렉터리>  모든 <원본> 인자를 <디렉터리>로 복사합니"
"다\n"
"  -T, --no-target-directory    <대상>을 일반 파일 처럼 취급합니다\n"

#: src/cp.c:213
msgid ""
"  -u, --update                 copy only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -x, --one-file-system        stay on this file system\n"
msgstr ""
"  -u, --update                 <원본> 파일이 대상 파일보다 최신이거나\n"
"                                 대상 파일이 빠졌을 경우에만 복사합니다\n"
"  -v, --verbose                처리한 작업을 설명합니다\n"
"  -x, --one-file-system        이 파일 시스템에 그대로 둡니다\n"

#: src/cp.c:220
msgid ""
"  -Z                           set SELinux security context of destination\n"
"                                 file to default type\n"
"      --context[=CTX]          like -Z, or if CTX is specified then set the\n"
"                                 SELinux or SMACK security context to CTX\n"
msgstr ""
"  -Z                           대상 파일의 SELinux 보안 컨텍스트를 기본 형으"
"로\n"
"                                 지정합니다\n"
"      --context[=<컨텍스트>]          -Z 옵션과 유사하나, <컨텍스트>를 지정하"
"면\n"
"                                 SELinux 또는 SMACK 보안 컨텍스트를 <컨텍스트"
">로 설정합니다\n"

#: src/cp.c:228
msgid ""
"\n"
"By default, sparse SOURCE files are detected by a crude heuristic and the\n"
"corresponding DEST file is made sparse as well.  That is the behavior\n"
"selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\n"
"file whenever the SOURCE file contains a long enough sequence of zero "
"bytes.\n"
"Use --sparse=never to inhibit creation of sparse files.\n"
msgstr ""
"\n"
"기본적으로 희소 <원본> 파일은 대강의 경험을 통해 찾으며, 관련 <대상>\n"
"파일 역시 마찬가지로 희소 파일로 만들 수 있습니다. 이는 --sparse=auto\n"
"옵션을 설정하면 됩니다.  <원본> 파일에 충분히 긴 0 바이트 시퀀스가 있을\n"
"때마다 희소 <대상>을 만들려면 --sparse=always 옵션을 지정하십시오.\n"
"희소 파일 만들기 동작을 막으려면 --sparse=never 옵션을 사용하십시오.\n"

#: src/cp.c:236
msgid ""
"\n"
"When --reflink[=always] is specified, perform a lightweight copy, where the\n"
"data blocks are copied only when modified.  If this is not possible the "
"copy\n"
"fails, or if --reflink=auto is specified, fall back to a standard copy.\n"
"Use --reflink=never to ensure a standard copy is performed.\n"
msgstr ""
"\n"
"--reflink[=always] 를 지정하면, 경량 복사를 수행하며, 데이터 블록을 수정했"
"을\n"
"경우 이를 복사합니다.  불가능한 경우 복사에 실패하거나, --reflink=auto 옵션"
"을 \n"
"지정하면 표준 복사 방식으로 대체 수행합니다.\n"
"확실히 표준 복사 동작을 수행하려면 --reflink=never 옵션을 사용하십시오.\n"

#: src/cp.c:244
msgid ""
"\n"
"As a special case, cp makes a backup of SOURCE when the force and backup\n"
"options are given and SOURCE and DEST are the same name for an existing,\n"
"regular file.\n"
msgstr ""
"\n"
"특별한 경우로, 강제와 백업 옵션이 주어지며 <원본>과 <대상>의 이름이 같고,\n"
"존재하는 일반 파일일 때 cp는 <원본>의 백업을 만듭니다.\n"

#: src/cp.c:300
#, c-format
msgid "failed to preserve times for %s"
msgstr "%s 시간 보존 실패"

#: src/cp.c:331
#, c-format
msgid "failed to preserve permissions for %s"
msgstr "%s 권한 보존 실패"

#: src/cp.c:478
#, c-format
msgid "cannot make directory %s"
msgstr "%s 디렉터리를 만들 수 없습니다"

#: src/cp.c:528 src/cp.c:558
#, c-format
msgid "%s exists but is not a directory"
msgstr "%s이(가) 있지만 디렉터리는 아닙니다"

#: src/cp.c:582 src/install.c:927 src/ln.c:568 src/mv.c:378 src/shred.c:1249
#: src/touch.c:434 src/truncate.c:316
#, c-format
msgid "missing file operand"
msgstr "파일 피연산자 빠짐"

#: src/cp.c:584 src/install.c:929 src/ln.c:591 src/mv.c:380
#, c-format
msgid "missing destination file operand after %s"
msgstr "%s 다음 대상 파일 피연산자 빠짐"

#: src/cp.c:595 src/install.c:940 src/mv.c:392
msgid "cannot combine --target-directory (-t) and --no-target-directory (-T)"
msgstr ""
"--target-directory (-t)와 --no-target-directory (-T) 옵션을 혼용할 수 없습니"
"다"

#: src/cp.c:607 src/mv.c:404
#, c-format
msgid "target directory %s"
msgstr "대상 디렉터리 %s"

#: src/cp.c:639 src/install.c:967 src/ln.c:633 src/mv.c:440
#, c-format
msgid "target %s"
msgstr "대상: %s"

#: src/cp.c:750
#, c-format
msgid "with --parents, the destination must be a directory"
msgstr "--parents 옵션에 같이 붙는 대상 값은 디렉터리여야 합니다"

#: src/cp.c:1084 src/install.c:851 src/ln.c:532 src/mv.c:338
msgid "multiple target directories specified"
msgstr "여러 대상 디렉터리를 지정했습니다"

#: src/cp.c:1115 src/mkdir.c:242 src/mkfifo.c:116 src/mknod.c:133 src/mv.c:362
#, c-format
msgid "warning: ignoring --context"
msgstr "경고: --context 무시"

#: src/cp.c:1121 src/install.c:887
#, c-format
msgid "warning: ignoring --context; it requires an SELinux-enabled kernel"
msgstr "경고: --context 무시. SELinux 활성 커널에 필요합니다"

#: src/cp.c:1142
#, c-format
msgid "cannot make both hard and symbolic links"
msgstr "하드 링크와 심볼릭 링크를 동시에 만들 수 없습니다"

#: src/cp.c:1152 src/mv.c:460
#, c-format
msgid "options --backup and --no-clobber are mutually exclusive"
msgstr "--backup과 --no-clobber 옵션은 혼용할 수 없습니다"

#: src/cp.c:1158
#, c-format
msgid "--reflink can be used only with --sparse=auto"
msgstr "--reflink 옵션은 --sparse=auto 옵션만 혼용할 수 있습니다."

#: src/cp.c:1163 src/install.c:907 src/ln.c:638 src/mv.c:465
msgid "backup type"
msgstr "백업 종류"

#: src/cp.c:1187 src/install.c:914
msgid "cannot set target context and preserve it"
msgstr "대상 컨텍스트를 지정하고 보존할 수 없습니다"

#: src/cp.c:1191
msgid "cannot preserve security context without an SELinux-enabled kernel"
msgstr "SELinux 활성 커널이 아니면 보안 컨텍스트를 보존할 수 없습니다"

#: src/cp.c:1207
msgid "cannot preserve extended attributes, cp is built without xattr support"
msgstr ""
"xattr 지원 기능을 제외하고 cp를 빌드하여 확장 속성을 보존할 수 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/csplit.c:45 src/dd.c:45
msgid "Stuart Kemp"
msgstr "Stuart Kemp"

#: src/csplit.c:511
msgid "input disappeared"
msgstr "입력 사라짐"

#: src/csplit.c:641 src/csplit.c:653
#, c-format
msgid "%s: line number out of range"
msgstr "%s: 범위를 벗어난 행 번호"

#: src/csplit.c:681
#, c-format
msgid "%s: %s: line number out of range"
msgstr "%s: %s: 범위를 벗어난 행 번호"

#: src/csplit.c:684 src/csplit.c:739
#, c-format
msgid " on repetition %s\n"
msgstr " %s 반복\n"

#: src/csplit.c:733
#, c-format
msgid "%s: %s: match not found"
msgstr "%s: %s: 맞는 짝이 없습니다"

#: src/csplit.c:797 src/csplit.c:837 src/nl.c:372 src/tac.c:286
#, c-format
msgid "error in regular expression search"
msgstr "정규식 탐색에 오류 발생"

#: src/csplit.c:970 src/csplit.c:1017
#, c-format
msgid "write error for %s"
msgstr "%s 쓰기 오류"

#: src/csplit.c:1052
#, c-format
msgid "%s: integer expected after delimiter"
msgstr "%s: 구분자 다음 정수가 와야 합니다"

#: src/csplit.c:1068
#, c-format
msgid "%s: '}' is required in repeat count"
msgstr "%s: 반복 횟수에 '}'가 필요합니다"

#: src/csplit.c:1081
#, c-format
msgid "%s}: integer required between '{' and '}'"
msgstr "%s}: '{'과 '}' 사이에 정수가 필요합니다"

#: src/csplit.c:1108
#, c-format
msgid "%s: closing delimiter '%c' missing"
msgstr "%s: 닫는 '%c' 구분자가 없습니다"

#: src/csplit.c:1125
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: 부적절한 정규식: %s"

#: src/csplit.c:1158
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: 부적절한 패턴"

#: src/csplit.c:1161
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: 행번호는 0값보다 커야합니다"

#: src/csplit.c:1166
#, c-format
msgid "line number %s is smaller than preceding line number, %s"
msgstr "'%s' 행번호가 앞선 %s 행번호보다 작습니다"

#: src/csplit.c:1172
#, c-format
msgid "warning: line number %s is the same as preceding line number"
msgstr "경고: '%s' 행번호가 앞선 행번호와 같습니다"

#: src/csplit.c:1250
msgid "missing conversion specifier in suffix"
msgstr "접미사에 변환 지정자가 빠졌음"

#: src/csplit.c:1255
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "접미사에 부적절한 변환 지정자: %c"

#: src/csplit.c:1258
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "접미사에 부적절한 변환 지정자: \\%.3o"

#: src/csplit.c:1263
#, c-format
msgid "invalid flags in conversion specification: %%%c%c"
msgstr "변환 명세에 부적절한 플래그: %%%c%c"

#: src/csplit.c:1280
#, c-format
msgid "too many %% conversion specifications in suffix"
msgstr "접미사에 %% 변환 지정자가 너무 많음"

#: src/csplit.c:1294
#, c-format
msgid "missing %% conversion specification in suffix"
msgstr "접미사에 %% 변환 지정자가 빠졌음"

#: src/csplit.c:1340 src/dd.c:1593 src/nproc.c:105 src/tail.c:2150
msgid "invalid number"
msgstr "부적절한 숫자"

#: src/csplit.c:1448
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "사용법: %s [<옵션>]... <파일> <패턴>...\n"

#: src/csplit.c:1452
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files 'xx00', 'xx01', ...,\n"
"and output byte counts of each piece to standard output.\n"
msgstr ""
"<파일>을 <패턴>으로 나눈 다음, `xx01', `xx02', ... 등 여러 파일에\n"
"출력하고, 각 조각의 바이트 수를 표준 출력으로 나타냅니다.\n"

#: src/csplit.c:1456
msgid ""
"\n"
"Read standard input if FILE is -\n"
msgstr ""
"\n"
"<파일>이 - 이면 표준 입력을 읽습니다.\n"

#: src/csplit.c:1463
#, c-format
msgid ""
"  -b, --suffix-format=FORMAT  use sprintf FORMAT instead of %02d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of 'xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
msgstr ""
"  -b, --suffix-format=<형식> %02d 대신에 sprintf <형식>을 씁니다\n"
"  -f, --prefix=<접두어>      `xx' 대신에 <접두어>를 씁니다\n"
"  -k, --keep-files           오류 발생시에도 출력 파일을 제거하지 않습니다\n"

#: src/csplit.c:1468
msgid "      --suppress-matched     suppress the lines matching PATTERN\n"
msgstr "      --suppress-matched     <패턴>에 일치하는 행을 숨깁니다\n"

#: src/csplit.c:1471
msgid ""
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
msgstr ""
"  -n, --digits=<숫자>        2 대신에 지정한 <숫자>의 개수를 이용합니다\n"
"  -s, --quiet, --silent      출력 파일의 크기를 표시하지 않습니다\n"
"  -z, --elide-empty-files    빈 출력 파일을 지웁니다\n"

#: src/csplit.c:1478
msgid ""
"\n"
"Each PATTERN may be:\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %REGEXP%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is an integer optionally preceded by '+' or '-'\n"
msgstr ""
"\n"
"각 <패턴>은 다음과 같습니다:\n"
"  <정수>                지정한 줄번호 앞까지 복사합니다\n"
"  /<정규식>/[<오프셋>]  정규식에 맞는 줄 앞까지 복사합니다\n"
"  %<정규식>%[<오프셋>]  정규식에 맞는 줄 앞까지 건너 뜁니다\n"
"  {<정수>}              바로 앞의 패턴을 지정한 횟수만큼 반복합니다\n"
"  {*}                   바로 앞의 패턴을 가능한한 많이 반복합니다\n"
"\n"
"행 <오프셋>은 `+' 또는 `-' 다음에 정수로 지정해야 합니다\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/cut.c:44 src/paste.c:52
msgid "David M. Ihnat"
msgstr "David M. Ihnat"

#: src/cut.c:133
#, c-format
msgid "Usage: %s OPTION... [FILE]...\n"
msgstr "사용법: %s <옵션>... [<파일>]...\n"

#: src/cut.c:137
msgid "Print selected parts of lines from each FILE to standard output.\n"
msgstr "각 <파일>에서 선택한 줄만 표준 출력에 표시합니다.\n"

#: src/cut.c:144
msgid ""
"  -b, --bytes=LIST        select only these bytes\n"
"  -c, --characters=LIST   select only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
msgstr ""
"  -b, --bytes=<목록>        이 바이트열만 표시합니다\n"
"  -c, --characters=<목록>   이 문자열만 표시합니다\n"
"  -d, --delimiter=<구분자>  필드 구분자로 탭 대신에 <구분자>를 씁니다\n"

#: src/cut.c:149
msgid ""
"  -f, --fields=LIST       select only these fields;  also print any line\n"
"                            that contains no delimiter character, unless\n"
"                            the -s option is specified\n"
"  -n                      (ignored)\n"
msgstr ""
"  -f, --fields=<목록>     이 필드만을 출력합니다. 또 -s 옵션이 사용되지\n"
"                            않았다면 구분자 문자가 들어 있지 않은 줄도\n"
"                            출력합니다\n"
"  -n                      (무시함)\n"

#: src/cut.c:155
msgid ""
"      --complement        complement the set of selected bytes, characters\n"
"                            or fields\n"
msgstr ""
"      --complement        선택한 바이트, 문자, 필드 집합을 덧붙입니다\n"

#: src/cut.c:159
msgid ""
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
msgstr ""
"  -s, --only-delimited    구분자가 들어 있지 않은 줄은 표시하지 않습니다\n"
"      --output-delimiter=<문자열>  <문자열>을 출력 구분자로 사용합니다\n"
"                            기본값은 입력 구분자로 사용하는 것입니다\n"

#: src/cut.c:164 src/head.c:134 src/numfmt.c:945 src/paste.c:449 src/tail.c:313
msgid "  -z, --zero-terminated    line delimiter is NUL, not newline\n"
msgstr "  -z, --zero-terminated    행 종결자는 개행 문자가 아닌 NUL입니다\n"

#: src/cut.c:169
msgid ""
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Selected input is written\n"
"in the same order that it is read, and is written exactly once.\n"
msgstr ""
"\n"
"-b, -c, -f 중 한 옵션만 사용하십시오.  각 <목록>은 하나의 범위 또는\n"
"쉼표로 구분한 여러 범위로 지정합니다.  선택한 입력은 읽은 순서대로\n"
"그대로 기록하며, 정확히 한번만 기록합니다.\n"

#: src/cut.c:175
msgid ""
"Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
msgstr ""
"각 범위는 다음 중 하나입니다:\n"
"\n"
"  N     N번째 바이트, 문자, 또는 필드, 1부터 시작합니다\n"
"  N-    N번째 바이트, 문자, 또는 필드부터 줄 끝까지\n"
"  N-M   N번째부터 M번째 바이트, 문자, 또는 필드까지 (N, M번째 포함)\n"
"  -M    처음부터 M번째 바이트, 문자, 또는 필드까지 (M번째 포함)\n"
"\n"
"냄\n"

#: src/cut.c:491
msgid "only one list may be specified"
msgstr "오직 목록 하나만을 지정할 수 있습니다"

#: src/cut.c:499 src/numfmt.c:1522
msgid "the delimiter must be a single character"
msgstr "구분자는 단일 문자여야 합니다"

#: src/cut.c:537
msgid "you must specify a list of bytes, characters, or fields"
msgstr "바이트, 문자, 또는 필드로 된 목록을 지정해야 합니다"

#: src/cut.c:542
msgid "an input delimiter may be specified only when operating on fields"
msgstr "필드를 처리할 때만 입력 구분자를 지정할 수 있습니다"

#: src/cut.c:546
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"구분자가 없는 줄을 숨기는 동작은\n"
"\t필드에서 동작하는 경우에만 의미가 있습니다"

#: src/date.c:132
#, c-format
msgid ""
"Usage: %s [OPTION]... [+FORMAT]\n"
"  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"
msgstr ""
"사용법: %s [<옵션>]... [+<형식>]\n"
"  또는:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\n"

#: src/date.c:137
msgid ""
"Display date and time in the given FORMAT.\n"
"With -s, or with [MMDDhhmm[[CC]YY][.ss]], set the date and time.\n"
msgstr ""
"주어진 <형식>으로 현재 날짜 및 시각을 표시합니다.\n"
"-s 옵션을 사용하거나 [MMDDhhmm[[CC]YY][.ss]] 형식을 사용합니다. date와 time"
"을 참고하십시오.\n"

#: src/date.c:144
msgid ""
"  -d, --date=STRING          display time described by STRING, not 'now'\n"
msgstr ""
"  -d, --date=<문자열>        'now'가 아닌 <문자열>로 설명한 시각을 표시합니"
"다\n"

#: src/date.c:147
msgid ""
"      --debug                annotate the parsed date,\n"
"                              and warn about questionable usage to stderr\n"
msgstr ""
"      --debug                해석 날짜를 표기하며,\n"
"                              질문 가능한 사용법을 표준 오류에 경고로 내보\n"

#: src/date.c:151
msgid ""
"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\n"
msgstr ""
"  -f, --file=<날짜파일>      --date와 유사하나, <날짜파일>의 각 행당 한번씩 "
"처리합니다.\n"

#: src/date.c:154
msgid ""
"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\n"
"                               FMT='date' for date only (the default),\n"
"                               'hours', 'minutes', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14T02:34:56-06:00\n"
msgstr ""
"  -I[<형식>], --iso-8601[=<형식>]  ISO 8601 형식으로 일시를 출력합니다.\n"
"                               <형식>='date' 값은 날짜만 출력합니다 (기본"
"값).\n"
"                               'hours', 'minutes', 'seconds', 'ns'로\n"
"                               지시 단위의 정밀도에 따라 날짜와 시각을 나타냅"
"니다.\n"
"                               예: 2006-08-14T02:34:56-06:00\n"

#: src/date.c:161
msgid ""
"  --resolution               output the available resolution of timestamps\n"
"                               Example: 0.000000001\n"
msgstr ""
"  --resolution               가용 정밀도로 타임스탬프를 출력합니다\n"
"                               예제: 0.000000001\n"

#: src/date.c:165
msgid ""
"  -R, --rfc-email            output date and time in RFC 5322 format.\n"
"                               Example: Mon, 14 Aug 2006 02:34:56 -0600\n"
msgstr ""
"  -R, --rfc-email            RFC 5322 형식으로 날짜와 시각을 출력합니다.\n"
"                               예: 2006년 8월 14일 (월) 17:34:56 +0900\n"

#: src/date.c:169
msgid ""
"      --rfc-3339=FMT         output date/time in RFC 3339 format.\n"
"                               FMT='date', 'seconds', or 'ns'\n"
"                               for date and time to the indicated "
"precision.\n"
"                               Example: 2006-08-14 02:34:56-06:00\n"
msgstr ""
"      --rfc-3339=<형식>      RFC 3339 형식으로 날짜/시각을 출력합니다.\n"
"                               <형식>='date', 'seconds', 'ns'로 지시하는\n"
"                               정밀도에 따라 날짜와 시각을 출력합니다.\n"
"                               예제: 2006-08-14 02:34:56-06:00\n"

#: src/date.c:175
msgid ""
"  -r, --reference=FILE       display the last modification time of FILE\n"
msgstr "  -r, --reference=<파일>     <파일>의 최근 수정 시각을 나타냅니다\n"

#: src/date.c:178
msgid ""
"  -s, --set=STRING           set time described by STRING\n"
"  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\n"
msgstr ""
"  -s, --set=<문자열>         <문자열> 에 따라 시간을 설정합니다\n"
"  -u, --utc, --universal     협정 세계표준시(UTC)에 맞춰 출력하거나 설정합니"
"다\n"

#: src/date.c:184
msgid ""
"\n"
"FORMAT controls the output.  Interpreted sequences are:\n"
"\n"
"  %%   a literal %\n"
"  %a   locale's abbreviated weekday name (e.g., Sun)\n"
msgstr ""
"\n"
"<형식>은 출력 방식을 설정합니다.  변환 시퀀스는 다음과 같습니다:\n"
"\n"
"  %%   문자 그대로의 %\n"
"  %a   해당 로캘의 요일 줄임 이름(예: 일)\n"

#: src/date.c:191
msgid ""
"  %A   locale's full weekday name (e.g., Sunday)\n"
"  %b   locale's abbreviated month name (e.g., Jan)\n"
"  %B   locale's full month name (e.g., January)\n"
"  %c   locale's date and time (e.g., Thu Mar  3 23:05:25 2005)\n"
msgstr ""
"  %A   해당 로캘의 요일 전체 이름 (예: 일요일)\n"
"  %b   해당 로캘의 월 줄임 이름 (e.g., 1월, Jan)\n"
"  %B   해당 로캘의 월 전체 이름 (e.g., 1월, January)\n"
"  %c   해당 로캘의 일시 (예: 2005. 05. 03. (목) 23:05:25)\n"

#: src/date.c:197
msgid ""
"  %C   century; like %Y, except omit last two digits (e.g., 20)\n"
"  %d   day of month (e.g., 01)\n"
"  %D   date; same as %m/%d/%y\n"
"  %e   day of month, space padded; same as %_d\n"
msgstr ""
"  %C   %Y와 유사한 세기, 아래 두자리는 제외함 (예: 20)\n"
"  %d   한달의 날짜 (예: 01)\n"
"  %D   날짜 %m/%d/%y와 동일\n"
"  %e   한달의 날짜, 공백 자릿수 맞춤. %_d와 동일\n"

#: src/date.c:203
msgid ""
"  %F   full date; like %+4Y-%m-%d\n"
"  %g   last two digits of year of ISO week number (see %G)\n"
"  %G   year of ISO week number (see %V); normally useful only with %V\n"
msgstr ""
"  %F   전체 날짜. %+4Y-%m-%d와 동일\n"
"  %g   ISO 주 번호의 연도 아래 두 자릿수 (%G 참조)\n"
"  %G   ISO 주 번호의 연도 (%V 참조). 보통 %V와 사용함\n"

#: src/date.c:208
msgid ""
"  %h   same as %b\n"
"  %H   hour (00..23)\n"
"  %I   hour (01..12)\n"
"  %j   day of year (001..366)\n"
msgstr ""
"  %h   %b와 동일\n"
"  %H   24시간제 시간 (00..23)\n"
"  %I   12시간제 시간 (01..12)\n"
"  %j   연중 일수 (001..366)\n"

#: src/date.c:214
msgid ""
"  %k   hour, space padded ( 0..23); same as %_H\n"
"  %l   hour, space padded ( 1..12); same as %_I\n"
"  %m   month (01..12)\n"
"  %M   minute (00..59)\n"
msgstr ""
"  %k   24시간제 시간, 공백 자릿수 맞춤 ( 0..23). %_H와 동일\n"
"  %l   12시간제 시간, 공백 자릿수 맞춤 ( 1..12). %_I와 동일\n"
"  %m   월 (01..12)\n"
"  %M   분 (00..59)\n"

#: src/date.c:220
msgid ""
"  %n   a newline\n"
"  %N   nanoseconds (000000000..999999999)\n"
"  %p   locale's equivalent of either AM or PM; blank if not known\n"
"  %P   like %p, but lower case\n"
"  %q   quarter of year (1..4)\n"
"  %r   locale's 12-hour clock time (e.g., 11:11:04 PM)\n"
"  %R   24-hour hour and minute; same as %H:%M\n"
"  %s   seconds since the Epoch (1970-01-01 00:00 UTC)\n"
msgstr ""
"  %n   개행 문자\n"
"  %N   나노초 (000000000..999999999)\n"
"  %p   AM, PM에 해당하는 로캘의 표기. 알 수 없을 경우 공백\n"
"  %P   %p와 유사하나, 소문자\n"
"  %q   4분위 분기 (1..4)\n"
"  %r   로캘의 12시간제 시계 (예: 오후 11:11:04)\n"
"  %R   24시간제 시간, 분. %H:%M과 동일\n"
"  %s   1970-01-01 00:00:00 UTC 부터의 에포크 날짜 기준 초\n"

#: src/date.c:230
msgid ""
"  %S   second (00..60)\n"
"  %t   a tab\n"
"  %T   time; same as %H:%M:%S\n"
"  %u   day of week (1..7); 1 is Monday\n"
msgstr ""
"  %S   초 (00..60)\n"
"  %t   탭\n"
"  %T   시각. %H:%M:%S와 동일\n"
"  %u   요일 (1..7). 1은 월요일\n"

#: src/date.c:236
msgid ""
"  %U   week number of year, with Sunday as first day of week (00..53)\n"
"  %V   ISO week number, with Monday as first day of week (01..53)\n"
"  %w   day of week (0..6); 0 is Sunday\n"
"  %W   week number of year, with Monday as first day of week (00..53)\n"
msgstr ""
"  %U   연간 주차 번호. 일요일이 한주의 첫날일 경우 (00..53)\n"
"  %V   ISO 주차 번호, 월요일이 한주의 첫날일 경우 (01..53)\n"
"  %w   요일 (0..6). 0은 일요일\n"
"  %W   연간 주차 번호, 월요일이 한주의 첫날인 경우 (00..53)\n"

#: src/date.c:242
msgid ""
"  %x   locale's date representation (e.g., 12/31/99)\n"
"  %X   locale's time representation (e.g., 23:13:48)\n"
"  %y   last two digits of year (00..99)\n"
"  %Y   year\n"
msgstr ""
"  %x   로캘의 날짜 표현 (예: 12/31/99)\n"
"  %X   로캘의 시각 표현 (예: 23:13:48)\n"
"  %y   연도 아래 자릿수 (00..99)\n"
"  %Y   연도\n"

#: src/date.c:248
msgid ""
"  %z   +hhmm numeric time zone (e.g., -0400)\n"
"  %:z  +hh:mm numeric time zone (e.g., -04:00)\n"
"  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\n"
"  %:::z  numeric time zone with : to necessary precision (e.g., -04, "
"+05:30)\n"
"  %Z   alphabetic time zone abbreviation (e.g., EDT)\n"
"\n"
"By default, date pads numeric fields with zeroes.\n"
msgstr ""
"  %z   +hhmm 숫자 지정 시간대 (e.g., -0400)\n"
"  %:z  +hh:mm 숫자 지정 시간대 (e.g., -04:00)\n"
"  %::z  +hh:mm:ss 숫자 지정 시간대 (e.g., -04:00:00)\n"
"  %:::z  시간대 정밀도 표현에 : 이 필요한 숫자 지정 시간대 (e.g., -04, "
"+05:30)\n"
"  %Z   시간대 알파벳 약자 (예: EDT)\n"
"\n"
"기본적으로, 날짜의 숫자 부분은 0으로 자릿수를 채워 맞춥니다.\n"

#: src/date.c:257
msgid ""
"The following optional flags may follow '%':\n"
"\n"
"  -  (hyphen) do not pad the field\n"
"  _  (underscore) pad with spaces\n"
"  0  (zero) pad with zeros\n"
"  +  pad with zeros, and put '+' before future years with >4 digits\n"
"  ^  use upper case if possible\n"
"  #  use opposite case if possible\n"
msgstr ""
"'%' 기호 다음 추가 플래그가 따라 붙을 수 있습니다:\n"
"\n"
"  -  (하이픈) 필드 자릿수 맞춤 안함\n"
"  _  (밑줄) 공백으로 자릿수 맞춤\n"
"  0  (영) 0으로 자릿수 맞춤\n"
"  +  0으로 자릿수 맞추고, 4자릿수 넘을 때 미래 연도 앞에 '+'붙임\n"
"  ^  가능한 경우 대문자 사용\n"
"  #  가능한 경우 케이스를 반대(대 ↔ 소)로\n"

#: src/date.c:267
msgid ""
"\n"
"After any flags comes an optional field width, as a decimal number;\n"
"then an optional modifier, which is either\n"
"E to use the locale's alternate representations if available, or\n"
"O to use the locale's alternate numeric symbols if available.\n"
msgstr ""
"\n"
"추가 필드 너비 값이 10진수로 오고 나면 \n"
"다음 둘 중 하나의 추가 수정자를 활용할 수 있습니다\n"
"E는 가용 상태일 때 로캘 대체 표현을 사용합니다.\n"
"O는 가용 상태일 때 대체 숫자 심볼을 사용합니다.\n"

#: src/date.c:274
msgid ""
"\n"
"Examples:\n"
"Convert seconds since the Epoch (1970-01-01 UTC) to a date\n"
"  $ date --date='@2147483647'\n"
"\n"
"Show the time on the west coast of the US (use tzselect(1) to find TZ)\n"
"  $ TZ='America/Los_Angeles' date\n"
"\n"
"Show the local time for 9AM next Friday on the west coast of the US\n"
"  $ date --date='TZ=\"America/Los_Angeles\" 09:00 next Fri'\n"
msgstr ""
"\n"
"예제:\n"
"에포크 날짜(1970-01-01 UTC)로부터 현재 일시까지 초 단위로 변환\n"
"  $ date --date='@2147483647'\n"
"\n"
"대한민국 서울 기준 시각 표시 (TZ 값은 tzselect(1) 명령을 활용)\n"
"  $ TZ='Asia/Seoul' date\n"
"\n"
"대한민국 서울 기준 다음주 금요일 오전 9시 지역 시각 표시\n"
"  $ date --date='TZ=\"Asia/Seoul\" 09:00 next Fri'\n"

#: src/date.c:346 src/dd.c:2453 src/head.c:882 src/digest.c:1045
#: src/digest.c:1515 src/od.c:916 src/od.c:1985 src/pr.c:1149 src/pr.c:1350
#: src/pr.c:1473 src/stty.c:1366 src/tac.c:574 src/tail.c:392 src/tee.c:174
#: src/tr.c:1914 src/tsort.c:525 src/wc.c:362
msgid "standard input"
msgstr "표준 입력"

#: src/date.c:375 src/date.c:617
#, c-format
msgid "invalid date %s"
msgstr "부적절한 날짜 %s"

#: src/date.c:492 src/date.c:525
msgid "multiple output formats specified"
msgstr "다중 출력 형식을 지정했습니다"

#: src/date.c:503
#, c-format
msgid "the options to specify dates for printing are mutually exclusive"
msgstr "여러 출력용 날짜 지정 옵션은 혼용할 수 없습니다"

#: src/date.c:510
#, c-format
msgid "the options to print and set the time may not be used together"
msgstr "출력 옵션과 시간 설정 옵션은 혼용할 수 없습니다"

#: src/date.c:531
#, c-format
msgid ""
"the argument %s lacks a leading '+';\n"
"when using an option to specify date(s), any non-option\n"
"argument must be a format string beginning with '+'"
msgstr ""
"%s 인자에 '+' 접두사가 빠졌습니다\n"
"날짜를 지정하는 옵션을 사용할 경우, 비 옵션 인자는\n"
"'+' 기호로 시작하는 형식 문자열이어야 합니다"

#: src/date.c:625
#, c-format
msgid "cannot set date"
msgstr "날짜를 지정할 수 없습니다"

#: src/date.c:645
#, c-format
msgid "output format: %s"
msgstr "출력 형식: %s"

#: src/date.c:660 src/du.c:389
#, c-format
msgid "time %s is out of range"
msgstr "범위를 벗어난 시간 값 %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/dd.c:43 src/factor.c:122 src/rm.c:40 src/tail.c:77 src/touch.c:42
#: src/wc.c:53
msgid "Paul Rubin"
msgstr "Paul Rubin"

#: src/dd.c:544
#, c-format
msgid ""
"Usage: %s [OPERAND]...\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s [<피연산자>]...\n"
"  또는: %s <옵션>\n"

#: src/dd.c:549
msgid ""
"Copy a file, converting and formatting according to the operands.\n"
"\n"
"  bs=BYTES        read and write up to BYTES bytes at a time (default: "
"512);\n"
"                  overrides ibs and obs\n"
"  cbs=BYTES       convert BYTES bytes at a time\n"
"  conv=CONVS      convert the file as per the comma separated symbol list\n"
"  count=N         copy only N input blocks\n"
"  ibs=BYTES       read up to BYTES bytes at a time (default: 512)\n"
msgstr ""
"피연산자에 따라 파일을 복사하고, 변환하고, 형식 지정합니다.\n"
"\n"
"  bs=<바이트>        한번에 최대 <바이트>만큼 읽고 씁니다 (기본: 512).\n"
"                  ibs와 obs 설정을 덮어쓰기합니다\n"
"  cbs=<바이트>       한번에 <바이트> 용량만큼 변환합니다\n"
"  conv=<변환>      쉼표 구분 심볼 목록에 따라 파일을 변환합니다\n"
"  count=<번호>         <번호> 입력 블록만 복사합니다\n"
"  ibs=<바이트>       한번에 <바이트> 용량 만큼 읽어들입니다 (기본: 512)\n"

#: src/dd.c:559
msgid ""
"  if=FILE         read from FILE instead of stdin\n"
"  iflag=FLAGS     read as per the comma separated symbol list\n"
"  obs=BYTES       write BYTES bytes at a time (default: 512)\n"
"  of=FILE         write to FILE instead of stdout\n"
"  oflag=FLAGS     write as per the comma separated symbol list\n"
"  seek=N          (or oseek=N) skip N obs-sized output blocks\n"
"  skip=N          (or iseek=N) skip N ibs-sized input blocks\n"
"  status=LEVEL    The LEVEL of information to print to stderr;\n"
"                  'none' suppresses everything but error messages,\n"
"                  'noxfer' suppresses the final transfer statistics,\n"
"                  'progress' shows periodic transfer statistics\n"
msgstr ""
"  if=<파일>       표준 입력 대신 <파일>을 읽습니다\n"
"  iflag=<플래그>  쉼표 구분 심볼 목록 설정에 따라 읽습니다\n"
"  obs=<바이트>    한번에 <바이트> 용량 만큼 기록합니다 (기본: 512)\n"
"  of=<파일>       표준 출력 대신 <파일>에 기록합니다\n"
"  oflag=<플래그>  쉼표 구분 심볼 목록 설정에 따라 기록합니다\n"
"  seek=<번호>     (또는 ossek=<번호>) <번호> obs 크기 출력 블록만큼 건너뜁니"
"다\n"
"  skip=<번호>     (또는 oskip=<번호>) <번호> ibs 크기 입력 블록만큼 건너뜁니"
"다\n"
"  status=<수준>   표준 오류에 출력할 정보의 <수준> 입니다\n"
"                  'none'은 오류 메시지를 제외한 모든 내용을 숨깁니다\n"
"                  'noxfer'는 최종 전송 통계 내용만 생략합니다\n"
"                  'progress'는 전송 통계를 주기적으로 나타냅니다\n"

#: src/dd.c:572
msgid ""
"\n"
"N and BYTES may be followed by the following multiplicative suffixes:\n"
"c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n"
"GB=1000*1000*1000, G=1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"If N ends in 'B', it counts bytes not blocks.\n"
"\n"
"Each CONV symbol may be:\n"
"\n"
msgstr ""
"\n"
"<번호>와 <바이트>는 다음 배수 단위 접미사가 따라올 수 있습니다:\n"
"c=1, w=2, b=512, kB=1000, K=1024, MB=1000*1000, M=1024*1024, xM=M,\n"
"GB=1000*1000*1000, G=1024*1024*1024, 그리고 T, P, E, Z, Y에도 마찬가지입니"
"다.\n"
"이진 접미사의 경우 마찬가지입니다. KiB=K, MiB=M, 등과 같습니다.\n"
"<번호>가 'B'로 끝나면, 블록이 아닌 바이트로 계산합니다.\n"
"\n"
"각 <변환> 심볼은 다음과 같습니다:\n"
"\n"

#: src/dd.c:583
msgid ""
"  ascii     from EBCDIC to ASCII\n"
"  ebcdic    from ASCII to EBCDIC\n"
"  ibm       from ASCII to alternate EBCDIC\n"
"  block     pad newline-terminated records with spaces to cbs-size\n"
"  unblock   replace trailing spaces in cbs-size records with newline\n"
"  lcase     change upper case to lower case\n"
"  ucase     change lower case to upper case\n"
"  sparse    try to seek rather than write all-NUL output blocks\n"
"  swab      swap every pair of input bytes\n"
"  sync      pad every input block with NULs to ibs-size; when used\n"
"            with block or unblock, pad with spaces rather than NULs\n"
msgstr ""
"  ascii     EBCDIC에서 ASCII로 변환합니다\n"
"  ebcdic    ASCII에서 EBCDIC으로 변환합니다\n"
"  ibm       ASCII에서 대안 EBCDIC으로 변환합니다\n"
"  block     개행문자로 끝나는 레코드를 cbs크기의 공백문자로 채웁니다\n"
"  unblock   cbs크기의 레코드 뒷부분의 공백문자를 개행문자로 바꿉니다\n"
"  lcase     대문자를 소문자로 바꿉니다\n"
"  ucase     소문자를 대문자로 바꿉니다\n"
"  swab      입력하는 두 바이트의 순서를 바꿉니다\n"
"  sync      ibs크기의 입력 레코드를 크기가 맞지 않으면 NUL로 채웁니다\n"
"            block 또는 unblock 옵션 혼용시 NUL 대신 공백으로 채웁니다\n"
"\n"

#: src/dd.c:596
msgid ""
"  excl      fail if the output file already exists\n"
"  nocreat   do not create the output file\n"
"  notrunc   do not truncate the output file\n"
"  noerror   continue after read errors\n"
"  fdatasync  physically write output file data before finishing\n"
"  fsync     likewise, but also write metadata\n"
msgstr ""
"  excl      출력 파일이 이미 있다면 실패를 반환합니다\n"
"  nocreat   출력 파일을 만들지 않습니다\n"
"  notrunc   출력 파일의 끝을 잘라내지 않습니다\n"
"  noerror   읽기 오류가 나도 계속합니다\n"
"  fdatasync  끝내기 전에 출력 파일에 물리적으로 기록합니다\n"
"  fsync     마찬가지로 메타데이터도 기록합니다\n"

#: src/dd.c:604
msgid ""
"\n"
"Each FLAG symbol may be:\n"
"\n"
"  append    append mode (makes sense only for output; conv=notrunc "
"suggested)\n"
msgstr ""
"\n"
"각 <플래그> 심볼은 다음과 같습니다:\n"
"\n"
"  append    추가 모드 (출력만 신경씀. conv=notrunc 플래그를 제안합니다)\n"

#: src/dd.c:611
msgid "  cio       use concurrent I/O for data\n"
msgstr "  cio       데이터 동시 입출력 사용\n"

#: src/dd.c:613
msgid "  direct    use direct I/O for data\n"
msgstr "  direct    데이터 직접 입출력 사용\n"

#: src/dd.c:615
msgid "  directory  fail unless a directory\n"
msgstr "  directory  디렉터리가 아니면 실패\n"

#: src/dd.c:617
msgid "  dsync     use synchronized I/O for data\n"
msgstr "  dsync     데이터 동기화 입출력 사용\n"

#: src/dd.c:619
msgid "  sync      likewise, but also for metadata\n"
msgstr "  sync      마찬가지로, 메타데이터도 포함\n"

#: src/dd.c:620
msgid "  fullblock  accumulate full blocks of input (iflag only)\n"
msgstr "  fullblock  입력 전체 블록 누적 (iflag 전용)\n"

#: src/dd.c:623
msgid "  nonblock  use non-blocking I/O\n"
msgstr "  nonblock  논 블로킹 입출력 사용\n"

#: src/dd.c:625
msgid "  noatime   do not update access time\n"
msgstr "  noatime   접근 시각 업데이트 안함\n"

#: src/dd.c:628
msgid "  nocache   Request to drop cache.  See also oflag=sync\n"
msgstr "  nocache   캐시 드롭을 요청합니다.  oflag=sync 참조\n"

#: src/dd.c:632
msgid "  noctty    do not assign controlling terminal from file\n"
msgstr "  noctty    파일의 터미널 제어를 허용하지 않습니다\n"

#: src/dd.c:635
msgid "  nofollow  do not follow symlinks\n"
msgstr "  nofollow  심볼릭 링크 따라가지 않음\n"

#: src/dd.c:637
msgid "  nolinks   fail if multiply-linked\n"
msgstr "  nolinks   다중 연결일 경우 실패 반환\n"

#: src/dd.c:639
msgid "  binary    use binary I/O for data\n"
msgstr "  binary    데이터 바이너리 입출력 사용\n"

#: src/dd.c:641
msgid "  text      use text I/O for data\n"
msgstr "  text      데이터 텍스트 입출력 사용\n"

#: src/dd.c:644
#, c-format
msgid ""
"\n"
"Sending a %s signal to a running 'dd' process makes it\n"
"print I/O statistics to standard error and then resume copying.\n"
"\n"
"Options are:\n"
"\n"
msgstr ""
"\n"
"실행 중인 'dd' 프로세스에 %s 시그널을 보내면 입출력 통계를\n"
"표준 오류로 내보내고 복사를 계속 진행합니다.\n"
"\n"
"옵션은 다음과 같습니다:\n"
"\n"

#: src/dd.c:680
#, c-format
msgid "memory exhausted by input buffer of size %td bytes (%s)"
msgstr "%td 바이트 입력 버퍼로 인해 메모리가 바닥났습니다 (%s)"

#: src/dd.c:702
#, c-format
msgid "memory exhausted by output buffer of size %td bytes (%s)"
msgstr "%td 바이트 출력 버퍼로 인해 메모리가 바닥났습니다 (%s)"

#: src/dd.c:768 src/du.c:401
msgid "Infinity"
msgstr "무한"

#: src/dd.c:787
#, c-format
msgid "%<PRIdMAX> byte copied, %s, %s"
msgid_plural "%<PRIdMAX> bytes copied, %s, %s"
msgstr[0] "%<PRIdMAX> 바이트 복사함, %s, %s"

#: src/dd.c:793
#, c-format
msgid "%<PRIdMAX> bytes (%s) copied, %s, %s"
msgstr "%<PRIdMAX> 바이트 (%s) 복사함, %s, %s"

#: src/dd.c:796
#, c-format
msgid "%<PRIdMAX> bytes (%s, %s) copied, %s, %s"
msgstr "%<PRIdMAX> 바이트 (%s, %s) 복사함, %s, %s"

#: src/dd.c:830
#, c-format
msgid ""
"%<PRIdMAX>+%<PRIdMAX> records in\n"
"%<PRIdMAX>+%<PRIdMAX> records out\n"
msgstr ""
"%<PRIdMAX>+%<PRIdMAX> 레코드 입력함\n"
"%<PRIdMAX>+%<PRIdMAX> 레코드 출력함\n"

#: src/dd.c:836
#, c-format
msgid "%<PRIdMAX> truncated record\n"
msgid_plural "%<PRIdMAX> truncated records\n"
msgstr[0] "잘린 레코드 %<PRIdMAX>개\n"

#: src/dd.c:947
#, c-format
msgid "closing input file %s"
msgstr "%s 입력 파일 닫는 중"

#: src/dd.c:954
#, c-format
msgid "closing output file %s"
msgstr "%s 출력 파일 닫는 중"

#: src/dd.c:1190
#, c-format
msgid "failed to turn off O_DIRECT: %s"
msgstr "O_DIRECT 끄기 실패: %s"

#: src/dd.c:1265 src/dd.c:2155
#, c-format
msgid "writing to %s"
msgstr "%s에 쓰는 중"

#: src/dd.c:1459
#, c-format
msgid "warning: %s is a zero multiplier; use %s if that is intended"
msgstr "경고: %s은(는) 0의 배수입니다. 의도한 값이라면 %s을(를) 사용하십시오"

#: src/dd.c:1502 src/dd.c:1581
#, c-format
msgid "unrecognized operand %s"
msgstr "인지할 수 없는 피연산자 %s"

#: src/dd.c:1514
msgid "invalid conversion"
msgstr "부적절한 변환"

#: src/dd.c:1517
msgid "invalid input flag"
msgstr "부적절한 입력 플래그"

#: src/dd.c:1520 src/dd.c:1620
msgid "invalid output flag"
msgstr "부적절한 출력 플래그"

#: src/dd.c:1523
msgid "invalid status level"
msgstr "부적절한 상태 수준"

#: src/dd.c:1670
msgid "cannot combine any two of {ascii,ebcdic,ibm}"
msgstr "{ascii,ebcdic,ibm} 중 두가지 값을 혼용할 수 없습니다"

#: src/dd.c:1672
msgid "cannot combine block and unblock"
msgstr "block과 unblock 옵션을 혼용할 수 없습니다"

#: src/dd.c:1674
msgid "cannot combine lcase and ucase"
msgstr "lcase와 ucase 옵션을 혼용할 수 없습니다"

#: src/dd.c:1676
msgid "cannot combine excl and nocreat"
msgstr "excl과 nocreat 옵션을 혼용할 수 없습니다"

#: src/dd.c:1679
msgid "cannot combine direct and nocache"
msgstr "direct와 nocache 옵션을 혼용할 수 없습니다"

#: src/dd.c:1866
#, c-format
msgid "%s: cannot skip"
msgstr "%s: 건너 뛸 수 없음"

#: src/dd.c:1868 src/dd.c:1899 src/dd.c:1959
#, c-format
msgid "%s: cannot seek"
msgstr "%s: 탐색할 수 없음"

#: src/dd.c:1939
#, c-format
msgid "offset overflow while reading file %s"
msgstr "%s 파일 읽는 중 오프셋 넘침 발생"

#: src/dd.c:1951
#, c-format
msgid "warning: invalid file offset after failed read"
msgstr "경고: 읽기 실패 후 잘못된 파일 오프셋"

#: src/dd.c:1955
#, c-format
msgid "cannot work around kernel bug after all"
msgstr "이후에 커널 버그를 회피할 수 없습니다"

#: src/dd.c:2094
#, c-format
msgid "setting flags for %s"
msgstr "%s 플래그 설정중"

#: src/dd.c:2136
#, c-format
msgid "%s: cannot skip to specified offset"
msgstr "%s: 지정 오프셋으로 건너뛸 수 없습니다"

#: src/dd.c:2367 src/dd.c:2525
#, c-format
msgid "failed to truncate to %<PRIdMAX> bytes in output file %s"
msgstr "%2$s 출력 파일을 %1$<PRIdMAX> 바이트로 잘라내기 실패"

#: src/dd.c:2403
#, c-format
msgid "fdatasync failed for %s"
msgstr "%s에 fdatasync 실패"

#: src/dd.c:2411
#, c-format
msgid "fsync failed for %s"
msgstr "%s에 fsync 실패"

#: src/dd.c:2459 src/dd.c:2499 src/nohup.c:157 src/nohup.c:159
#, c-format
msgid "failed to open %s"
msgstr "%s 열기 실패"

#: src/dd.c:2487
#, c-format
msgid ""
"offset too large: cannot truncate to a length of seek=%<PRIdMAX> (%td-byte) "
"blocks"
msgstr ""
"오프셋 값이 너무 큼: 탐색 길이=%<PRIdMAX> (%td-바이트) 블록을 자를 수 없습니"
"다"

#: src/dd.c:2548 src/dd.c:2554
#, c-format
msgid "failed to discard cache for: %s"
msgstr "캐시 비우기 실패: %s"

#. This is a proper name. See the gettext manual, section Names.
#: src/df.c:50 src/du.c:56 src/expr.c:55 src/kill.c:34 src/pathchk.c:31
#: src/shuf.c:41 src/sleep.c:35 src/sort.c:68
msgid "Paul Eggert"
msgstr "Paul Eggert"

#: src/df.c:183
msgid "Filesystem"
msgstr "파일 시스템"

#: src/df.c:186
msgid "Type"
msgstr "형식"

#: src/df.c:189 src/df.c:620
msgid "blocks"
msgstr "블록"

#: src/df.c:192
msgid "Used"
msgstr "사용"

#: src/df.c:195
msgid "Available"
msgstr "가용"

#: src/df.c:198
msgid "Use%"
msgstr "사용%"

#: src/df.c:201
msgid "Inodes"
msgstr "Inodes"

#: src/df.c:204
msgid "IUsed"
msgstr "IUsed"

#: src/df.c:207
msgid "IFree"
msgstr "IFree"

#: src/df.c:210
msgid "IUse%"
msgstr "IUse%"

#: src/df.c:213
msgid "Mounted on"
msgstr "마운트위치"

#: src/df.c:216
msgid "File"
msgstr "파일"

#: src/df.c:460
#, c-format
msgid "option --output: field %s unknown"
msgstr "--output 옵션: 알 수 없는 %s 필드"

#: src/df.c:467
#, c-format
msgid "option --output: field %s used more than once"
msgstr "--output 옵션: %s 필드를 한번 이상 사용했습니다"

#: src/df.c:488 src/df.c:527
msgid "Size"
msgstr "크기"

#: src/df.c:492 src/df.c:529
msgid "Avail"
msgstr "가용"

#: src/df.c:552
msgid "Capacity"
msgstr "용량"

#. TRANSLATORS: this is the "1K-blocks" header in "df" output.
#. TRANSLATORS: this is the "1024-blocks" header in "df -P".
#: src/df.c:623 src/df.c:632
#, c-format
msgid "%s-%s"
msgstr "%s-%s"

#: src/df.c:1366
#, c-format
msgid "cannot access %s: over-mounted by another device"
msgstr "%s에 접근할 수 없음: 다른 장치에서 마운트함"

#: src/df.c:1535
msgid ""
"Show information about the file system on which each FILE resides,\n"
"or all file systems by default.\n"
msgstr ""
"각 <파일>이 있는 파일 시스템 정보 또는 기본적으로 모든 파일 시스템을\n"
"보여줍니다.\n"

#. TRANSLATORS: The thousands and decimal separators are best
#. adjusted to an appropriate default for your locale.
#: src/df.c:1544
msgid ""
"  -a, --all             include pseudo, duplicate, inaccessible file "
"systems\n"
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -h, --human-readable  print sizes in powers of 1024 (e.g., 1023M)\n"
"  -H, --si              print sizes in powers of 1000 (e.g., 1.1G)\n"
msgstr ""
"  -a, --all             의사, 복제, 접근 불가 파일 시스템도 포함\n"
"  -B, --block-size=<크기>  내용 출력 전 <크기>만큼 크기를 단위 맞춤. \n"
"                           예: '-BM'은 1,048,576 바이트 단위로 크기를 출력합"
"니다.\n"
"                           <크기> 형식은 아래 참조\n"
"  -h, --human-readable  1024 배수로 크기를 출력(예: 1023M)\n"
"  -H, --si              1000 배수로 크기를 출력(예 1.1G)\n"

#: src/df.c:1552
msgid ""
"  -i, --inodes          list inode information instead of block usage\n"
"  -k                    like --block-size=1K\n"
"  -l, --local           limit listing to local file systems\n"
"      --no-sync         do not invoke sync before getting usage info "
"(default)\n"
msgstr ""
"  -i, --inodes          블록 사용량 대신 inode 정보를 보여줍니다\n"
"  -k                    --block-size=1K와 같음\n"
"  -l, --local           로컬 파일 시스템으로 제한\n"
"      --no-sync         사용 저옵를 가져오기 전 동기화하지 않음(기본값)\n"

#: src/df.c:1559
msgid ""
"      --output[=FIELD_LIST]  use the output format defined by FIELD_LIST,\n"
"                               or print all fields if FIELD_LIST is "
"omitted.\n"
"  -P, --portability     use the POSIX output format\n"
"      --sync            invoke sync before getting usage info\n"
msgstr ""
"      --output[=<필드_목록>]  <필드_목록>에 지정한 출력 형식을 사용하거나,\n"
"                               <필드_목록>을 생략했을 경우 모든 필드를 출력합"
"니다.\n"
"  -P, --portability     POSIX 출력 형식을 활용합니다\n"
"      --sync            사용 정보를 가져오기 전 동기화 실행\n"

#: src/df.c:1565
msgid ""
"      --total           elide all entries insignificant to available space,\n"
"                          and produce a grand total\n"
msgstr ""
"      --total           중요하지 않은 가용 공간의 모든 항목 출력을 생략합니"
"다\n"
"                          그리고 전체 총 용량을 계산합니다\n"

#: src/df.c:1569
msgid ""
"  -t, --type=TYPE       limit listing to file systems of type TYPE\n"
"  -T, --print-type      print file system type\n"
"  -x, --exclude-type=TYPE   limit listing to file systems not of type TYPE\n"
"  -v                    (ignored)\n"
msgstr ""
"  -t, --type=<형식>       파일 시스템 <형식>의 목록 표시를 제한합니다\n"
"  -T, --print-type      파일 시스템 형식을 출력합니다\n"
"  -x, --exclude-type=<형식>   파일 시스템 <형식>에 해당하지 않는\n"
"                        모든 항목 표시를 제한합니다\n"
"  -v                    (무시함)\n"

#: src/df.c:1579
msgid ""
"\n"
"FIELD_LIST is a comma-separated list of columns to be included.  Valid\n"
"field names are: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent',\n"
"'size', 'used', 'avail', 'pcent', 'file' and 'target' (see info page).\n"
msgstr ""
"\n"
"<필드_목록>은 쉼표로 구분하여 넣을 열 목록입니다.  적절한 필드 이름:\n"
"'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size', 'used', \n"
"'avail', 'pcent', 'file', 'target' (info 페이지 참고).\n"

#: src/df.c:1616
#, c-format
msgid "options %s and %s are mutually exclusive"
msgstr "%s와(과) %s 옵션은 혼용할 수 없습니다"

#: src/df.c:1766
#, c-format
msgid "file system type %s both selected and excluded"
msgstr "%s 파일 시스템 형식을 선택하고 제외했습니다"

#: src/df.c:1819
msgid "Warning: "
msgstr "경고: "

#: src/df.c:1821 src/stat.c:961
msgid "cannot read table of mounted file systems"
msgstr "마운트한 파일 시스템의 테이블을 읽을 수 없습니다"

#: src/df.c:1856
msgid "no file systems processed"
msgstr "처리한 파일 시스템이 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/dircolors.c:36
msgid "H. Peter Anvin"
msgstr "H. Peter Anvin"

#: src/dircolors.c:103
msgid ""
"Output commands to set the LS_COLORS environment variable.\n"
"\n"
"Determine format of output:\n"
"  -b, --sh, --bourne-shell    output Bourne shell code to set LS_COLORS\n"
"  -c, --csh, --c-shell        output C shell code to set LS_COLORS\n"
"  -p, --print-database        output defaults\n"
"      --print-ls-colors       output fully escaped colors for display\n"
msgstr ""
"LS_COLORS환경변수를 지정하기 위한 명령을 출력합니다.\n"
"\n"
"출력 결정 형식:\n"
"  -b, --sh, --bourne-shell    LS_COLORS를 지정할 Bourne쉘 명령 출력\n"
"  -c, --csh, --c-shell        LS_COLORS를 지정할 C쉘 명령 출력\n"
"  -p, --print-database        기본값 출력\n"
"      --print-ls-colors       화면에 나타낼 색상을 완전히 이스케이핑하여 출"
"력\n"

#: src/dircolors.c:114
msgid ""
"\n"
"If FILE is specified, read it to determine which colors to use for which\n"
"file types and extensions.  Otherwise, a precompiled database is used.\n"
"For details on the format of these files, run 'dircolors --print-database'.\n"
msgstr ""
"\n"
"<파일>을 지정하면, 파일 형식과 확장자에 대해 어떤 색상을 사용할 지 읽어\n"
"들입니다.  그렇지 않으면 미리 컴파일한 데이터베이스를 사용합니다.\n"
"이 파일 형식에 대한 자세한 내용은 'dircolors --print-database' 명령을\n"
"실행하여 알아보십시오.\n"

#: src/dircolors.c:321
#, c-format
msgid "%s:%lu: invalid line;  missing second token"
msgstr "%s:%lu: 잘못된 행.  초 토큰 빠짐"

#: src/dircolors.c:376
#, c-format
msgid "%s:%lu: unrecognized keyword %s"
msgstr "%s:%lu: 인지할 수 없는 %s 키워드"

#: src/dircolors.c:377
msgid "<internal>"
msgstr "<내장>"

#: src/dircolors.c:462
#, c-format
msgid ""
"the options to output non shell syntax,\n"
"and to select a shell syntax are mutually exclusive"
msgstr ""
"셸 문법이 아닌 항목을 출력하는 옵션과,\n"
"셸 문법의 선택을 혼용할 수 없습니다"

#: src/dircolors.c:470
#, c-format
msgid "options --print-database and --print-ls-colors are mutually exclusive"
msgstr "--print-database와 --print-ls-colors 옵션은 혼용할 수 없습니다"

#: src/dircolors.c:481
msgid "file operands cannot be combined with --print-database (-p)"
msgstr "파일 피연산자는 --print-database (-p) 옵션과 혼용할 수 없습니다"

#: src/dircolors.c:504
msgid "no SHELL environment variable, and no shell type option given"
msgstr "SHELL 환경 변수가 없고 쉘 형식 옵션을 지정하지 않았습니다"

#: src/dirname.c:50
#, c-format
msgid "Usage: %s [OPTION] NAME...\n"
msgstr "사용법: %s [<옵션>] <이름>...\n"

#: src/dirname.c:54
msgid ""
"Output each NAME with its last non-slash component and trailing slashes\n"
"removed; if NAME contains no /'s, output '.' (meaning the current "
"directory).\n"
"\n"
msgstr ""
"마지막에 슬래시가 붙지 않은, 붙은 슬래시를 제거한 각 <이름> 을 출력합니다\n"
"<이름>에 슬래시가 없으면, '.' (현재 디렉터리)을 출력합니다.\n"
"\n"

#: src/dirname.c:59
msgid "  -z, --zero     end each output line with NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     각 출력 행을 개행 문자가 아닌 NUL로 끝냅니다\n"

#: src/dirname.c:64
#, c-format
msgid ""
"\n"
"Examples:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" followed by \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"
msgstr ""
"\n"
"예제:\n"
"  %s /usr/bin/          -> \"/usr\"\n"
"  %s dir1/str dir2/str  -> \"dir1\" 다음 \"dir2\"\n"
"  %s stdio.h            -> \".\"\n"

#: src/du.c:285 src/sort.c:418 src/wc.c:191
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [OPTION]... --files0-from=F\n"
msgstr ""
"사용법: %s [<옵션>]... [<파일>]...\n"
"  또는: %s [<옵션>]... --files0-from=F\n"
"\n"

#: src/du.c:289
msgid ""
"Summarize device usage of the set of FILEs, recursively for directories.\n"
msgstr "<파일> 집합과 여러 하위 디렉터리의 장치 사용량을 요약합니다.\n"

#: src/du.c:295
msgid ""
"  -0, --null            end each output line with NUL, not newline\n"
"  -a, --all             write counts for all files, not just directories\n"
"      --apparent-size   print apparent sizes rather than device usage; "
"although\n"
"                          the apparent size is usually smaller, it may be\n"
"                          larger due to holes in ('sparse') files, internal\n"
"                          fragmentation, indirect blocks, and the like\n"
msgstr ""
"  -0, --null            각 출력 행을 개행 문자가 아닌 NUL 문자로 끝냅니다\n"
"  -a, --all             모든 디렉터리 뿐만 아니라 파일 갯수도 기록합니다\n"
"      --apparent-size   디스크 사용량이 아닌 가시적 크기를 출력합니다\n"
"                          가시적 크기가 더 작다손 치더라도 ('분산') 파일의 "
"홀,\n"
"                          내부 파편화, 간접 블록위치 같은 문제로 더 클 수 있"
"습니다\n"

#: src/du.c:304
msgid ""
"  -B, --block-size=SIZE  scale sizes by SIZE before printing them; e.g.,\n"
"                           '-BM' prints sizes in units of 1,048,576 bytes;\n"
"                           see SIZE format below\n"
"  -b, --bytes           equivalent to '--apparent-size --block-size=1'\n"
"  -c, --total           produce a grand total\n"
"  -D, --dereference-args  dereference only symlinks that are listed on the\n"
"                          command line\n"
"  -d, --max-depth=N     print the total for a directory (or file, with --"
"all)\n"
"                          only if it is N or fewer levels below the command\n"
"                          line argument;  --max-depth=0 is the same as\n"
"                          --summarize\n"
msgstr ""
"  -B, --block-size=<크기>  내용 출력 전 <크기>만큼 크기를 단위 맞춤. \n"
"                           예: '-BM'은 1,048,576 바이트 단위로 크기를 출력합"
"니다.\n"
"                           <크기> 형식은 아래 참조\n"
"  -b, --bytes           '--apparent-size --block-size=1'과 동일\n"
"  -c, --total           전체 총 용량을 계산합니다\n"
"  -D, --dereference-args  명령행에 보이는 심볼릭 링크만 역참조합니다\n"
"  -d, --max-depth=<숫자>  <숫자>값이 실제 디렉터리 단계 수와 같거나 \n"
"                          명령행 인자로 지정한 값 아래일 경우에만 디렉터리 "
"(또는 파일,\n"
"                          --all 옵션)에 대한 총 용량을 나타냅니다. --max-"
"depth=0은\n"
"                          --summarize와 동일합니다\n"

#: src/du.c:317
msgid ""
"      --files0-from=F   summarize device usage of the\n"
"                          NUL-terminated file names specified in file F;\n"
"                          if F is -, then read names from standard input\n"
"  -H                    equivalent to --dereference-args (-D)\n"
"  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M "
"2G)\n"
"      --inodes          list inode usage information instead of block usage\n"
msgstr ""
"      --files0-from=<파일>  <파일> 이름으로 지정한 NUL 종료 파일에 대해\n"
"                          디스크 사용량을 요약 표시합니다. <파일>이 - 이면, "
"표준 입력으로\n"
"                          파일 이름을 읽어들입니다\n"
"  -H                    --dereference-args (-D)와 동일\n"
"  -h, --human-readable  가독 형식으로 크기를 나타냅니다(예: 1K 234M 2G)\n"
"      --inodes          블록 사용 정보 대신 inode 사용 정보를 나타냅니다\n"

#: src/du.c:326
msgid ""
"  -k                    like --block-size=1K\n"
"  -L, --dereference     dereference all symbolic links\n"
"  -l, --count-links     count sizes many times if hard linked\n"
"  -m                    like --block-size=1M\n"
msgstr ""
"  -k                    --block-size=1K와 같음\n"
"  -L, --dereference     모든 심볼릭 링크를 역참조\n"
"  -l, --count-links     하드 링크일 경우 크기를 여러번 계산\n"
"  -m                    --block-size=1M과 같은\n"

#: src/du.c:332
msgid ""
"  -P, --no-dereference  don't follow any symbolic links (this is the "
"default)\n"
"  -S, --separate-dirs   for directories do not include size of "
"subdirectories\n"
"      --si              like -h, but use powers of 1000 not 1024\n"
"  -s, --summarize       display only a total for each argument\n"
msgstr ""
"  -P, --no-dereference  어떤 심볼릭 링크도 따르지 않음 (기본값)\n"
"  -S, --separate-dirs   디렉터리에 대해 하위 디렉터리 크기를 합산하지 않음\n"
"      --si              -h와 같지만 1024 배수가 아닌 1000 배수를 사용\n"
"  -s, --summarize       각 인자별로 총계만 표시\n"

#: src/du.c:338
msgid ""
"  -t, --threshold=SIZE  exclude entries smaller than SIZE if positive,\n"
"                          or entries greater than SIZE if negative\n"
"      --time            show time of the last modification of any file in "
"the\n"
"                          directory, or any of its subdirectories\n"
"      --time=WORD       show time as WORD instead of modification time:\n"
"                          atime, access, use, ctime or status\n"
"      --time-style=STYLE  show times using STYLE, which can be:\n"
"                            full-iso, long-iso, iso, or +FORMAT;\n"
"                            FORMAT is interpreted like in 'date'\n"
msgstr ""
"  -t, --threshold=<크기>  <크기> 가 양수이면 보다 작은 항목은 모두 제외\n"
"                          <크기>가 음수이면 보다 큰 항목은 모두 제외\n"
"      --time            디렉터리의 임의의 파일에 대한 최종 수정 시각 또는 그 "
"하위\n"
"                          디렉터리의 최종 수정 시각 표시\n"
"      --time=<단어>     수정 시각 대신 다음 <단어>값 해당 내용을 나타냅니"
"다:\n"
"                          atime, access, use, ctime, status\n"
"      --time-style=<방식>  지정 <방식>으로 시각 표시. 해당 값:\n"
"                            full-iso, long-iso, iso, or +<형식>.\n"
"                            <형식> 'date' 에서와 같이 해석합니다.\n"

#: src/du.c:349
msgid ""
"  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n"
"      --exclude=PATTERN    exclude files that match PATTERN\n"
"  -x, --one-file-system    skip directories on different file systems\n"
msgstr ""
"  -X, --exclude-from=<파일>  <파일>의 패턴에 일치하는 파일을 제외합니다\n"
"      --exclude=<패턴>    <패턴>에 일치하는 파일은 제외합니다\n"
"  -x, --one-file-system    다른 파일 시스템의 디렉터리는 건너뜁니다\n"

#: src/du.c:696
#, c-format
msgid "fts_read failed: %s"
msgstr "fts_read 실패: %s"

#: src/du.c:820
#, c-format
msgid "invalid maximum depth %s"
msgstr "부적절한 최대 깊이 %s"

#: src/du.c:849
msgid "invalid --threshold argument '-0'"
msgstr "부적절한 --threshold 인자값 '-0'"

#: src/du.c:932
#, c-format
msgid "cannot both summarize and show all entries"
msgstr "모든 디렉터리 내용을 표시하면서 요약할 수는 없습니다"

#: src/du.c:939
#, c-format
msgid "warning: summarizing is the same as using --max-depth=0"
msgstr "경고: 요약은 --max-depth=0 옵션값 사용 동작과 같습니다"

#: src/du.c:945
#, c-format
msgid "warning: summarizing conflicts with --max-depth=%lu"
msgstr "경고: --max-depth=%lu 옵션 값은 요약 옵션과 혼용할 수 없습니다"

#: src/du.c:956
#, c-format
msgid "warning: options --apparent-size and -b are ineffective with --inodes"
msgstr ""
"경고: --apparent-size 옵션과 -b 옵션은 --inodes 옵션과 혼용할 수 없습니다"

#: src/du.c:1021 src/sort.c:4681 src/wc.c:867
msgid "file operands cannot be combined with --files0-from"
msgstr "파일 피연산자를 --files0-from와 혼용할 수 없습니다"

#: src/du.c:1088 src/sort.c:4702 src/wc.c:945
#, c-format
msgid "when reading file names from stdin, no file name of %s allowed"
msgstr "표준 입력에서 파일 이름을 읽을 때 %s 파일 이름은 허용하지 않습니다"

#: src/du.c:1105 src/du.c:1113 src/wc.c:958 src/wc.c:966
msgid "invalid zero-length file name"
msgstr "잘못된 0 길이 파일 이름"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:27
msgid "Brian Fox"
msgstr "Brian Fox"

#. This is a proper name. See the gettext manual, section Names.
#: src/echo.c:28
msgid "Chet Ramey"
msgstr "Chet Ramey"

#: src/echo.c:42
#, c-format
msgid ""
"Usage: %s [SHORT-OPTION]... [STRING]...\n"
"  or:  %s LONG-OPTION\n"
msgstr ""
"사용법: %s [<짧은옵션>]... [<문자열>]...\n"
"  또는: %s <긴옵션>\n"

#: src/echo.c:46
msgid ""
"Echo the STRING(s) to standard output.\n"
"\n"
"  -n             do not output the trailing newline\n"
msgstr ""
"<문자열>을 표준 출력에 나타냅니다.\n"
"\n"
"  -n             후행 개행 문자를 출력하지 않습니다\n"

#: src/echo.c:52
msgid ""
"  -e             enable interpretation of backslash escapes (default)\n"
"  -E             disable interpretation of backslash escapes\n"
msgstr ""
"  -e             역슬래시 이스케이프 해석 활성 (기본값)\n"
"  -E             역슬래시 이스케이프 해석 비활성\n"

#: src/echo.c:55
msgid ""
"  -e             enable interpretation of backslash escapes\n"
"  -E             disable interpretation of backslash escapes (default)\n"
msgstr ""
"  -e             역슬래시 이스케이프 해석 활성\n"
"  -E             역슬래시 이스케이프 해석 비활성(기본값)\n"

#: src/echo.c:61
msgid ""
"\n"
"If -e is in effect, the following sequences are recognized:\n"
"\n"
msgstr ""
"\n"
"-e 옵션이 동작한다면, 다음 시퀀스를 인식합니다:\n"
"\n"

#: src/echo.c:66 src/printf.c:111
msgid ""
"  \\\\      backslash\n"
"  \\a      alert (BEL)\n"
"  \\b      backspace\n"
"  \\c      produce no further output\n"
"  \\e      escape\n"
"  \\f      form feed\n"
"  \\n      new line\n"
"  \\r      carriage return\n"
"  \\t      horizontal tab\n"
"  \\v      vertical tab\n"
msgstr ""
"  \\\\      역슬래시\n"
"  \a       경고 (알림음)\n"
"  \\b      백스페이스\n"
"  \\c      더이상 출력하지 않음\n"
"  \\e      이스케이프\n"
"  \\f      폼 피드\n"
"  \\n      개행 문자\n"
"  \\r      캐리지 리턴\n"
"  \\t      수평 탭\n"
"  \\v      수직 탭\n"

#: src/echo.c:78
msgid ""
"  \\0NNN   byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
msgstr ""
"  \\0NNN   8진수 NNN 값 (1 ~ 3 자리)\n"
"  \\xHH    16진수 바이트 HH 값 (1 ~ 2 자리)\n"

#: src/echo.c:83
msgid ""
"\n"
"NOTE: printf(1) is a preferred alternative,\n"
"which does not have issues outputting option-like strings.\n"
msgstr ""
"\n"
"참고: printf(1)는 옵션과 비슷한 문자열을 출력하는데\n"
"그 어떤 문제가 없는 선호 대안입니다.\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/env.c:38 src/printenv.c:45 src/whoami.c:35
msgid "Richard Mlynarik"
msgstr "Richard Mlynarik"

#: src/env.c:115
#, c-format
msgid "Usage: %s [OPTION]... [-] [NAME=VALUE]... [COMMAND [ARG]...]\n"
msgstr "사용법: %s [<옵션>]... [-] [<이름>=<값>]... [<명령> [<인자>]...]\n"

#: src/env.c:118
msgid "Set each NAME to VALUE in the environment and run COMMAND.\n"
msgstr "각각의 환경 <이름>과 <값>을 설정하고 <명령>을 실행합니다.\n"

#: src/env.c:124
msgid ""
"  -i, --ignore-environment  start with an empty environment\n"
"  -0, --null           end each output line with NUL, not newline\n"
"  -u, --unset=NAME     remove variable from the environment\n"
msgstr ""
"  -i, --ignore-environment  빈 환경으로 시작합니다\n"
"  -0, --null           각 출력 행을 개행 문자가 아닌 NUL 문자로 끝냅니다\n"
"  -u, --unset=<이름>   환경 변수를 제거합니다\n"

#: src/env.c:129
msgid "  -C, --chdir=DIR      change working directory to DIR\n"
msgstr "  -C, --chdir=<디렉터리>      작업 디렉터리를 <디렉터리>로 바꿈\n"

#: src/env.c:132
msgid ""
"  -S, --split-string=S  process and split S into separate arguments;\n"
"                        used to pass multiple arguments on shebang lines\n"
msgstr ""
"  -S, --split-string=<문자열>  <문자열>을 처리하고 개별 인자로 나눕니다\n"
"                        쉬뱅 #! 행에 다중 인자를 넘길 때 요긴합니다\n"

#: src/env.c:136
msgid ""
"      --block-signal[=SIG]    block delivery of SIG signal(s) to COMMAND\n"
msgstr ""
"      --block-signal[=<시그널>]    <명령>으로의 <시그널> 전달을 차단합니다\n"

#: src/env.c:139
msgid ""
"      --default-signal[=SIG]  reset handling of SIG signal(s) to the "
"default\n"
msgstr ""
"      --default-signal[=<시그널>]  <시그널> 처리 동작을 기본으로 초기화합니"
"다\n"

#: src/env.c:142
msgid ""
"      --ignore-signal[=SIG]   set handling of SIG signal(s) to do nothing\n"
msgstr ""
"      --ignore-signal[=<시그널>]   <시그널> 처리 동작을 하지 않고 무시합니"
"다\n"

#: src/env.c:145
msgid ""
"      --list-signal-handling  list non default signal handling to stderr\n"
msgstr ""
"      --list-signal-handling  비 기본 시그널 처리를 표준 오류에 나타냅니다\n"

#: src/env.c:148
msgid ""
"  -v, --debug          print verbose information for each processing step\n"
msgstr "  -v, --debug          각 처리 단계별 자세한 정보를 출력합니다\n"

#: src/env.c:153
msgid ""
"\n"
"A mere - implies -i.  If no COMMAND, print the resulting environment.\n"
msgstr ""
"\n"
"단순 - 기호는 -i 옵션을 의미합니다.  지정 <명령>이 없다면 결과 환경을 출력합"
"니다.\n"

#: src/env.c:157
msgid ""
"\n"
"SIG may be a signal name like 'PIPE', or a signal number like '13'.\n"
"Without SIG, all known signals are included.  Multiple signals can be\n"
"comma-separated.\n"
msgstr ""
"\n"
"<시그널>은 'PIPE'와 같은 시그널 이름을 가지거나 '13' 같은 시그널 번호\n"
"를 갖습니다. <시그널>을 지정하지 않으면 알려진 모든 시그널이 해당합니다.\n"
"다중 시그널은 쉼표로 구분합니다.\n"

#: src/env.c:184
#, c-format
msgid "cannot unset %s"
msgstr "%s을(를) 지정 해제할 수 없습니다"

#: src/env.c:427
msgid "'\\c' must not appear in double-quoted -S string"
msgstr "'\\c'는 큰 따옴표 -S 문자열에 나타나면 안됩니다"

#: src/env.c:438
msgid "invalid backslash at end of string in -S"
msgstr "-S에서 문자열 끝에 부적절한 역슬래시 기호"

#: src/env.c:441
#, c-format
msgid "invalid sequence '\\%c' in -S"
msgstr "-S에 부적절한 시퀀스 '\\%c'"

#: src/env.c:455
#, c-format
msgid "only ${VARNAME} expansion is supported, error at: %s"
msgstr "${VARNAME} 확장만 지원합니다. 오류 위치: %s"

#: src/env.c:480
msgid "no terminating quote in -S string"
msgstr "-S 문자열에 마침 따옴표가 없습니다"

#: src/env.c:565 src/env.c:654 src/operand2sig.c:88
#, c-format
msgid "%s: invalid signal"
msgstr "%s: 잘못된 시그널"

#: src/env.c:597
#, c-format
msgid "failed to get signal action for signal %d"
msgstr "%d 시그널의 시그널 동작 가져오기에 실패"

#: src/env.c:605
#, c-format
msgid "failed to set signal action for signal %d"
msgstr "%d 시그널의 시그널 동작 설정하기에 실패"

#: src/env.c:677 src/env.c:717
msgid "failed to get signal process mask"
msgstr "시그널 프로세스 마스크 가져오기 실패"

#: src/env.c:706
msgid "failed to set signal process mask"
msgstr "시그널 프로세스 마스크 지정 실패"

#: src/env.c:808
#, c-format
msgid "invalid option -- '%c'"
msgstr "부적절한 옵션 -- '%c'"

#: src/env.c:809 src/env.c:900
#, c-format
msgid "use -[v]S to pass options in shebang lines"
msgstr "#! 줄에서 옵션을 전달하려면 -[v]S 옵션을 사용하십시오"

#: src/env.c:842
#, c-format
msgid "cannot set %s"
msgstr "%s을(를) 설정할 수 없습니다"

#: src/env.c:852
#, c-format
msgid "cannot specify --null (-0) with command"
msgstr "명령에 --null (-0) 옵션을 지정할 수 없습니다"

#: src/env.c:858
#, c-format
msgid "must specify command with --chdir (-C)"
msgstr "명령에 --chdir (-C) 옵션을 지정해야 합니다"

#: src/env.c:883
#, c-format
msgid "cannot change directory to %s"
msgstr "%s 디렉터리로 현재 디렉터리 위치를 바꿀 수 없습니다"

#: src/expand-common.c:89
msgid "tabs are too far apart"
msgstr "탭이 너무 멀리 떨어져 있습니다"

#: src/expand-common.c:102
#, c-format
msgid "'/' specifier only allowed with the last value"
msgstr "'/' 지정자는 마지막 값으로만 쓸 수 있습니다"

#: src/expand-common.c:119
#, c-format
msgid "'+' specifier only allowed with the last value"
msgstr "'+' 지정자는 마지막 값으로만 쓸 수 있습니다"

#: src/expand-common.c:171
#, c-format
msgid "'/' specifier not at start of number: %s"
msgstr "'/' 지정자가 숫자 시작 부분에 없습니다: %s"

#: src/expand-common.c:182
#, c-format
msgid "'+' specifier not at start of number: %s"
msgstr "'+' 지정자가 숫자 시작 부분에 없습니다: %s"

#: src/expand-common.c:203
#, c-format
msgid "tab stop is too large %s"
msgstr "%s 탭 간격이 너무 깁니다"

#: src/expand-common.c:211
#, c-format
msgid "tab size contains invalid character(s): %s"
msgstr "탭 크기에 부적절한 문자가 들어있습니다: %s"

#: src/expand-common.c:243
msgid "tab size cannot be 0"
msgstr "탭 크기는 0이 될 수 없습니다"

#: src/expand-common.c:245
msgid "tab sizes must be ascending"
msgstr "탭 크기는 점점 커져야 합니다"

#: src/expand-common.c:250
msgid "'/' specifier is mutually exclusive with '+'"
msgstr "'/' 지정자는 '+' 지정자와 혼용할 수 없습니다"

#: src/expand-common.c:389
msgid "  -t, --tabs=LIST  use comma separated list of tab positions.\n"
msgstr "  -t, --tabs=<목록>  탭 위치를 쉼표 구분 <목록>으로 나타냅니다.\n"

#: src/expand-common.c:392
msgid ""
"                     The last specified position can be prefixed with '/'\n"
"                     to specify a tab size to use after the last\n"
"                     explicitly specified tab stop.  Also a prefix of '+'\n"
"                     can be used to align remaining tab stops relative to\n"
"                     the last specified tab stop instead of the first "
"column\n"
msgstr ""
"                     마지막 지정 위치 앞에는 최종적으로 분명히 지정한\n"
"                     탭 간격 다음 사용할 탭 크기 지정에 '/' 접두사를\n"
"                     사용할 수 있습니다. 또한 '+' 접두사로 처음 열\n"
"                     보다는 최종 지정한 탭 간격에 상대적으로 나머지\n"
"                     열의 탭 간격을 지정할 수 있습니다\n"

#: src/expand.c:72
msgid "Convert tabs in each FILE to spaces, writing to standard output.\n"
msgstr "각 <파일>의 탭을 공백으로 바꾸고, 표준 출력에 기록합니다.\n"

#: src/expand.c:79
msgid ""
"  -i, --initial    do not convert tabs after non blanks\n"
"  -t, --tabs=N     have tabs N characters apart, not 8\n"
msgstr ""
"  -i, --initial       공백 다음에 있는 탭을 변환하지 않습니다\n"
"  -t, --tabs=<개수>   탭을 8이 아닌 <개수> 길이 공백으로 취급합니다\n"

#: src/expand.c:145 src/expand.c:164 src/unexpand.c:180 src/unexpand.c:225
msgid "input line is too long"
msgstr "입력 행이 너무 깁니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:53 src/ln.c:45 src/mv.c:43 src/tee.c:36
msgid "Mike Parker"
msgstr "Mike Parker"

#. This is a proper name. See the gettext manual, section Names.
#: src/expr.c:54 src/groups.c:37
msgid "James Youngman"
msgstr "James Youngman"

#: src/expr.c:247
#, c-format
msgid ""
"Usage: %s EXPRESSION\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s <표현식>\n"
"  또는:  %s <옵션>\n"

#: src/expr.c:255
msgid ""
"\n"
"Print the value of EXPRESSION to standard output.  A blank line below\n"
"separates increasing precedence groups.  EXPRESSION may be:\n"
"\n"
"  ARG1 | ARG2       ARG1 if it is neither null nor 0, otherwise ARG2\n"
"\n"
"  ARG1 & ARG2       ARG1 if neither argument is null or 0, otherwise 0\n"
msgstr ""
"\n"
"<표현식>의 값을 표준 출력 방향으로 출력합니다.  하단의 빈 줄은\n"
"늘어나는 우선순위 그룹을 분리했습니다.  <표현식>은 다음과 같습니다:\n"
"\n"
"  <인자1> | <인자2>  둘 다 NULL 또는 0이 아니면 <인자1>을 아니면 <인자2>를 반"
"환\n"
"\n"
"  <인자1> & <인자2>  둘 중 하나가 NULL 또는 0이 아니면 <인자1>를 아니면 0을 "
"반환\n"

#: src/expr.c:264
msgid ""
"\n"
"  ARG1 < ARG2       ARG1 is less than ARG2\n"
"  ARG1 <= ARG2      ARG1 is less than or equal to ARG2\n"
"  ARG1 = ARG2       ARG1 is equal to ARG2\n"
"  ARG1 != ARG2      ARG1 is unequal to ARG2\n"
"  ARG1 >= ARG2      ARG1 is greater than or equal to ARG2\n"
"  ARG1 > ARG2       ARG1 is greater than ARG2\n"
msgstr ""
"\n"
"  <인자1> < <인자2>       <인자1>이 <인자2>보다 작은지 여부\n"
"  <인자1> <= <인자2>      <인자1>이 <인자2>보다 작거나 같은지 여부\n"
"  <인자1> = <인자2>       <인자1>과 <인자2>가 같은지 여부\n"
"  <인자1> != <인자2>      <인자1>과 <인자2>가 다른지 여부\n"
"  <인자1> >= <인자2>      <인자1>이 <인자2>보다 크거나 같은지 여부\n"
"  <인자1> > <인자2>       <인자1>이 <인자2>보다 큰지 여부\n"

#: src/expr.c:273
msgid ""
"\n"
"  ARG1 + ARG2       arithmetic sum of ARG1 and ARG2\n"
"  ARG1 - ARG2       arithmetic difference of ARG1 and ARG2\n"
msgstr ""
"\n"
"  <인자1> + <인자2>       <인자1>과 <인자2>의 산술 가산\n"
"  <인자1> - <인자2>       <인자1>과 <인자2>의 산술 감산\n"

#: src/expr.c:280
#, no-c-format
msgid ""
"\n"
"  ARG1 * ARG2       arithmetic product of ARG1 and ARG2\n"
"  ARG1 / ARG2       arithmetic quotient of ARG1 divided by ARG2\n"
"  ARG1 % ARG2       arithmetic remainder of ARG1 divided by ARG2\n"
msgstr ""
"\n"
"  <인자1> * <인자2>  <인자1>과 <인자2>의 산술 승산\n"
"  <인자1> / <인자2>  <인자1>과 <인자2>의 산술 제산 몫\n"
"  <인자1> % <인자2>  <인자1>과 <인자2>의 산술 제산 나머지\n"

#: src/expr.c:286
msgid ""
"\n"
"  STRING : REGEXP   anchored pattern match of REGEXP in STRING\n"
"\n"
"  match STRING REGEXP        same as STRING : REGEXP\n"
"  substr STRING POS LENGTH   substring of STRING, POS counted from 1\n"
"  index STRING CHARS         index in STRING where any CHARS is found, or 0\n"
"  length STRING              length of STRING\n"
msgstr ""
"\n"
"  <문자열> : <정규식>   <문자열>에 연결한 <정규식> 패턴 일치 여부 \n"
"\n"
"  match <문자열> <정규식>        <문자열> : <정규식>과 동일\n"
"  substr <문자열> <위치> <길이>  <문자열>의 부분 문자열, <위치>는 1부터 시"
"작\n"
"  index <문자열> <문자>          <문자> 찾은 <문자열>의 위치 또는 0 값\n"
"  length <문자열>                <문자열>의 길이\n"

#: src/expr.c:295
msgid ""
"  + TOKEN                    interpret TOKEN as a string, even if it is a\n"
"                               keyword like 'match' or an operator like '/'\n"
"\n"
"  ( EXPRESSION )             value of EXPRESSION\n"
msgstr ""
"  + <토큰>                   문자열 로서의 <토큰>을 'match'와 같은\n"
"                               키워드거나 '/' 문자와 같은 연잔자라 하더라도 "
"해석\n"
"\n"
"  ( <표현식> )               <표현식>의 값\n"

#: src/expr.c:301
msgid ""
"\n"
"Beware that many operators need to be escaped or quoted for shells.\n"
"Comparisons are arithmetic if both ARGs are numbers, else lexicographical.\n"
"Pattern matches return the string matched between \\( and \\) or null; if\n"
"\\( and \\) are not used, they return the number of characters matched or "
"0.\n"
msgstr ""
"\n"
"많은 연산자는 셸에서 이스케이핑 하거나 따옴표로 감싸야 합니다.\n"
"두 <인자>가 숫자인 경우 산술 비교를 하며 그렇지 않으면 문자 비교를 합니다.\n"
"\\(와 \\) 사이의 문자열이 패턴에 일치하면 해당 문자열을 그렇지 않으면 NUL을 "
"반환합니다.\n"
"\\(와 \\) 괄호를 사용하지 않으면 일치한 문자 수를 반환하거나 0을 반환합니"
"다.\n"

#: src/expr.c:308
msgid ""
"\n"
"Exit status is 0 if EXPRESSION is neither null nor 0, 1 if EXPRESSION is "
"null\n"
"or 0, 2 if EXPRESSION is syntactically invalid, and 3 if an error occurred.\n"
msgstr ""
"\n"
"<표현식> 반환값이 둘 다 NUL 또는 0이 아니면 0을 반환하며, <표현식>이 \n"
"NUL이면 1을, <표현식>의 문법이 잘못됐을 경우 0 또는 2를, 오류가 있을 경우\n"
"3을 반환합니다.\n"

#: src/expr.c:355
#, c-format
msgid "syntax error: unexpected argument %s"
msgstr "문법 오류: 예기치 못한 %s 인자"

#: src/expr.c:560
#, c-format
msgid "syntax error: missing argument after %s"
msgstr "문법 오류: %s 다음 인자 빠짐"

#: src/expr.c:648 src/ptx.c:288
msgid "error in regular expression matcher"
msgstr "정규 표현식 오류"

#: src/expr.c:676
#, c-format
msgid "syntax error: expecting ')' after %s"
msgstr "문법 오류: %s 이후 ')' 빠짐"

#: src/expr.c:679
#, c-format
msgid "syntax error: expecting ')' instead of %s"
msgstr "문법 오류: %s 대신 ')' 빠짐"

#: src/expr.c:685
msgid "syntax error: unexpected ')'"
msgstr "문법 오류: 예기치 못한 ')'"

#: src/expr.c:831 src/expr.c:868
msgid "non-integer argument"
msgstr "비 정수 인자"

#: src/expr.c:833 src/truncate.c:276
msgid "division by zero"
msgstr "0 나누기 오류"

#: src/expr.c:927 src/sort.c:2125
#, c-format
msgid "set LC_ALL='C' to work around the problem"
msgstr "이 문제를 피해 가려면 LC_ALL='C'로 설정하십시오"

#: src/expr.c:929
#, c-format
msgid "the strings compared were %s and %s"
msgstr "비교한 문자열은 %s과(와) %s입니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/factor.c:124
msgid "Niels Moller"
msgstr "Niels Moller"

#: src/factor.c:1270 src/factor.c:1370 src/factor.c:1445
#, c-format
msgid "Lucas prime test failure.  This should not happen"
msgstr "루카스 소수 시험에 실패했습니다.  일어나면 안되는 문제입니다"

#: src/factor.c:2098
msgid "squfof queue overflow"
msgstr "squfof 큐 넘침"

#: src/factor.c:2509
#, c-format
msgid "%s is not a valid positive integer"
msgstr "%s: 유효한 양의 정수가 아닙니다"

#: src/factor.c:2544
#, c-format
msgid ""
"Usage: %s [NUMBER]...\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s [<번호>]...\n"
"  또는: %s <옵션>\n"

#: src/factor.c:2549
msgid ""
"Print the prime factors of each specified integer NUMBER.  If none\n"
"are specified on the command line, read them from standard input.\n"
"\n"
msgstr ""
"정수 <숫자> 값으로 지정한 소수 인자값을 출력합니다. 명령행에 지정한\n"
"값이 없을 경우 표준 입력으로 읽어들입니다.\n"
"\n"

#: src/find-mount-point.c:40
#, c-format
msgid "cannot get current directory"
msgstr "현재 디렉터리 정보를 가져올 수 없습니다"

#: src/find-mount-point.c:50 src/find-mount-point.c:64
#: src/find-mount-point.c:92
#, c-format
msgid "cannot change to directory %s"
msgstr "%s 디렉터리로 현재 위치를 바꿀 수 없습니다"

#: src/find-mount-point.c:70
#, c-format
msgid "cannot stat current directory (now %s)"
msgstr "현재 디렉터리 상태 정보를 가져올 수 없습니다 (현재 %s)"

#. This is a proper name. See the gettext manual, section Names.
#: src/fmt.c:39
msgid "Ross Paterson"
msgstr "Ross Paterson"

#: src/fmt.c:271
#, c-format
msgid "Usage: %s [-WIDTH] [OPTION]... [FILE]...\n"
msgstr "사용법: %s [-<너비>] [<옵션>]... [<파일>]...\n"

#: src/fmt.c:272
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"The option -WIDTH is an abbreviated form of --width=DIGITS.\n"
msgstr ""
"<파일>의 각 문단을 재구성한 후, 표준 출력에 기록합니다.\n"
"-<너비> 옵션은 --width=<숫자> 축약형입니다\n"

# refill을 뭐라고 번역?  -- 줄이 남을 때 아래 문장의 일부를 갖다 붙이는 것
#: src/fmt.c:280
msgid ""
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       reformat only lines beginning with STRING,\n"
"                              reattaching the prefix to reformatted lines\n"
"  -s, --split-only          split long lines, but do not refill\n"
msgstr ""
"  -c, --crown-margin        맨 처음 두 줄의 들여쓰기를 유지합니다\n"
"  -p, --prefix=<문자열>     <문자열>로 시작하는 행만 재구성하며,\n"
"                              재구성한 행에 접두사를 다시 붙입니다\n"
"  -s, --split-only          긴 줄을 나누되, 채워 넣지는 않습니다\n"

#: src/fmt.c:289
#, no-c-format
msgid ""
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=WIDTH         maximum line width (default of 75 columns)\n"
"  -g, --goal=WIDTH          goal width (default of 93% of width)\n"
msgstr ""
"  -t, --tagged-paragraph    첫 번째 줄의 들여쓰기를 두 번째와 다르게 합니다\n"
"  -u, --uniform-spacing     단어 사이에 한 개의 공백, 문장 다음에 두 개의 공"
"백\n"
"  -w, --width=<개수>        한 줄의 최대 너비 (기본값은 75열)\n"

#: src/fmt.c:357
#, c-format
msgid ""
"invalid option -- %c; -WIDTH is recognized only when it is the first\n"
"option; use -w N instead"
msgstr ""
"잘못된 옵션 -- %c. -<너비> 는 처음 옵션일 경우에만 고려합니다. 대신\n"
"-w <숫자> 옵션을 사용하십시오"

#: src/fmt.c:401 src/fmt.c:408
msgid "invalid width"
msgstr "부적절한 너비"

#: src/fold.c:70
msgid "Wrap input lines in each FILE, writing to standard output.\n"
msgstr "각 <파일>의 입력 행을 자동 줄바꿈하여, 표준 출력에 기록합니다.\n"

#: src/fold.c:77
msgid ""
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
msgstr ""
"  -b, --bytes         열이 아니라 바이트 수를 셉니다\n"
"  -s, --spaces        공백에서 줄을 나눕니다\n"
"  -w, --width=<너비>  80열 대신에 <너비> 길이 열을 활용합니다\n"

#: src/fold.c:284 src/pr.c:842
msgid "invalid number of columns"
msgstr "부적절한 열 개수"

#. This is a proper name. See the gettext manual, section Names.
#: src/getlimits.c:30 src/digest.c:139 src/digest.c:143 src/realpath.c:33
#: src/stdbuf.c:38 src/timeout.c:78 src/truncate.c:38
msgid "Padraig Brady"
msgstr "Padraig Brady"

#: src/getlimits.c:66
#, c-format
msgid "Usage: %s\n"
msgstr "사용법: %s\n"

#: src/getlimits.c:70
msgid ""
"Output platform dependent limits in a format useful for shell scripts.\n"
"\n"
msgstr ""
"형식에서의 출력 플랫폼 의존 제한은 셸 스크립트에서 요긴합니다.\n"
"\n"

#: src/group-list.c:68 src/id.c:399
#, c-format
msgid "failed to get groups for user %s"
msgstr "%s 사용자의 그룹 정보 가져오기 실패"

#: src/group-list.c:73 src/id.c:402
#, c-format
msgid "failed to get groups for the current process"
msgstr "현재 프로세스의 그룹 정보 가져오기 실패"

#: src/group-list.c:113
#, c-format
msgid "cannot find name for group ID %lu"
msgstr "%lu 그룹 ID의 이름을 가져올 수 없습니다"

#: src/groups.c:54
#, c-format
msgid "Usage: %s [OPTION]... [USERNAME]...\n"
msgstr "사용법: %s [<옵션>]... [<사용자이름>]...\n"

#: src/groups.c:55
msgid ""
"Print group memberships for each USERNAME or, if no USERNAME is specified, "
"for\n"
"the current process (which may differ if the groups database has changed).\n"
msgstr ""
"각 <사용자이름>의 그룹 소속 여부를 출력하며, <사용자이름>을 지정하지 않았다"
"면,\n"
"현재 프로세스 사용자의 그룹 소속 여부를 출력합니다(그룹 데이터베이스가 바뀌"
"면 다를 수 있음).\n"

#: src/groups.c:106 src/id.c:287
msgid "cannot get real UID"
msgstr "실제 UID를 가져올 수 없습니다"

#: src/groups.c:111 src/id.c:295
msgid "cannot get effective GID"
msgstr "적용한 GID를 가져올 수 없습니다"

#: src/groups.c:116 src/id.c:300
msgid "cannot get real GID"
msgstr "실제 GID를 가져올 수 없습니다"

#: src/groups.c:130 src/id.c:250
#, c-format
msgid "%s: no such user"
msgstr "%s: 이 사용자는 없습니다"

#: src/head.c:114
#, c-format
msgid ""
"Print the first %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"각 <파일>의 맨 마지막 %d줄을 표준 출력에 표시합니다.\n"
"두 개 이상의 <파일>이면, 각 파일에 대한 파일 이름 헤더를 먼저 나타냅니다.\n"

#: src/head.c:122
#, c-format
msgid ""
"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM bytes of each file\n"
"  -n, --lines=[-]NUM       print the first NUM lines instead of the first "
"%d;\n"
"                             with the leading '-', print all but the last\n"
"                             NUM lines of each file\n"
msgstr ""
"  -c, --bytes=[-]<숫자>    각 파일의 처음 <숫자> 바이트 내용을\n"
"                             출력합니다. 앞에 '-' 기호가 붙으면, 각 파일의\n"
"                             <숫자> 바이트 뒷부분을 출력합니다.\n"
"  -n, --lines=[-]<숫자>    처음 %d 만큼 대신 처음 <숫자> 행을\n"
"                             출력합니다. 앞에 '-' 기호가 붙으면, 각 파일의\n"
"                             <숫자> 행 뒷부분을 출력합니다.\n"

#: src/head.c:130
msgid ""
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
msgstr ""
"  -q, --quiet, --silent    파일 이름을 나타내는 헤더를 표시하지 않습니다\n"
"  -v, --verbose            언제나 파일 이름을 나타내는 헤더를 표시합니다\n"

#: src/head.c:139
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"<숫자>에는 배수 단위 접미사가 붙을 수 있습니다:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, 그리고 T, P, E, Z, Y에도 마찬가지입니"
"다.\n"
"이진 접미사의 경우 마찬가지입니다. KiB=K, MiB=M, 등과 같습니다.\n"

#: src/head.c:160
#, c-format
msgid "%s: file has shrunk too much"
msgstr "%s: 파일 크기가 너무 확 줄어들었습니다"

#: src/head.c:232 src/tail.c:512
#, c-format
msgid "%s: cannot seek to offset %s"
msgstr "%s: 오프셋 %s 위치에서 탐색할 수 없습니다"

#: src/head.c:233 src/tail.c:516
#, c-format
msgid "%s: cannot seek to relative offset %s"
msgstr "%s: 상대 오프셋 %s 위치에서 탐색할 수 없습니다"

#: src/head.c:275
#, c-format
msgid "%s: number of bytes is too large"
msgstr "%s: 바이트 수가 너무 큽니다"

#: src/head.c:914 src/split.c:1373 src/split.c:1540 src/tail.c:2191
msgid "invalid number of lines"
msgstr "부적절한 행의 개수"

#: src/head.c:915 src/head.c:1079 src/split.c:1365 src/split.c:1381
#: src/tail.c:2192
msgid "invalid number of bytes"
msgstr "%s: 부적절한 바이트 수"

#: src/head.c:1005 src/head.c:1067
#, c-format
msgid "invalid trailing option -- %c"
msgstr "부적절한 후위 옵션 -- %c"

#: src/hostid.c:41
#, c-format
msgid ""
"Usage: %s [OPTION]\n"
"Print the numeric identifier (in hexadecimal) for the current host.\n"
"\n"
msgstr ""
"사용법: %s [<옵션>]\n"
"현재 호스트의 숫자 식별자(16진수)를 출력합니다.\n"
"\n"

#: src/hostname.c:60
#, c-format
msgid ""
"Usage: %s [NAME]\n"
"  or:  %s OPTION\n"
"Print or set the hostname of the current system.\n"
"\n"
msgstr ""
"사용법: %s [<이름>]\n"
"  또는: %s <옵션>\n"
"현재 시스템의 호스트 이름을 출력하거나 설정합니다.\n"
"\n"

#: src/hostname.c:102
#, c-format
msgid "cannot set name to %s"
msgstr "%s 이름을 지정할 수 없습니다"

#: src/hostname.c:109
msgid "cannot determine hostname"
msgstr "호스트 이름을 알 수 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/id.c:41 src/touch.c:43
msgid "Arnold Robbins"
msgstr "Arnold Robbins"

#: src/id.c:96 src/pinky.c:489
#, c-format
msgid "Usage: %s [OPTION]... [USER]...\n"
msgstr "사용법: %s [<옵션>]... [<사용자>]...\n"

#: src/id.c:97
msgid ""
"Print user and group information for each specified USER,\n"
"or (when USER omitted) for the current process.\n"
"\n"
msgstr ""
"각 지정 <사용자>에 대한 사용자 및 그룹 정보 또는 (<사용자>\n"
"를 생략 하면) 현재 프로세스의 사용자 및 그룹 정보를 출력합니다.\n"
"\n"

#: src/id.c:102
msgid ""
"  -a             ignore, for compatibility with other versions\n"
"  -Z, --context  print only the security context of the process\n"
"  -g, --group    print only the effective group ID\n"
"  -G, --groups   print all group IDs\n"
"  -n, --name     print a name instead of a number, for -ugG\n"
"  -r, --real     print the real ID instead of the effective ID, with -ugG\n"
"  -u, --user     print only the effective user ID\n"
"  -z, --zero     delimit entries with NUL characters, not whitespace;\n"
"                   not permitted in default format\n"
msgstr ""
"  -a             기타 버전간의 호환성 때문에 무시\n"
"  -Z, --context  프로세스의 보안 컨텍스트만 출력\n"
"  -g, --group    실질 그룹 ID만 출력\n"
"  -G, --groups   모든 그룹 ID를 출력\n"
"  -n, --name     -ugG에 대해 숫자 대신 이름을 출력\n"
"  -r, --real     실질적인 ID 대신 실제 ID를 -ugG 옵션을 주어 출력\n"
"  -u, --user     실질 사용자 ID만 출력\n"
"  -z, --zero     항목을 공백이 아닌 NUL 문자로 구분\n"
"                   기본 형식에서는 허용하지 않음\n"

#: src/id.c:115
msgid ""
"\n"
"Without any OPTION, print some useful set of identified information.\n"
msgstr ""
"\n"
"어떤 <옵션>도 제시하지 않았다면, 일부 활용 가치가 있는 여러 식별 정보를 출력"
"합니다.\n"

#: src/id.c:152
msgid "--context (-Z) works only on an SELinux/SMACK-enabled kernel"
msgstr "--context (-Z) 옵션은 SELinux/SMACK 활성 커널에서만 동작합니다"

#: src/id.c:157
msgid "--context (-Z) works only on an SELinux-enabled kernel"
msgstr "--context (-Z) SELinux 활성 커널에서만 동작합니다"

#: src/id.c:191
msgid "cannot print security context when user specified"
msgstr "사용자를 지정했을 때 보안 컨텍스트를 출력할 수 없습니다"

#: src/id.c:194
msgid "cannot print \"only\" of more than one choice"
msgstr "한가지 선택 이상 \"만\" 출력할 수 없습니다"

#: src/id.c:203
msgid "cannot print only names or real IDs in default format"
msgstr "기본 형식에서 이름 또는 실제 ID를 출력할 수 없습니다"

#: src/id.c:207
msgid "option --zero not permitted in default format"
msgstr "기본 형식에서 --zero 옵션을 허용하지 않습니다"

#: src/id.c:223
msgid "can't get process context"
msgstr "프로세스 컨텍스트를 가져올 수 없습니다"

#: src/id.c:278
msgid "cannot get effective UID"
msgstr "적용한 UID를 가져올 수 없습니다"

#: src/id.c:342
#, c-format
msgid "cannot find name for user ID %s"
msgstr "%s 사용자 ID의 이름을 찾을 수 없습니다"

#: src/id.c:360
#, c-format
msgid "uid=%s"
msgstr "uid=%s"

#: src/id.c:365
#, c-format
msgid " gid=%s"
msgstr " gid=%s"

#: src/id.c:372
#, c-format
msgid " euid=%s"
msgstr " euid=%s"

#: src/id.c:380
#, c-format
msgid " egid=%s"
msgstr " egid=%s"

#: src/id.c:408
msgid " groups="
msgstr " groups="

#: src/id.c:424
#, c-format
msgid " context=%s"
msgstr " context=%s"

#: src/install.c:313
#, c-format
msgid "warning: security labeling handle failed"
msgstr "경고: 보안 레이블링 처리 실패"

#: src/install.c:342
#, c-format
msgid "warning: %s: context lookup failed"
msgstr "경고: %s: 컨텍스트 찾기 실패"

#: src/install.c:349
#, c-format
msgid "warning: %s: failed to change context to %s"
msgstr "경고: %s: %s 컨텍스트로의 전환 실패"

#: src/install.c:361
#, c-format
msgid "creating directory %s"
msgstr "%s 디렉터리 만드는 중"

#: src/install.c:374 src/mkdir.c:133 src/mkdir.c:165
#, c-format
msgid "failed to set default creation context for %s"
msgstr "%s의 기본 생성 컨텍스트 지정에 실패"

#: src/install.c:404 src/mkdir.c:185
#, c-format
msgid "failed to restore context for %s"
msgstr "%s에 대한 컨텍스트 복원 실패"

#: src/install.c:453
#, c-format
msgid "cannot change ownership of %s"
msgstr "%s의 소유권을 바꿀 수 없습니다"

#: src/install.c:478
#, c-format
msgid "cannot set timestamps for %s"
msgstr "%s 타임스탬프를 설정할 수 없습니다"

#: src/install.c:500 src/split.c:524 src/timeout.c:539
#, c-format
msgid "fork system call failed"
msgstr "fork 시스템 호출 실패"

#: src/install.c:504
#, c-format
msgid "cannot run %s"
msgstr "%s을(를) 실행할 수 없습니다"

#: src/install.c:507
#, c-format
msgid "waiting for strip"
msgstr "strip 처리 기다리는 중"

#: src/install.c:509
#, c-format
msgid "strip process terminated abnormally"
msgstr "strip 처리가 비정상적으로 끝났습니다"

#: src/install.c:533
#, c-format
msgid "invalid user %s"
msgstr "잘못된 %s 사용자"

#: src/install.c:571
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] SOURCE DEST\n"
"  or:  %s [OPTION]... SOURCE... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY SOURCE...\n"
"  or:  %s [OPTION]... -d DIRECTORY...\n"
msgstr ""
"사용법: %s [<옵션>]... [-T] <원본> <대상>\n"
"  또는:  %s [<옵션>]... <원본>... <디렉터리>\n"
"  또는:  %s [<옵션>]... -t <디렉터리> <원본>...\n"
"  또는:  %s [<옵션>]... -d <디렉터리>...\n"

#: src/install.c:578
msgid ""
"\n"
"This install program copies files (often just compiled) into destination\n"
"locations you choose.  If you want to download and install a ready-to-use\n"
"package on a GNU/Linux system, you should instead be using a package "
"manager\n"
"like yum(1) or apt-get(1).\n"
"\n"
"In the first three forms, copy SOURCE to DEST or multiple SOURCE(s) to\n"
"the existing DIRECTORY, while setting permission modes and owner/group.\n"
"In the 4th form, create all components of the given DIRECTORY(ies).\n"
msgstr ""
"\n"
"이 install 프로그램은 (종종 즉시 컴파일한) 파일을 선택한 대상 위치로 복사합니"
"다.\n"
"GNU/리눅스 시스템에서 바로 쓸 수 있는 패키지를 다운로드하고 설치하려면,\n"
"yum(1) 또는 apt-get(1)과 같은 패키지 관리자를 활용해야 합니다.\n"
"\n"
"처음 세가지 형태는 <원본>을 <대상>으로 또는 다중 <원본>을 기존 <디렉터리>로\n"
"복사하며, 동시에 권한 모드와 소유자/그룹을 설정합니다. 네번찌 양식에서는\n"
"주어진 <디렉터리>의 모든 구성요소를 갖춥니다.\n"

#: src/install.c:592
msgid ""
"      --backup[=CONTROL]  make a backup of each existing destination file\n"
"  -b                  like --backup but does not accept an argument\n"
"  -c                  (ignored)\n"
"  -C, --compare       compare content of source and destination files, and\n"
"                        if no change to content, ownership, and "
"permissions,\n"
"                        do not modify the destination at all\n"
"  -d, --directory     treat all arguments as directory names; create all\n"
"                        components of the specified directories\n"
msgstr ""
"      --backup[=<제어>]  기존 대상 파일의 백업을 만듭니다\n"
"  -b                  --backup과 같지만 인자를 받지 않습니다\n"
"  -c                  (무시)\n"
"  -C, --compare       각 원본 및 대상 파일 쌍을 비교하며,\n"
"                        내용, 소유주, 권한의 변경이 없다면,\n"
"                        모든 대상을 수정하지는 않습니다\n"
"  -d, --directory     모든 인자를 디렉터리 이름으로 취급합니다.\n"
"                        지정 디렉터리의 모든 요소를 갖춥니다.\n"

#: src/install.c:602
msgid ""
"  -D                  create all leading components of DEST except the "
"last,\n"
"                        or all components of --target-directory,\n"
"                        then copy SOURCE to DEST\n"
"  -g, --group=GROUP   set group ownership, instead of process' current "
"group\n"
"  -m, --mode=MODE     set permission mode (as in chmod), instead of rwxr-xr-"
"x\n"
"  -o, --owner=OWNER   set ownership (super-user only)\n"
msgstr ""
"  -D                  마지막 부분을 제외한 모든 <대상> 요소 또는,\n"
"                        --target-directory의 모든 구성 요소를 만들고,\n"
"                        <원본>을 <대상>으로 복사합니다\n"
"  -g, --group=<그룹>   프로세스의 현재 그룹이 아닌 소유 그룹을 설정합니다\n"
"  -m, --mode=<모드>    rwxr-xr-x 방식 대신 (chmod 처럼) 권한 모드를 설정합니"
"다\n"
"  -o, --owner=<소유주>  소유자 설정 (최고 관리자용)\n"

#: src/install.c:610
msgid ""
"  -p, --preserve-timestamps   apply access/modification times of SOURCE "
"files\n"
"                        to corresponding destination files\n"
"  -s, --strip         strip symbol tables\n"
"      --strip-program=PROGRAM  program used to strip binaries\n"
"  -S, --suffix=SUFFIX  override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory  treat DEST as a normal file\n"
"  -v, --verbose       print the name of each directory as it is created\n"
msgstr ""
"  -p, --preserve-timestamps       <원본> 파일의 접근/수정 시각을\n"
"                                    관련 대상 파일에 그대로 적용합니다\n"
"  -s, --strip                     심볼 테이블을 제거합니다\n"
"      --strip-program=<프로그램>    바이너리를 스트리핑할 프로그램\n"
"  -S, --suffix=<접미사>           일반 백업 접미사를 덮어씁니다\n"
"  -t, --target-directory=<디렉터리>  모든 <원본> 인자를 <디렉터리>에 복사합니"
"다\n"
"  -T, --no-target-directory       <대상>을 일반 파일 취급합니다\n"
"  -v, --verbose                   각 디렉터리를 만들었을 때 이름을 출력합니"
"다\n"

#: src/install.c:620
msgid ""
"      --preserve-context  preserve SELinux security context\n"
"  -Z                      set SELinux security context of destination\n"
"                            file and each created directory to default type\n"
"      --context[=CTX]     like -Z, or if CTX is specified then set the\n"
"                            SELinux or SMACK security context to CTX\n"
msgstr ""
"      --preserve-context  SELinux 보안 컨텍스트를 유지\n"
"  -Z                      대상 파일과 생성한 각 디렉터리의 SELinux 보안\n"
"                            컨텍스트를 기본형으로 설정\n"
"      --context[=<컨텍스트>]  -Z 옵션과 유사하나, <컨텍스트>를 지정하면\n"
"                            SELinux 또는 SMACK 보안 컨텍스트를 <컨텍스트>로 "
"설정합니다\n"

#: src/install.c:657 src/unlink.c:85
#, c-format
msgid "cannot unlink %s"
msgstr "%s 링크를 끊을 수 없습니다"

#: src/install.c:739
#, c-format
msgid "cannot open %s"
msgstr "%s을(를) 열 수 없습니다"

#: src/install.c:861
#, c-format
msgid ""
"WARNING: ignoring --preserve-context; this kernel is not SELinux-enabled"
msgstr "경고: --preserve-context 무시. 이 커널은 SELinux 활성 커널이 아닙니다"

#: src/install.c:901
msgid "the strip option may not be used when installing a directory"
msgstr "strip 옵션은 디렉터리를 설치할 때는 쓸 수 없습니다"

#: src/install.c:904
msgid "target directory not allowed when installing a directory"
msgstr "디렉터리를 설치할 때 대상 디렉터리를 허용하지 않습니다"

#: src/install.c:953 src/ln.c:198 src/ln.c:225 src/ln.c:537
#, c-format
msgid "failed to access %s"
msgstr "%s 접근 실패"

#: src/install.c:974 src/mkdir.c:292 src/stdbuf.c:352
#, c-format
msgid "invalid mode %s"
msgstr "잘못된 %s 모드"

#: src/install.c:981
#, c-format
msgid "WARNING: ignoring --strip-program option as -s option was not specified"
msgstr "경고: -s 옵션을 지정하지 않아 --strip-program 옵션을 무시합니다"

#: src/install.c:986
#, c-format
msgid "options --compare (-C) and --preserve-timestamps are mutually exclusive"
msgstr "--compare (-C)과 --preserve-timestamps는 혼용할 수 없습니다"

#: src/install.c:993
#, c-format
msgid "options --compare (-C) and --strip are mutually exclusive"
msgstr "--compare (-C)과 --strip은 혼용할 수 없습니다"

#: src/install.c:999
#, c-format
msgid ""
"the --compare (-C) option is ignored when you specify a mode with non-"
"permission bits"
msgstr "비허용 비트 모드를 지정할 때 --compare (-C) 옵션을 무시합니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/join.c:41 src/sort.c:67
msgid "Mike Haertel"
msgstr "Mike Haertel"

#: src/join.c:196
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited by blanks.\n"
msgstr ""
"이상적인 조인 필드로 입력 행 쌍을 구성하려면, 표준 입력에 행을 \n"
"작성하십시오.  기본 조인 필드가 우선이며, 빈칸으로 구분합니다.\n"

#: src/join.c:205
msgid ""
"\n"
"  -a FILENUM             also print unpairable lines from file FILENUM, "
"where\n"
"                           FILENUM is 1 or 2, corresponding to FILE1 or "
"FILE2\n"
msgstr ""
"\n"
"  -a <파일번호>          <파일번호>가 1 또는 2일 때 <파일1> 또는 <파일2>에 \n"
"                           해당하는 <파일번호> 파일에서 짝결합이 안되는 행도 "
"출력합니다\n"

#: src/join.c:210
msgid ""
"  -e STRING              replace missing (empty) input fields with STRING;\n"
"                           I.e., missing fields specified with '-12jo' "
"options\n"
msgstr ""
"  -e <문자열>            빠진 (빈) 입력 필드를 <문자열>로 바꿉니다.\n"
"                           예: '-12jo' 옵션으로 지정한 누락 필드\n"

#: src/join.c:215
msgid ""
"  -i, --ignore-case      ignore differences in case when comparing fields\n"
"  -j FIELD               equivalent to '-1 FIELD -2 FIELD'\n"
"  -o FORMAT              obey FORMAT while constructing output line\n"
"  -t CHAR                use CHAR as input and output field separator\n"
msgstr ""
"  -i, --ignore-case      필드를 구분할 때 대소문자를 구별하지 않습니다\n"
"  -j <필드>              '-1 <필드> -2 <필드>'와 동일합니다\n"
"  -o <형식>              출력 행을 구성할 때 <형식>을 따릅니다\n"
"  -t <문자>              입력 및 출력 필드에 구분 <문자>를 사용합니다\n"

#: src/join.c:221
msgid ""
"  -v FILENUM             like -a FILENUM, but suppress joined output lines\n"
"  -1 FIELD               join on this FIELD of file 1\n"
"  -2 FIELD               join on this FIELD of file 2\n"
"      --check-order      check that the input is correctly sorted, even\n"
"                           if all input lines are pairable\n"
"      --nocheck-order    do not check that the input is correctly sorted\n"
"      --header           treat the first line in each file as field "
"headers,\n"
"                           print them without trying to pair them\n"
msgstr ""
"  -v <파일번호>          -a <파일번호>와 유사하나, 결합한 출력 행은 숨깁니"
"다\n"
"  -1 <필드>              파일 1의 이 <필드>를 조인\n"
"  -2 <필드>              파일 2의 이 <필드>를 조인\n"
"      --check-order      모든 입력 행이 짝을 지울 수 있다 하더라도 입력 내용"
"을\n"
"                           제대로 정렬했는지 검사합니다\n"
"      --nocheck-order    입력 내용 정렬 여부를 검사하지 않습니다\n"
"      --header           모든 파일의 첫 줄에 필드 헤더로 다루고,\n"
"                           짝을 지으려 하지 말고 그냥 출력\n"

#: src/join.c:231
msgid "  -z, --zero-terminated  line delimiter is NUL, not newline\n"
msgstr "  -z, --zero-terminated  행 종결자는 개행 문자가 아닌 NUL입니다\n"

#: src/join.c:236
msgid ""
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being 'FILENUM.FIELD' or '0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.  If FORMAT is the keyword 'auto', then the first\n"
"line of each file determines the number of fields output for each line.\n"
"\n"
"Important: FILE1 and FILE2 must be sorted on the join fields.\n"
"E.g., use \"sort -k 1b,1\" if 'join' has no options,\n"
"or use \"join -t ''\" if 'sort' has no options.\n"
"Note, comparisons honor the rules specified by 'LC_COLLATE'.\n"
"If the input is not sorted and some lines cannot be joined, a\n"
"warning message will be given.\n"
msgstr ""
"\n"
"'-t <문자>' 옵션을 쓰지 않았다면, 줄의 맨 앞의 공백은 무시됩니다. 이 옵션을\n"
"썼다면 각 필드는 <문자>로 구분합니다.  <필드>는 필드 번호로 1부터 시작합니"
"다.\n"
"<형식>은 필드를 쉼표 또는 공백으로 구분하는 형식 지정자로, 각각의 형식지정자"
"는\n"
"'<사이드>.<필드>' 또는 `0'의 형식을 지닙니다.  기본 <형식> 출력으로,  join 필"
"드,\n"
" <파일1>에 남아 있는 필드, <파일2>에 남아 있는 필드의 순서대로 각각은 <문자>"
"로\n"
" 구분하여 출력합니다.\n"
"\n"
"중요: <파일1>과 <파일2> 는 'join' 필드에서 정렬해야 합니다.\n"
"예: 'join'에 옵션을 주지 않았다면 \"sort -k 1b,1\" 명령을,\n"
"'sort'에 옵션을 주지 않았다면 \"join -t ''\" 명령을 활용하십시오.\n"
"참고로, 비교 순서 규칙은 'LC_COLLATE'로 지정합니다.\n"
"입력을 정렬하지 않고, 일부 행을 합칠 수 없다면, 경고 메시지를\n"
"볼 수 있습니다.\n"

#: src/join.c:421
#, c-format
msgid "%s:%<PRIuMAX>: is not sorted: %.*s"
msgstr "%s:%<PRIuMAX>: 정렬하지 않음: %.*s"

#: src/join.c:852 src/join.c:1050
#, c-format
msgid "invalid field number: %s"
msgstr "부적절한 필드 번호: %s"

#: src/join.c:873 src/join.c:882
#, c-format
msgid "invalid field specifier: %s"
msgstr "부적절한 필드 지정자: %s"

#: src/join.c:889
#, c-format
msgid "invalid file number in field spec: %s"
msgstr "필드 지정에 부적절한 파일 번호: `%s'"

#: src/join.c:933
#, c-format
msgid "incompatible join fields %lu, %lu"
msgstr "비호환 병합 필드 %lu, %lu"

#: src/join.c:1061
msgid "conflicting empty-field replacement strings"
msgstr "빈 필드 대체 문자열이 겹칩니다"

#: src/join.c:1113 src/sort.c:4618
#, c-format
msgid "multi-character tab %s"
msgstr "여러 문자로 된 탭 %s"

#: src/join.c:1117 src/sort.c:4623
msgid "incompatible tabs"
msgstr "호환성 없는 탭"

#: src/join.c:1190
msgid "both files cannot be standard input"
msgstr "두 파일이 모두 표준 입력이면 안 됩니다"

#: src/kill.c:77
#, c-format
msgid ""
"Usage: %s [-s SIGNAL | -SIGNAL] PID...\n"
"  or:  %s -l [SIGNAL]...\n"
"  or:  %s -t [SIGNAL]...\n"
msgstr ""
"사용법: %s [-s <시그널> | -<시그널>] <프로세스ID>...\n"
"  또는:  %s -l [<시그널>]...\n"
"  또는:  %s -t [<시그널>]...\n"

#: src/kill.c:83
msgid "Send signals to processes, or list signals.\n"
msgstr "프로세스에 시그널 또는 시그널 목록을 보냅니다.\n"

#: src/kill.c:89
msgid ""
"  -s, --signal=SIGNAL, -SIGNAL\n"
"                   specify the name or number of the signal to be sent\n"
"  -l, --list       list signal names, or convert signal names to/from "
"numbers\n"
"  -t, --table      print a table of signal information\n"
msgstr ""
"  -s, --signal=<시그널>, -<시그널>\n"
"                   전송할 시그널의 이름 또는 번호를 지정합니다\n"
"  -l, --list       시그널 이름 목록을 나타내거나 시그널 이름을 번호로 상호 변"
"환합니다\n"
"  -t, --table      시그널 정보 테이블을 출력합니다\n"

#: src/kill.c:97
msgid ""
"\n"
"SIGNAL may be a signal name like 'HUP', or a signal number like '1',\n"
"or the exit status of a process terminated by a signal.\n"
"PID is an integer; if negative it identifies a process group.\n"
msgstr ""
"\n"
"<시그널>은 'HUP'와 같은 시그널 이름이거나, '1'과 같은 시그널 번호,\n"
"또는 시그널로 중단한 프로세스의 종료 상태일 수 있습니다.\n"
"PID는 정수 값입니다. 이 값이 음수이면 프로세스 그룹을 나타냅니다.\n"

#: src/kill.c:206
#, c-format
msgid "%s: invalid process id"
msgstr "%s: 잘못된 프로세스 ID"

#: src/kill.c:260
#, c-format
msgid "invalid option -- %c"
msgstr "부적절한 옵션 -- %c"

#: src/kill.c:269
#, c-format
msgid "%s: multiple signals specified"
msgstr "%s: 다중 시그널을 지정했습니다"

#: src/kill.c:284
#, c-format
msgid "multiple -l or -t options specified"
msgstr "다중 -l 또는 -t 옵션을 지정함"

#: src/kill.c:301
#, c-format
msgid "cannot combine signal with -l or -t"
msgstr "-l 또는 -t로 시그널을 조합할 수 없습니다"

#: src/kill.c:307
#, c-format
msgid "no process ID specified"
msgstr "지정한 프로세스 ID가 없습니다"

#: src/libstdbuf.c:109
#, c-format
msgid "invalid buffering mode %s for %s\n"
msgstr "%2$s의 부적절한 버퍼링 모드 %1$s\n"

#: src/libstdbuf.c:121
#, c-format
msgid "failed to allocate a %<PRIuMAX> byte stdio buffer\n"
msgstr "%<PRIuMAX> 바이트 표준 입출력 버퍼 할당에 실패했습니다\n"

#: src/libstdbuf.c:131
#, c-format
msgid "could not set buffering of %s to mode %s\n"
msgstr "%s 버퍼링을 %s 모드로 설정할 수 없습니다\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/link.c:36 src/unlink.c:36 src/who.c:52
msgid "Michael Stone"
msgstr "Michael Stone"

#: src/link.c:45
#, c-format
msgid ""
"Usage: %s FILE1 FILE2\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s <파일1> <파일2>\n"
"  또는: %s <옵션>\n"

#: src/link.c:48
msgid ""
"Call the link function to create a link named FILE2 to an existing FILE1.\n"
"\n"
msgstr ""
"기존 <파일1>에 대한 <파일2> 링크를 만들도록 링크 함수를 호출합니다.\n"
"\n"
"\n"

#: src/link.c:89
#, c-format
msgid "cannot create link %s to %s"
msgstr "%2$s의 %1$s 링크를 만들 수 없습니다"

#: src/ln.c:207
#, c-format
msgid "%s: hard link not allowed for directory"
msgstr "%s: 디렉터리는 하드링크할 수 없습니다"

#: src/ln.c:232
#, c-format
msgid "%s: cannot overwrite directory"
msgstr "%s: 디렉터리를 덮어쓸 수 없습니다"

#: src/ln.c:279
#, c-format
msgid "%s: replace %s? "
msgstr "%s: %s을(를) 바꿀까요? "

#: src/ln.c:377
#, c-format
msgid "failed to create symbolic link %s"
msgstr "%s 심볼릭 링크 만들기 실패"

#: src/ln.c:378
#, c-format
msgid "failed to create symbolic link %s -> %s"
msgstr "%s -> %s 심볼릭 링크 만들기 실패"

#: src/ln.c:380
#, c-format
msgid "failed to create hard link to %.0s%s"
msgstr "%.0s%s로의 하드 링크 만들기 실패"

#: src/ln.c:383
#, c-format
msgid "failed to create hard link %s"
msgstr "%s 하드 링크 만들기 실패"

#: src/ln.c:384
#, c-format
msgid "failed to create hard link %s => %s"
msgstr "%s => %s 하드링크 만들기 실패"

#: src/ln.c:410
#, c-format
msgid ""
"Usage: %s [OPTION]... [-T] TARGET LINK_NAME\n"
"  or:  %s [OPTION]... TARGET\n"
"  or:  %s [OPTION]... TARGET... DIRECTORY\n"
"  or:  %s [OPTION]... -t DIRECTORY TARGET...\n"
msgstr ""
"사용법: %s [<옵션>]... [-T] <대상> <링크이름>\n"
"  또는: %s [<옵션>]... <대상>\n"
"  또는: %s [<옵션>]... <대상>... <디렉터리>\n"
"  또는: %s [<옵션>]... -t <디렉터리> <대상>...\n"

#: src/ln.c:417
msgid ""
"In the 1st form, create a link to TARGET with the name LINK_NAME.\n"
"In the 2nd form, create a link to TARGET in the current directory.\n"
"In the 3rd and 4th forms, create links to each TARGET in DIRECTORY.\n"
"Create hard links by default, symbolic links with --symbolic.\n"
"By default, each destination (name of new link) should not already exist.\n"
"When creating hard links, each TARGET must exist.  Symbolic links\n"
"can hold arbitrary text; if later resolved, a relative link is\n"
"interpreted in relation to its parent directory.\n"
msgstr ""
"첫번째 형태에서는 <대상> 링크를 <링크_이름>으로 만듭니다.\n"
"두번째 형태에서는 <대상> 링크를 현재 디렉터리에 만듭니다.\n"
"세번째, 네번째 형태에서는 <디렉터리>의 각 <대상>의 링크를 만듭니다.\n"
"기본적으로 하드 링크를 만들며, 심볼릭 링크는 --symbolic 옵션을 씁니다.\n"
"하드 링크를 만들 때, 각 <대상>이 있어야 합니다.  심볼릭 링크는\n"
"임의의 텍스트를 유지할 수 있습니다. 나중에 링크 문제를 해결하면,\n"
"상대 링크는 자체 상위 디렉터리에 상대적으로 해석합니다.\n"

#: src/ln.c:430
msgid ""
"      --backup[=CONTROL]      make a backup of each existing destination "
"file\n"
"  -b                          like --backup but does not accept an argument\n"
"  -d, -F, --directory         allow the superuser to attempt to hard link\n"
"                                directories (note: will probably fail due "
"to\n"
"                                system restrictions, even for the "
"superuser)\n"
"  -f, --force                 remove existing destination files\n"
msgstr ""
"      --backup[=<제어>]       각 기존 대상 파일의 백업을 만듭니다\n"
"  -b                          --backup과 동일하나 인자를 받지 않습니다\n"
"  -d, -F, --directory         최고 관리자가 디렉터리 하드 링크를\n"
"                                시도할 수 있게 합니다 (참고: 최고 관리자에게"
"도\n"
"                                시스템 제한 때문에 실패할 수 있음)\n"
"  -f, --force                 기존 대상 파일을 제거합니다\n"

#: src/ln.c:438
msgid ""
"  -i, --interactive           prompt whether to remove destinations\n"
"  -L, --logical               dereference TARGETs that are symbolic links\n"
"  -n, --no-dereference        treat LINK_NAME as a normal file if\n"
"                                it is a symbolic link to a directory\n"
"  -P, --physical              make hard links directly to symbolic links\n"
"  -r, --relative              with -s, create links relative to link "
"location\n"
"  -s, --symbolic              make symbolic links instead of hard links\n"
msgstr ""
"  -i, --interactive           대상을 삭제할 지 여부를 묻습니다\n"
"  -L, --logical               심볼릭 링크 <대상>을 역참조합니다\n"
"  -n, --no-dereference        <링크_이름>이 디렉터리 심볼릭 링크일 경우\n"
"                                일반 파일로 간주합니다\n"
"  -P, --physical              심볼릭 링크에 직접적인 하드 링크를 만듭니다\n"
"  -r, --relative              -s 옵션을 붙여서 링크 위치에 상대적인 링크를 만"
"듭니다\n"
"  -s, --symbolic              하드 링크 대신 심볼릭 링크를 만듭니다\n"

#: src/ln.c:447
msgid ""
"  -S, --suffix=SUFFIX         override the usual backup suffix\n"
"  -t, --target-directory=DIRECTORY  specify the DIRECTORY in which to "
"create\n"
"                                the links\n"
"  -T, --no-target-directory   treat LINK_NAME as a normal file always\n"
"  -v, --verbose               print name of each linked file\n"
msgstr ""
"  -S, --suffix=<접미사>       일반적인 백업 접미사를 대체합니다\n"
"  -t, --target-directory=<디렉터리>  링크를 만들어 넣을 <디렉터리>를\n"
"                                지정합니다\n"
"  -T, --no-target-directory   <링크_이름>을 항상 일반 파일로 취급합니다\n"
"  -v, --verbose               각 링크 파일의 이름을 출력합니다\n"

#: src/ln.c:457
#, c-format
msgid ""
"\n"
"Using -s ignores -L and -P.  Otherwise, the last option specified controls\n"
"behavior when a TARGET is a symbolic link, defaulting to %s.\n"
msgstr ""
"\n"
"-s 옵션은 -L 옵션과 -P 옵션을 무시합니다.  아니면 %s을(를) 기본으로\n"
"<대상>이 심볼릭 링크일 떄 마지막에 지정한 옵션의 동작을 처리합니다.\n"

#: src/ln.c:540
#, c-format
msgid "target %s is not a directory"
msgstr "%s 대상은 디렉터리가 아닙니다"

#: src/ln.c:573
msgid "cannot do --relative without --symbolic"
msgstr "--symbolic 옵션 없이는 --relative 옵션 동작을 수행할 수 없습니다"

#: src/ln.c:585
msgid "cannot combine --target-directory and --no-target-directory"
msgstr "--target-directory와 --no-target-directory 옵션을 혼용할 수 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/logname.c:30
msgid "FIXME: unknown"
msgstr "FIXME: 알 수 없음"

#: src/logname.c:39
#, c-format
msgid "Usage: %s [OPTION]\n"
msgstr "사용법: %s [<옵션>]\n"

#: src/logname.c:40
msgid ""
"Print the user's login name.\n"
"\n"
msgstr ""
"사용자 로그인 이름을 출력합니다.\n"
"\n"

#: src/logname.c:78
msgid "no login name"
msgstr "로그인 이름 없음"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:780
msgid "%b %e  %Y"
msgstr "%Y년 %b %e일"

#. TRANSLATORS: ls output needs to be aligned for ease of reading,
#. so be wary of using variable width fields from the locale.
#. Note %b is handled specially by ls and aligned correctly.
#. Note also that specifying a width as in %5b is erroneous as strftime
#. will count bytes rather than characters in multibyte locales.
#: src/ls.c:793
msgid "%b %e %H:%M"
msgstr "%b %e일  %H:%M"

#: src/ls.c:2027
msgid "invalid line width"
msgstr "부적절한 행 길이"

#: src/ls.c:2105
msgid "invalid tab size"
msgstr "부적절한 탭 길이"

#: src/ls.c:2301
#, c-format
msgid "ignoring invalid width in environment variable COLUMNS: %s"
msgstr "환경 변수 COLUMNS의 값에 다음의 잘못된 폭이 지정되었습니다: %s"

#: src/ls.c:2332
#, c-format
msgid "ignoring invalid tab size in environment variable TABSIZE: %s"
msgstr "환경변수 TABSIZE의 값에 다음의 잘못된 탭 크기가 지정되었습니다: %s"

#: src/ls.c:2378
msgid "--dired and --zero are incompatible"
msgstr "--dired와 --zero 옵션은 호환성이 없습니다"

#: src/ls.c:2419
#, c-format
msgid "invalid time style format %s"
msgstr "부적절한 시간 형식 %s"

#: src/ls.c:2443
msgid "Valid arguments are:\n"
msgstr "올바른 인자:\n"

#: src/ls.c:2447
msgid "  - +FORMAT (e.g., +%H:%M) for a 'date'-style format\n"
msgstr "  - +<형식> (예: +%H:%M) 'date' 명령 방식의 형식입니다\n"

#: src/ls.c:2821
#, c-format
msgid "unrecognized prefix: %s"
msgstr "인식할 수 없는 접두사: %s"

#: src/ls.c:2851
#, c-format
msgid "unparsable value for LS_COLORS environment variable"
msgstr "LS_COLORS 환경 변수의 해석할 수 없는 값"

#: src/ls.c:2880 src/stat.c:1064
#, c-format
msgid "ignoring invalid value of environment variable QUOTING_STYLE: %s"
msgstr "QUOTING_STYLE 환경 변수에 지정한 부적절한 값 무시: %s"

#: src/ls.c:2949 src/pwd.c:164
#, c-format
msgid "cannot open directory %s"
msgstr "%s 디렉터리를 열 수 없습니다"

#: src/ls.c:2964
#, c-format
msgid "cannot determine device and inode of %s"
msgstr "%s의 장치와 inode를 확인할 수 없습니다"

#: src/ls.c:2973
#, c-format
msgid "%s: not listing already-listed directory"
msgstr "%s: 이미 확인한 디렉터리를 조회하지 않음"

#: src/ls.c:2998 src/ls.c:3415
#, c-format
msgid "error canonicalizing %s"
msgstr "%s 규정화 오류"

#: src/ls.c:3060 src/pwd.c:232
#, c-format
msgid "reading directory %s"
msgstr "%s 디렉터리 읽는 중"

#: src/ls.c:3075
#, c-format
msgid "closing directory %s"
msgstr "%s 디렉터리 닫는 중"

#: src/ls.c:3793
#, c-format
msgid "cannot compare file names %s and %s"
msgstr "%s와(과) %s 파일 이름을 비교할 수 없습니다"

#: src/ls.c:5403
msgid ""
"List information about the FILEs (the current directory by default).\n"
"Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.\n"
msgstr ""
"<파일>의 정보를 나타냅니다(기본: 현재 디렉터리).\n"
"-cftuvSUX 또는 --sort 옵션을 지정하지 않으면 항목을 알파벳 순으로 정렬합니"
"다.\n"

#: src/ls.c:5410
msgid ""
"  -a, --all                  do not ignore entries starting with .\n"
"  -A, --almost-all           do not list implied . and ..\n"
"      --author               with -l, print the author of each file\n"
"  -b, --escape               print C-style escapes for nongraphic "
"characters\n"
msgstr ""
"  -a, --all                  . (점)으로 시작하는 항목을 무시하지 않습니다\n"
"  -A, --almost-all           . 과 .. 를 목록으로 나타내지 않습니다\n"
"      --author               -l 옵션을 붙이면, 각 파일의 작성자를 출력합니"
"다\n"
"  -b, --escape               비시각적 문자를 C언어 방식 이스케이프로 출력합니"
"다\n"

#: src/ls.c:5416
msgid ""
"      --block-size=SIZE      with -l, scale sizes by SIZE when printing "
"them;\n"
"                             e.g., '--block-size=M'; see SIZE format below\n"
"\n"
msgstr ""
"      --block-size=<크기>    -l 옵션을 붙여 대상을 출력하면 <크기> 만큼 \n"
"                               블록 크기를 늘립니다\n"
"                               예: '--block-size=M'. <크기> 형식은 아래 참"
"조\n"
"\n"

#: src/ls.c:5421
msgid ""
"  -B, --ignore-backups       do not list implied entries ending with ~\n"
msgstr ""
"  -B, --ignore-backups       ~ 문자로 끝난 암시 항목을 나타내지 않습니다\n"
"\n"

#: src/ls.c:5424
msgid ""
"  -c                         with -lt: sort by, and show, ctime (time of "
"last\n"
"                             modification of file status information);\n"
"                             with -l: show ctime and sort by name;\n"
"                             otherwise: sort by ctime, newest first\n"
"\n"
msgstr ""
"  -c                         -lt 옵션 추가: 최종 수정 시각 기준으로 정렬 후 "
"나열\n"
"                               (파일 상태 정보의 최종 수정 시각)\n"
"                               -l 옵션 추가: 최종 수정 시각과 이름으로 정렬 "
"후 나열\n"
"                               기타: 최종 수정 시각 내림 차순으로 정렬\n"
"\n"

#: src/ls.c:5431
msgid ""
"  -C                         list entries by columns\n"
"      --color[=WHEN]         color the output WHEN; more info below\n"
"  -d, --directory            list directories themselves, not their "
"contents\n"
"  -D, --dired                generate output designed for Emacs' dired mode\n"
msgstr ""
"  -C                         열 별로 항목을 보여줍니다\n"
"      --color[=<시기>]         <시기>에 따라 색상 출력합니다. 자세한 내용은 "
"하단 참조\n"
"  -d, --directory            디렉터리의 내용이 아닌 그 자체를 보여줍니다\n"
"  -D, --dired                이맥스 dir 방식으로 설계한 출력을 만듭니다\n"

#: src/ls.c:5437
msgid ""
"  -f                         list all entries in directory order\n"
"  -F, --classify[=WHEN]      append indicator (one of */=>@|) to entries "
"WHEN\n"
"      --file-type            likewise, except do not append '*'\n"
msgstr ""
"  -f                         디렉터리 순으로 모슨 항목을 나타냅니다\n"
"  -F, --classify[=<시기>]    <시기>에 따라 항목에 식별자(*/=>@| 중 하나)를 붙"
"입니다\n"
"      --file-type            비슷하지만, '*'를 붙이는 경우를 제외합니다\n"

# !!DO NOT TRANSLATE!! --format= 다음에 실제로 across 와 같이 입력해야 함. 이 단어를 안내하는 부분.
#: src/ls.c:5442
msgid ""
"      --format=WORD          across -x, commas -m, horizontal -x, long -l,\n"
"                             single-column -1, verbose -l, vertical -C\n"
"\n"
msgstr ""
"      --format=<단어>          across -x, commas -m, horizontal -x, long -"
"l,\n"
"                             single-column -1, verbose -l, vertical -C\n"
"\n"

#: src/ls.c:5447
msgid "      --full-time            like -l --time-style=full-iso\n"
msgstr "      --full-time            -l --time-style=full-iso 옵션과 유사함\n"

#: src/ls.c:5450
msgid "  -g                         like -l, but do not list owner\n"
msgstr "  -g                         -l과 같지만 소유주를 보여주지 않습니다\n"

#: src/ls.c:5453
msgid ""
"      --group-directories-first\n"
"                             group directories before files;\n"
"                             can be augmented with a --sort option, but any\n"
"                             use of --sort=none (-U) disables grouping\n"
"\n"
msgstr ""
"      --group-directories-first\n"
"                             파일 출력 전 디렉터리를 모읍니다.\n"
"                               --sort 옵션으로 동작을 확장할 수 있지만,\n"
"                               --sort=none (-U) 옵션을 사용하면 분류 정렬\n"
"                               동작을 끌 수 있습니다.\n"
"\n"

#: src/ls.c:5460
msgid ""
"  -G, --no-group             in a long listing, don't print group names\n"
msgstr ""
"  -G, --no-group             길게 보여주지만 그룹 이름은 출력하지 않음\n"

#: src/ls.c:5463
msgid ""
"  -h, --human-readable       with -l and -s, print sizes like 1K 234M 2G "
"etc.\n"
"      --si                   likewise, but use powers of 1000 not 1024\n"
msgstr ""
"  -h, --human-readable       -l, -s 옵션과 같이, 1K 234M 2G 처럼 크기를 출"
"력.\n"
"      --si                   비슷하지만 1024배수가 아닌 1000배수를 활용합니"
"다\n"

#: src/ls.c:5467
msgid ""
"  -H, --dereference-command-line\n"
"                             follow symbolic links listed on the command "
"line\n"
msgstr ""
"  -H, --dereference-command-line\n"
"                             명령행에 나타난 심볼릭 링크를 따라갑니다\n"

#: src/ls.c:5471
msgid ""
"      --dereference-command-line-symlink-to-dir\n"
"                             follow each command line symbolic link\n"
"                             that points to a directory\n"
"\n"
msgstr ""
"      --dereference-command-line-symlink-to-dir\n"
"                             각 명령행에서 디렉터리를 가리키는\n"
"                             심볼릭 링크를 따라갑니다\n"
"\n"

#: src/ls.c:5477
msgid ""
"      --hide=PATTERN         do not list implied entries matching shell "
"PATTERN\n"
"                             (overridden by -a or -A)\n"
"\n"
msgstr ""
"      --hide=<패턴>         셸 <패턴>에 일치하는 암시 항목은 나타내지 않습니"
"다\n"
"                             (-a 또는 -A가 더 우선함)\n"
"\n"

#: src/ls.c:5483
msgid "      --hyperlink[=WHEN]     hyperlink file names WHEN\n"
msgstr ""
"      --hyperlink[=<시기>]   <시기>에 맞춰 파일 이름의 하이퍼링크를 만듭니"
"다\n"

#: src/ls.c:5486
msgid ""
"      --indicator-style=WORD\n"
"                             append indicator with style WORD to entry "
"names:\n"
"                             none (default), slash (-p),\n"
"                             file-type (--file-type), classify (-F)\n"
"\n"
msgstr ""
"      --indicator-style=<단어>  항목 이름에 <단어> 방식의 표시를 붙여둡니"
"다:\n"
"                               none (기본값), slash (-p),\n"
"                               file-type (--file-type), classify (-F)\n"
"\n"

#: src/ls.c:5493
msgid ""
"  -i, --inode                print the index number of each file\n"
"  -I, --ignore=PATTERN       do not list implied entries matching shell "
"PATTERN\n"
msgstr ""
"  -i, --inode                각 파일의 인덱스 번호를 출력합니다\n"
"  -I, --ignore=<패턴>        셸 <패턴>에 일치하는 암시 항목을 나타내지 않습니"
"다\n"

#: src/ls.c:5498
msgid ""
"  -k, --kibibytes            default to 1024-byte blocks for file system "
"usage;\n"
"                             used only with -s and per directory totals\n"
"\n"
msgstr ""
"  -k, --kibibytes            1024 바이트 블록을 파일 시스템 사용 정보 기본 단"
"위로 합니다.\n"
"                               디렉터리별 총계를 나타낼 때는 -s 옵션만 함께 "
"사용합니다\n"
"\n"

#: src/ls.c:5504
msgid "  -l                         use a long listing format\n"
msgstr ""
"  -l                         긴 목록 형식으로 보여줍니다\n"
"\n"

#: src/ls.c:5507
msgid ""
"  -L, --dereference          when showing file information for a symbolic\n"
"                             link, show information for the file the link\n"
"                             references rather than for the link itself\n"
"\n"
msgstr ""
"  -L, --dereference          심볼릭 링크 파일 정보를 보여줄 때 링크 자체를\n"
"                               보여주기 보다는 링크 참조의 파일 정보를 보여줍"
"니다\n"
"\n"
"\n"

#: src/ls.c:5513
msgid ""
"  -m                         fill width with a comma separated list of "
"entries\n"
msgstr ""
"  -m                         쉼표로 구분한 항목 목록으로 너비를 채웁니다\n"

#: src/ls.c:5517
msgid ""
"  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs\n"
"  -N, --literal              print entry names without quoting\n"
"  -o                         like -l, but do not list group information\n"
"  -p, --indicator-style=slash\n"
"                             append / indicator to directories\n"
msgstr ""
"  -n, --numeric-uid-gid      -l과 유사하나, 사용자/그룹 숫자 ID를 나타냅니"
"다\n"
"  -N, --literal              따옴표 처리하지 않은 항목 이름을 출력합니다\n"
"  -o                         -l과 유사하나, 그룹 정보를 나타내지 않습니다\n"
"  -p, --indicator-style=slash\n"
"                             디렉터리 뒤에 / 표시를 붙입니다\n"

#: src/ls.c:5524
msgid "  -q, --hide-control-chars   print ? instead of nongraphic characters\n"
msgstr "  -q, --hide-control-chars   비형 문자 대신 ? 문자를 출력합니다\n"

#: src/ls.c:5527
msgid ""
"      --show-control-chars   show nongraphic characters as-is (the default,\n"
"                             unless program is 'ls' and output is a "
"terminal)\n"
"\n"
msgstr ""
"      --show-control-chars   출력할 수 없는 문자를 그대로 보여줍니다(기본값"
"은,\n"
"                               프로그램이 'ls'이며 출력 대상이 터미널인 경우"
"가 아닐 경우)\n"

#: src/ls.c:5533
msgid "  -Q, --quote-name           enclose entry names in double quotes\n"
msgstr "  -Q, --quote-name           목록 이름을 큰따옴표 안에 넣습니다\n"

#: src/ls.c:5536
msgid ""
"      --quoting-style=WORD   use quoting style WORD for entry names:\n"
"                             literal, locale, shell, shell-always,\n"
"                             shell-escape, shell-escape-always, c, escape\n"
"                             (overrides QUOTING_STYLE environment variable)\n"
"\n"
msgstr ""
"      --quoting-style=WORD   WORD의 인용 스타일을 사용합니다. 가능한 값은:\n"
"                               literal, locale, shell, shell-always, c, "
"escape\n"
"                               (QUOTING_STYLE 환경 변수 값을 덮어씀)\n"
"\n"

#: src/ls.c:5543
msgid ""
"  -r, --reverse              reverse order while sorting\n"
"  -R, --recursive            list subdirectories recursively\n"
"  -s, --size                 print the allocated size of each file, in "
"blocks\n"
msgstr ""
"  -r, --reverse              정렬을 역순으로 합니다\n"
"  -R, --recursive            하위 디렉터리를 연속으로 조회합니다\n"
"  -s, --size                 각 파일의 블록 단위 할당 크기를 출력합니다\n"

#: src/ls.c:5548
msgid "  -S                         sort by file size, largest first\n"
msgstr ""
"  -S                         큰 파일부터 파일 크기 순서대로 정렬합니다\n"

#: src/ls.c:5551
msgid ""
"      --sort=WORD            sort by WORD instead of name: none (-U), size (-"
"S),\n"
"                             time (-t), version (-v), extension (-X), width\n"
"\n"
msgstr ""
"      --sort=<단어>          이름 대신 <단어>값 기준 정렬: none (-U), size (-"
"S),\n"
"                             time (-t), version (-v), extension (-X), width\n"
"\n"

#: src/ls.c:5557
msgid ""
"      --time=WORD            change the default of using modification "
"times;\n"
"                               access time (-u): atime, access, use;\n"
"                               change time (-c): ctime, status;\n"
"                               birth time: birth, creation;\n"
"                             with -l, WORD determines which time to show;\n"
"                             with --sort=time, sort by WORD (newest first)\n"
"\n"
msgstr ""
"      --time=<단어>            수정 시각 대신 정렬 시간 기준을 바꿉니다\n"
"                               접근 시각 (-u): atime, access, use\n"
"                               변경 시각 (-c): ctime, status\n"
"                               생성 시각: birth, creation\n"
"                             -l 옵션으로는, <단어>로 보여줄 시각을 지정합니"
"다\n"
"                             --sort=time 옵션으로는, <단어> 지정 기준 순으"
"로\n"
"                             정렬합니다 (최신 항목 우선)\n"
"\n"

#: src/ls.c:5566
msgid ""
"      --time-style=TIME_STYLE\n"
"                             time/date format with -l; see TIME_STYLE below\n"
msgstr ""
"      --time-style=<시각_형식>\n"
"                             -l 옵션이 붙은 날짜/시각 형식입니다 아래 <시각_"
"형식> 참조\n"

#: src/ls.c:5570
msgid ""
"  -t                         sort by time, newest first; see --time\n"
"  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8\n"
msgstr ""
"  -t                         시간순으로 정렬. 최신이 먼저옵니다. --time 참"
"조\n"
"  -T, --tabsize=<열>         8 대신 <열> 길이만큼 탭 간격을 지정합니다\n"

#: src/ls.c:5574
msgid ""
"  -u                         with -lt: sort by, and show, access time;\n"
"                             with -l: show access time and sort by name;\n"
"                             otherwise: sort by access time, newest first\n"
"\n"
msgstr ""
"  -u                         -lt 옵션 혼용: 접근 시간순 정렬 후 표시\n"
"                               -l 옵션 혼용: 이름순 정렬 후 접근시간 표시\n"
"                               기타: 접근 시간순 정렬 후, 최신 항목부터 표"
"시\n"
"\n"

#: src/ls.c:5580
msgid ""
"  -U                         do not sort; list entries in directory order\n"
msgstr ""
"  -U                         정렬하지 않고 디렉터리 순서대로 보여줍니다\n"

#: src/ls.c:5583
msgid ""
"  -v                         natural sort of (version) numbers within text\n"
msgstr ""
"  -v                         텍스트 내의 (버전) 번호를 자연스레 정렬합니다\n"

#: src/ls.c:5586
msgid ""
"  -w, --width=COLS           set output width to COLS.  0 means no limit\n"
"  -x                         list entries by lines instead of by columns\n"
"  -X                         sort alphabetically by entry extension\n"
"  -Z, --context              print any security context of each file\n"
"      --zero                 end each output line with NUL, not newline\n"
"  -1                         list one file per line\n"
msgstr ""
"  -w, --width=<열>           <열> 길이만큼 출력폭을 제한. 0은 제한 없음\n"
"  -x                         열 대신 행 별로 항목을 나열\n"
"  -X                         항목을 확장하여 알파벳순 정렬\n"
"  -Z, --context              각 파일의 보안 컨텍스트 출력\n"
"      --zero                 각 출력 행 끝을 개행문자가 아닌 NUL 문자로 끝내"
"기\n"
"  -1                         한 줄당 파일 하나 나열\n"

#: src/ls.c:5597
msgid ""
"\n"
"The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.\n"
"FORMAT is interpreted like in date(1).  If FORMAT is "
"FORMAT1<newline>FORMAT2,\n"
"then FORMAT1 applies to non-recent files and FORMAT2 to recent files.\n"
"TIME_STYLE prefixed with 'posix-' takes effect only outside the POSIX "
"locale.\n"
"Also the TIME_STYLE environment variable sets the default style to use.\n"
msgstr ""
"\n"
"<시각_형식> 인자는 full-iso, long-iso, iso, locale, or +<형식> 중 하나가 될 "
"수 있습니다.\n"
"<형식>은 date(1) 명령처럼 해석합니다.  <형식>이 <형식1><newline><형식2>의 형"
"태라면,\n"
"<형식1>에는 최신 이전의 설정을 적용하고 <형식2>에 최신 설정을 적용합니다.\n"
"<시각_형식> 앞에 'posix-' 접두사를 붙이면 POSIX 로캘이 아닐 경우에만 동작합니"
"다.\n"
"<시각_형식> 환경 변수는 또한 활용 기본 모양새를 설정하기도 합니다.\n"

#: src/ls.c:5605
msgid ""
"\n"
"The WHEN argument defaults to 'always' and can also be 'auto' or 'never'.\n"
msgstr ""
"\n"
"<시기> 인자에는 'always'가 기본값으로 들어가며, 'auto' 또는 'never' 값이 들어"
"갈 수 있습니다.\n"

#: src/ls.c:5609
msgid ""
"\n"
"Using color to distinguish file types is disabled both by default and\n"
"with --color=never.  With --color=auto, ls emits color codes only when\n"
"standard output is connected to a terminal.  The LS_COLORS environment\n"
"variable can change the settings.  Use the dircolors(1) command to set it.\n"
msgstr ""
"\n"
"파일 형식을 구분하는 색상의 사용을 기본적으로 껐거나 --color=never 옵션\n"
"으로 막아두었습니다.  --color=auto 옵션을 쓰면 표준 출력을 터미널에 연결\n"
"했을 경우에만 ls 명령에서 색상 코드를 출력합니다.  LS_COLORS 환경 변수에서\n"
"설정을 바꿀 수 있습니다.  이 값을 설정하려면 dircolors(1) 명령을 사용하십시"
"오.\n"

#: src/ls.c:5616
msgid ""
"\n"
"Exit status:\n"
" 0  if OK,\n"
" 1  if minor problems (e.g., cannot access subdirectory),\n"
" 2  if serious trouble (e.g., cannot access command-line argument).\n"
msgstr ""
"\n"
"종료 상태코드:\n"
" 0  정상,\n"
" 1  단순한 문제 (예: 하위 디렉터리 접근 불가),\n"
" 2  중대한 문제 (예: 명령행 인자 접근 불가).\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/digest.c:135
msgid "Kayvan Aghaiepour"
msgstr "Kayvan Aghaiepour"

#. This is a proper name. See the gettext manual, section Names.
#: src/digest.c:140
msgid "Q. Frank Xia"
msgstr "Q. Frank Xia"

#. This is a proper name. See the gettext manual, section Names.
#: src/digest.c:144
msgid "Samuel Neves"
msgstr "Samuel Neves"

#. This is a proper name. See the gettext manual, section Names.
#: src/digest.c:147 src/seq.c:48
msgid "Ulrich Drepper"
msgstr "Ulrich Drepper"

#. This is a proper name. See the gettext manual, section Names.
#: src/digest.c:148
msgid "Scott Miller"
msgstr "Scott Miller"

#. This is a proper name. See the gettext manual, section Names.
#: src/digest.c:149
msgid "David Madore"
msgstr "David Madore"

#: src/digest.c:409
msgid ""
"Print or verify checksums.\n"
"By default use the 32 bit CRC algorithm.\n"
msgstr ""
"검사합을 출력하거나 검증합니다.\n"
"기본적으로 32비트 CRC 알고리즘을 활용합니다.\n"

#: src/digest.c:414
#, c-format
msgid "Print or check %s (%d-bit) checksums.\n"
msgstr "%s (%d 비트) 검사합을 출력하거나 확인합니다.\n"

#: src/digest.c:423
msgid ""
"\n"
"  -r              use BSD sum algorithm (the default), use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
msgstr ""
"\n"
"  -r              BSD 합 알고리즘 사용 (기본값), 1K 블럭 사용\n"
"  -s, --sysv      시스템 V 합 알고리즘 사용, 512 바이트 블럭 사용\n"

#: src/digest.c:433
msgid ""
"  -a, --algorithm=TYPE  select the digest type to use.  See DIGEST below.\n"
msgstr ""
"  -a, --algorithm=<형식>  사용할 다이제스트 형식을 선택합니다. 아래 <다이제스"
"트>를 참고하십시오.\n"

#: src/digest.c:441
msgid ""
"  -b, --binary          read in binary mode (default unless reading tty "
"stdin)\n"
msgstr ""
"  -b, --binary          바이너리 모드로 읽어들입니다 (tty 표준 입력으로 읽지 "
"않은 한 기본)\n"

#: src/digest.c:446
msgid "  -b, --binary          read in binary mode\n"
msgstr "  -b, --binary          이진 모드로 읽습니다\n"

#: src/digest.c:450
msgid "  -c, --check           read checksums from the FILEs and check them\n"
msgstr "  -c, --check           <파일>에서 검사합을 읽어 검사합니다\n"

#: src/digest.c:454
msgid ""
"  -l, --length=BITS     digest length in bits; must not exceed the max for\n"
"                          the blake2 algorithm and must be a multiple of 8\n"
msgstr ""
"  -l, --length=<비트>     비트 길이에 대해 다이제스트 연산을 수행합니다. "
"blake2 \n"
"                          알고리즘의 최대 길이를 넘어서면 안되며 8의 배수여"
"야 합니다\n"

#: src/digest.c:460
msgid "      --tag             create a BSD-style checksum (the default)\n"
msgstr "      --tag             BSD 방식 검사합을 만듭니다 (기본값)\n"

#: src/digest.c:463
msgid ""
"      --untagged        create a reversed style checksum, without digest "
"type\n"
msgstr ""
"      --untagged        다이제스트 형식을 지정하지 않고 반전 형식 검사합을 만"
"듭니다\n"

#: src/digest.c:467
msgid "      --tag             create a BSD-style checksum\n"
msgstr "      --tag             BSD 방식 검사합을 만듭니다\n"

#: src/digest.c:473
msgid ""
"  -t, --text            read in text mode (default if reading tty stdin)\n"
msgstr "  -t, --text            텍스트 모드로 읽기 (tty 표준 입력 읽기 기본)\n"

#: src/digest.c:477
msgid "  -t, --text            read in text mode (default)\n"
msgstr "  -t, --text            텍스트 모드로 읽기 (기본)\n"

#: src/digest.c:481
msgid ""
"  -z, --zero            end each output line with NUL, not newline,\n"
"                          and disable file name escaping\n"
msgstr ""
"  -z, --zero            각 출력 행을 개행 문자가 아닌 NUL로 끝내며,\n"
"                          파일 이름을 이스케이핑하지 않습니다\n"

#: src/digest.c:485
msgid ""
"\n"
"The following five options are useful only when verifying checksums:\n"
"      --ignore-missing  don't fail or report status for missing files\n"
"      --quiet           don't print OK for each successfully verified file\n"
"      --status          don't output anything, status code shows success\n"
"      --strict          exit non-zero for improperly formatted checksum "
"lines\n"
"  -w, --warn            warn about improperly formatted checksum lines\n"
"\n"
msgstr ""
"\n"
"다음 다섯가지 옵션은 검사합을 검사할 경우에만 해당합니다:\n"
"      --ignore-missing  빠진 파일에 대해 실패를 반환하거나 상태 보고를 하지 "
"않음\n"
"      --quiet          파일을 검증한 후 OK를 출력하지 않음\n"
"      --status            출력을 하지 않고, 상태 코드는 성공/실패를 반환\n"
"      --strict         검사합 행을 제대로 갖추지 못햇을 경우 0이 아닌 값을 반"
"환\n"
"  -w, --warn              부적절한 형식의 검사합 행 경고\n"
"\n"

#: src/digest.c:497
msgid "      --debug           indicate which implementation used\n"
msgstr "      --debug           어떤 구현체를 활용하는지 나타냅니다\n"

#: src/digest.c:504
msgid ""
"\n"
"DIGEST determines the digest algorithm and default output format:\n"
"  sysv      (equivalent to sum -s)\n"
"  bsd       (equivalent to sum -r)\n"
"  crc       (equivalent to cksum)\n"
"  md5       (equivalent to md5sum)\n"
"  sha1      (equivalent to sha1sum)\n"
"  sha224    (equivalent to sha224sum)\n"
"  sha256    (equivalent to sha256sum)\n"
"  sha384    (equivalent to sha384sum)\n"
"  sha512    (equivalent to sha512sum)\n"
"  blake2b   (equivalent to b2sum)\n"
"  sm3       (only available through cksum)\n"
"\n"
msgstr ""
"\n"
"<다이제스트> 는 다이제스트 알고리즘과 기본 출력 형식을 결정합니다:\n"
"  sysv      (-s 합과 동일)\n"
"  bsd       (-r 합과 동일)\n"
"  crc       (cksum과 동일)\n"
"  md5       (md5sum과 동일)\n"
"  sha1      (sha1sum과 동일)\n"
"  sha224    (sha224sum과 동일)\n"
"  sha256    (sha256sum과 동일)\n"
"  sha384    (sha384sum과 동일)\n"
"  sha512    (sha512sum과 동일)\n"
"  blake2b   (b2sum과 동일)\n"
"  sm3       (cksum으로만 가능)\n"
"\n"

#: src/digest.c:521
#, c-format
msgid ""
"\n"
"The sums are computed as described in %s.\n"
msgstr ""
"\n"
"%s에 설명한대로 검사합을 계산합니다.\n"

#: src/digest.c:524
msgid ""
"When checking, the input should be a former output of this program.\n"
"The default mode is to print a line with: checksum, a space,\n"
"a character indicating input mode ('*' for binary, ' ' for text\n"
"or where binary is insignificant), and name for each FILE.\n"
"\n"
"Note: There is no difference between binary mode and text mode on GNU "
"systems.\n"
msgstr ""
"검사할 때, 입력은 이 프로그램의 출력 데이터여야 합니다.\n"
"기본 모드는 검사합, 공백, 입력 모드를 나타내는 문자 (이진\n"
"파일은 '*', 문서 파일은 ' '), 그리고 각 <파일>의 이름입니다.\n"
"\n"
"참고: GNU 시스템에서 바이너리 모드와 텍스트 모드에는 차이가 없습니다.\n"

#: src/digest.c:534
msgid ""
"When checking, the input should be a former output of this program,\n"
"or equivalent standalone program.\n"
msgstr ""
"검사할 때 입력을 이 프로그램의 출력 앞에 지정하거나,\n"
"대응 독립 프로그램으로 지정해야 합니다.\n"

#: src/digest.c:1070
#, c-format
msgid "%s: too many checksum lines"
msgstr "%s: 검사합 행이 너무 많습니다"

#: src/digest.c:1100
#, c-format
msgid "%s: %<PRIuMAX>: improperly formatted %s checksum line"
msgstr "%s: %<PRIuMAX>: 부적절한 형식을 갖춘 %s 검사합 행"

#: src/digest.c:1133
msgid "FAILED open or read"
msgstr "열기 또는 읽기 실패"

#: src/digest.c:1171
msgid "FAILED"
msgstr "실패"

#: src/digest.c:1173
msgid "OK"
msgstr "성공"

#: src/digest.c:1198
#, c-format
msgid "%s: no properly formatted checksum lines found"
msgstr "%s: 올바른 형식을 갖춘 검사합 행을 찾지 못함"

#: src/digest.c:1208
#, c-format
msgid "WARNING: %<PRIuMAX> line is improperly formatted"
msgid_plural "WARNING: %<PRIuMAX> lines are improperly formatted"
msgstr[0] "경고: 행 %<PRIuMAX>번의 형식 지정이 부적절합니다"

#: src/digest.c:1216
#, c-format
msgid "WARNING: %<PRIuMAX> listed file could not be read"
msgid_plural "WARNING: %<PRIuMAX> listed files could not be read"
msgstr[0] "경고: 열거한 파일 %<PRIuMAX>개를 읽을 수 없습니다"

#: src/digest.c:1224
#, c-format
msgid "WARNING: %<PRIuMAX> computed checksum did NOT match"
msgid_plural "WARNING: %<PRIuMAX> computed checksums did NOT match"
msgstr[0] "경고: 처리한 검사합 %<PRIuMAX>개가 일치하지 않습니다"

#: src/digest.c:1230
#, c-format
msgid "%s: no file was verified"
msgstr "%s: 검증한 파일 없음"

#: src/digest.c:1301
msgid "invalid length"
msgstr "부적절한 길이"

#: src/digest.c:1305 src/digest.c:1380
#, c-format
msgid "invalid length: %s"
msgstr "부적절한 길이: %s"

#: src/digest.c:1306
msgid "length is not a multiple of 8"
msgstr "길이가 8의 배수가 아닙니다"

#: src/digest.c:1376
msgid "--length is only supported with --algorithm=blake2b"
msgstr "--length 옵션은 --algorithm=blake2b 옵션만 지원합니다"

#: src/digest.c:1382
#, c-format
msgid "maximum digest length for %s is %d bits"
msgstr "%s의 최대 다이제스트 길이는 %d 비트 입니다"

#: src/digest.c:1407
msgid "--check is not supported with --algorithm={bsd,sysv,crc}"
msgstr "--check 옵션은 --algorithm={bsd,sysv,crc} 옵션을 지원하지 않습니다"

#: src/digest.c:1422
#, c-format
msgid "--tag does not support --text mode"
msgstr "--tag 옵션은 --text 모드를 지원하지 않습니다"

#: src/digest.c:1428
#, c-format
msgid "the --zero option is not supported when verifying checksums"
msgstr "--zero 옵션은 검사합 검증시 지원하지 않습니다"

#: src/digest.c:1435
#, c-format
msgid "the --tag option is meaningless when verifying checksums"
msgstr "--tag 옵션은 검사합을 검사할 때는 의미가 없습니다"

#: src/digest.c:1444
#, c-format
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "--binary와 --text 옵션은 검사합을 검증할 때만 의미가 있습니다"

#: src/digest.c:1453
#, c-format
msgid "the --ignore-missing option is meaningful only when verifying checksums"
msgstr "--ignore-missing 옵션은 검사합을 검증할 때만 의미가 있습니다"

#: src/digest.c:1461
#, c-format
msgid "the --status option is meaningful only when verifying checksums"
msgstr "--status 옵션은 검사합을 검증할 때만 의미가 있습니다"

#: src/digest.c:1468
#, c-format
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "--warn 옵션은 오직 검사합을 검증할 때만 의미가 있습니다"

#: src/digest.c:1475
#, c-format
msgid "the --quiet option is meaningful only when verifying checksums"
msgstr "--quiet 옵션은 검사합을 검증할 때만 의미가 있습니다"

#: src/digest.c:1482
#, c-format
msgid "the --strict option is meaningful only when verifying checksums"
msgstr "--strict 옵션은 검사합을 검증할 때만 의미가 있습니다"

#: src/mkdir.c:59 src/rmdir.c:174
#, c-format
msgid "Usage: %s [OPTION]... DIRECTORY...\n"
msgstr "사용법: %s [<옵션>]... <디렉터리>...\n"

#: src/mkdir.c:60
msgid "Create the DIRECTORY(ies), if they do not already exist.\n"
msgstr "<디렉터리>가 없을 경우 만듭니다.\n"

#: src/mkdir.c:66
msgid ""
"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\n"
"  -p, --parents     no error if existing, make parent directories as "
"needed,\n"
"                    with their file modes unaffected by any -m option.\n"
"  -v, --verbose     print a message for each created directory\n"
msgstr ""
"  -m, --mode=<모드>   a=rwx - umask가 아닌, (chmod의) 파일 모드를 설정합니"
"다\n"
"  -p, --parents     상위 디렉터리가 있으면 필요에 따라 오류를 나타내지 않으"
"며, 필요한 경우\n"
"                    어떤 -m 옵션에 영향을 받지 않는 자체 모드로 상위 디렉터리"
"를 만듭니다. \n"
"  -v, --verbose     만들어 둔 각 디렉터리의 메시지를 출력합니다\n"

#: src/mkdir.c:72
msgid ""
"  -Z                   set SELinux security context of each created "
"directory\n"
"                         to the default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   생성한 각 디렉터리의 SELinux 보안 컨텍스트를 기본형으"
"로\n"
"                         설정합니다\n"
"      --context[=<컨텍스트>]  -Z와 유사하나, <컨텍스트>를 지정했다면 \n"
"                         SELinux/SMACK 보안 컨텍스트를 <컨텍스트>로 설정합니"
"다\n"

#: src/mkdir.c:225
#, c-format
msgid "created directory %s"
msgstr "%s 디렉터리를 만들었습니다"

#: src/mkdir.c:248 src/mkfifo.c:122 src/mknod.c:139
#, c-format
msgid ""
"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel"
msgstr "경고: --context 무시. SELinux/SMACK 활성 커널이 필요합니다"

#: src/mkfifo.c:54 src/pathchk.c:88
#, c-format
msgid "Usage: %s [OPTION]... NAME...\n"
msgstr "사용법: %s [<옵션>]... <이름>...\n"

#: src/mkfifo.c:55
msgid "Create named pipes (FIFOs) with the given NAMEs.\n"
msgstr "주어진 <이름>으로 명명 파이프(FIFO)를 만듭니다.\n"

#: src/mkfifo.c:61 src/mknod.c:63
msgid ""
"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\n"
msgstr ""
"  -m, --mode=<모드>   파일 권한 비트를 a=rw - umask가 아닌, <모드>로 지정합니"
"다\n"

#: src/mkfifo.c:64 src/mknod.c:66
msgid ""
"  -Z                   set the SELinux security context to default type\n"
"      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\n"
"                         or SMACK security context to CTX\n"
msgstr ""
"  -Z                   SELinux 보안 컨텍스트를 기본형으로 설정합니다\n"
"      --context[=CTX]  -Z와 유사하나, <컨텍스트>를 지정했다면 \n"
"                         SELinux/SMACK 보안 컨텍스트를 <컨텍스트>로 설정합니"
"다\n"

#: src/mkfifo.c:159 src/mknod.c:156
msgid "invalid mode"
msgstr "부적절한 모드"

#: src/mkfifo.c:166 src/mknod.c:163
msgid "mode must specify only file permission bits"
msgstr "모드에는 파일 권한 비트만 지정해야 합니다"

#: src/mkfifo.c:180 src/mknod.c:276
#, c-format
msgid "cannot set permissions of %s"
msgstr "%s의 권한을 설정할 수 없습니다"

#: src/mknod.c:55
#, c-format
msgid "Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\n"
msgstr "사용법: %s [<옵션>]... <이름> <형식> [<주번호> <부번호>]\n"

#: src/mknod.c:57
msgid "Create the special file NAME of the given TYPE.\n"
msgstr "주어진 <형식>의 <이름>을 가진 특수 파일을 만듭니다.\n"

#: src/mknod.c:73
msgid ""
"\n"
"Both MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\n"
"must be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\n"
"it is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\n"
"otherwise, as decimal.  TYPE may be:\n"
msgstr ""
"\n"
"<형식>이 b, c, u일 때 <주>, <부> 값을 지정해야 하며 <형식>이 p 이면 생략해"
"야\n"
"합니다. <주>, <부> 값이 0x 또는 0X로 시작하면, 16진수로 해석합니다. 그렇지\n"
"않고 0으로 시작하면 8진수로 해석하며, 아니면 10진수로 해석합니다. <형식>은\n"
"다음 값을 쓸 수 있습니다:\n"
"\n"

#: src/mknod.c:80
msgid ""
"\n"
"  b      create a block (buffered) special file\n"
"  c, u   create a character (unbuffered) special file\n"
"  p      create a FIFO\n"
msgstr ""
"\n"
"  b      블럭(버퍼링 있는) 특별 파일을 만듭니다.\n"
"  c, u   캐릭터(버퍼링 없는) 특별 파일을 만듭니다.\n"
"  p      FIFO를 만듭니다\n"

#: src/mknod.c:181
msgid "Special files require major and minor device numbers."
msgstr "득수 파일은 장치 주/부 번호가 필요합니다."

#: src/mknod.c:191
msgid "Fifos do not have major and minor device numbers."
msgstr "FIFO 버퍼는 장치 주/부 번호를 보유하지 않습니다."

#: src/mknod.c:216
msgid "block special files not supported"
msgstr "블록 특수 파일을 지원하지 않습니다"

#: src/mknod.c:225
msgid "character special files not supported"
msgstr "문자 특수 파일을 지원하지 않습니다"

#: src/mknod.c:241
#, c-format
msgid "invalid major device number %s"
msgstr "부적절한 장치 주번호 %s"

#: src/mknod.c:246
#, c-format
msgid "invalid minor device number %s"
msgstr "부적절한 장치 부번호 %s"

#: src/mknod.c:251
#, c-format
msgid "invalid device %s %s"
msgstr "부적절한 %2$s 장치 %1$s"

#: src/mknod.c:271
#, c-format
msgid "invalid device type %s"
msgstr "부적절한 %s 장치 형식"

#. This is a proper name. See the gettext manual, section Names.
#: src/mktemp.c:37
msgid "Eric Blake"
msgstr "Eric Blake"

#: src/mktemp.c:67
#, c-format
msgid "Usage: %s [OPTION]... [TEMPLATE]\n"
msgstr "사용법: %s [<옵션>]... [<양식>]\n"

#: src/mktemp.c:68
msgid ""
"Create a temporary file or directory, safely, and print its name.\n"
"TEMPLATE must contain at least 3 consecutive 'X's in last component.\n"
"If TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\n"
msgstr ""
"임시 파일 또는 디렉터리를 안전하게 만들고 이름을 출력합니다.\n"
"<양식>에는 최소한 뒷 부분에 'X'가 3번 들어가야 합니다.\n"
"<양식>을 지정하지 않았다면, use tmp.XXXXXXXXXX 파일을 사용하고, --tmpdir 옵션"
"을 붙입니다.\n"

#: src/mktemp.c:73
msgid ""
"Files are created u+rw, and directories u+rwx, minus umask restrictions.\n"
msgstr "파일은 u+rw로, 디렉터리는 u+rwx로 만들었으며, umask 제한은 뺐습니다.\n"

#: src/mktemp.c:77
msgid ""
"  -d, --directory     create a directory, not a file\n"
"  -u, --dry-run       do not create anything; merely print a name (unsafe)\n"
"  -q, --quiet         suppress diagnostics about file/dir-creation failure\n"
msgstr ""
"  -d, --directory     파일이 아닌 디렉터리를 만듭니다\n"
"  -u, --dry-run       무엇이든 만들지 않습니다. 단지 이름만 출력합니다 (안전"
"하지 않음)\n"
"  -q, --quiet         파일/디렉터리 생성 실패 진단 내용을 숨깁니다\n"

#: src/mktemp.c:82
msgid ""
"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a "
"slash.\n"
"                        This option is implied if TEMPLATE does not end in "
"X\n"
msgstr ""
"      --suffix=<접미사>  <양식>에 <접미사>를 덧붙입니다. <접미사>에 '/'가\n"
"                        들어있으면 안됩니다. <양식>을 X로 끝내지 않을 경우\n"
"                        이 옵션은 자동으로 붙습니다.\n"

#: src/mktemp.c:86
msgid ""
"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\n"
"                        specified, use $TMPDIR if set, else /tmp.  With\n"
"                        this option, TEMPLATE must not be an absolute name;\n"
"                        unlike with -t, TEMPLATE may contain slashes, but\n"
"                        mktemp creates only the final component\n"
msgstr ""
"  -p <디렉터리>, --tmpdir[=<디렉터리>]  <디렉터리>에 상대적인 <양식>을 해석합"
"니다.\n"
"                        <디렉터리>를 지정하지 않으면, $TMPDIR를 지정했을 때\n"
"                        이 변수값을 사용하며, 아니면 /tmp 경로를 활용합니"
"다.\n"
"                        이 옵션으로 <양식>에 절대 이름을 설정하면 안됩니다.\n"
"                        -t 와는 달리 <양식>에 슬래시가 들어갈 수 있지만,\n"
"                        mktemp는 최종 구성 항목만 만듭니다\n"

#: src/mktemp.c:93
msgid ""
"  -t                  interpret TEMPLATE as a single file name component,\n"
"                        relative to a directory: $TMPDIR, if set; else the\n"
"                        directory specified via -p; else /tmp [deprecated]\n"
msgstr ""
"  -t                  <양식>을 디렉터리에 상대적인 단일 파일 이름 요소\n"
"                        로 해석합니다. $TMPDIR을 설정했을 경우 이 변수를\n"
"                        활용하며, -p로 지정한 디렉터리 값이 있다면 이 값을,\n"
"                        그렇지 않으면 /tmp [낡은 방식] 경로를 활용합니다.\n"

#: src/mktemp.c:211
#, c-format
msgid "too many templates"
msgstr "양식이 너무 많습니다"

#: src/mktemp.c:231
#, c-format
msgid "with --suffix, template %s must end in X"
msgstr "--suffix 옵션에는 %s 양식을 X로 끝내야 합니다"

#: src/mktemp.c:256 src/split.c:1350
#, c-format
msgid "invalid suffix %s, contains directory separator"
msgstr "잘못된 접미사 %s. 디렉터리 구분자가 있습니다"

#: src/mktemp.c:261
#, c-format
msgid "too few X's in template %s"
msgstr "%s 양식의 X가 너무 적습니다"

#: src/mktemp.c:277
#, c-format
msgid "invalid template, %s, contains directory separator"
msgstr "잘못된 양식 %s에 디렉터리 구분자가 있습니다"

#: src/mktemp.c:291
#, c-format
msgid "invalid template, %s; with --tmpdir, it may not be absolute"
msgstr "잘못된 양식 %s. --tmpdir 옵션이 붙어있으며 절대경로여서는 안됩니다"

#: src/mktemp.c:312
#, c-format
msgid "failed to create directory via template %s"
msgstr "%s 양식으로 디렉터리 만들기 실패"

#: src/mktemp.c:323
#, c-format
msgid "failed to create file via template %s"
msgstr "%s 양식으로 파일 만들기 실패"

#: src/mv.c:247
msgid "Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\n"
msgstr ""
"<원본>을 <대상>으로 이름 바꾸거나 (다수) <원본>을 <디렉터리>로 이동합니다.\n"

#: src/mv.c:253
msgid ""
"      --backup[=CONTROL]       make a backup of each existing destination "
"file\n"
"  -b                           like --backup but does not accept an "
"argument\n"
"  -f, --force                  do not prompt before overwriting\n"
"  -i, --interactive            prompt before overwrite\n"
"  -n, --no-clobber             do not overwrite an existing file\n"
"If you specify more than one of -i, -f, -n, only the final one takes "
"effect.\n"
msgstr ""
"      --backup[=<제어>]       각 기존 대상 파일의 백업을 만듭니다\n"
"  -b                           --backup과 유사하나 인자를 받지 않습니다\n"
"  -f, --force                  덮어쓰기 전 물어보지 않습니다\n"
"  -i, --interactive            덮어쓰기 전 물어봅니다\n"
"  -n, --no-clobber             기존 파일을 덮어쓰지 않습니다\n"
"-i, -f, -n 중 하나 이상의 옵션을 설정했다면 마지막 옵션만 동작합니다.\n"

#: src/mv.c:262
msgid ""
"      --strip-trailing-slashes  remove any trailing slashes from each "
"SOURCE\n"
"                                 argument\n"
"  -S, --suffix=SUFFIX          override the usual backup suffix\n"
msgstr ""
"      --strip-trailing-slashes  각 <원본> 인자에서 슬래시 접미부를 제거합니"
"다\n"
"  -S, --suffix=<접미사>          일반적인 백업 접미사를 설정합니다\n"

#: src/mv.c:267
msgid ""
"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into "
"DIRECTORY\n"
"  -T, --no-target-directory    treat DEST as a normal file\n"
"  -u, --update                 move only when the SOURCE file is newer\n"
"                                 than the destination file or when the\n"
"                                 destination file is missing\n"
"  -v, --verbose                explain what is being done\n"
"  -Z, --context                set SELinux security context of destination\n"
"                                 file to default type\n"
msgstr ""
"  -t, --target-directory=<디렉터리>  모든 <원본>인자의 위치를 <디렉터리>로 옮"
"깁니다\n"
"  -T, --no-target-directory    <대상> 을 일반 파일로 취급합니다\n"
"  -u, --update                 <원본> 파일이 대상 파일보다 최신이거나\n"
"                                 대상 파일이 빠졌을 경우에만 이동합니다\n"
"  -v, --verbose                처리한 작업을 설명합니다\n"
"  -Z, --context                대상 파일의 SELinux 보안 컨텍스트를\n"
"                                 기본형으로 지정합니다\n"

#: src/nice.c:73
#, c-format
msgid "Usage: %s [OPTION] [COMMAND [ARG]...]\n"
msgstr "사용법: %s [<옵션>] [<명령>[<인자>]...]\n"

#: src/nice.c:74
#, c-format
msgid ""
"Run COMMAND with an adjusted niceness, which affects process scheduling.\n"
"With no COMMAND, print the current niceness.  Niceness values range from\n"
"%d (most favorable to the process) to %d (least favorable to the process).\n"
msgstr ""
"조정 nice 값으로 <명령>을 실행하며, 프로세스 스케쥴링에 영향을 줍니다.\n"
"<명령>을 지정하지 않으면 현재 nice 값을 출력합니다. nice 값 범위는 \n"
"%d(가장 관심있는 프로세스)부터 %d(관심이 덜한 프로세스)까지입니다.\n"

#: src/nice.c:83
msgid "  -n, --adjustment=N   add integer N to the niceness (default 10)\n"
msgstr ""
"  -n, --adjustment=<숫자>   정수 <숫자> 로 nice 값을 추가합니다(기본값: 10)\n"

#: src/nice.c:173
#, c-format
msgid "invalid adjustment %s"
msgstr "부적절한 인접 요소 %s"

#: src/nice.c:182
#, c-format
msgid "a command must be given with an adjustment"
msgstr "명령에 조정 값을 지정해야 합니다"

#: src/nice.c:189 src/nice.c:200
msgid "cannot get niceness"
msgstr "nice 우선순위 정보를 가져올 수 없습니다"

#: src/nice.c:206
#, c-format
msgid "cannot set niceness"
msgstr "nice 우선순위를 설정할 수 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/nl.c:41
msgid "Scott Bartram"
msgstr "Scott Bartram"

#: src/nl.c:183
msgid "Write each FILE to standard output, with line numbers added.\n"
msgstr "각 <파일>을 줄번호를 붙여서 표준 출력에 씁니다.\n"

#: src/nl.c:190
msgid ""
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for logical page delimiters\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
msgstr ""
"  -b, --body-numbering=<스타일>    본문에 번호를 붙일 때 <스타일>을 씁니다\n"
"  -d, --section-delimiter=<구분>   논리적 페이지를 구분할 때 <구분>을 씁니"
"다\n"
"  -f, --footer-numbering=<스타일>  아래단에 번호를 붙일 때 <스타일>을 씁니"
"다\n"

#: src/nl.c:195
msgid ""
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --line-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers for each "
"section\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
msgstr ""
"  -h, --header-numbering=<스타일>  상단에 번호를 붙이는 데 <스타일>을 씁니"
"다\n"
"  -i, --page-increment=<번호>      각 줄의 줄번호 증가치\n"
"  -l, --join-blank-lines=<번호>    <번호>개의 빈 줄은 하나로 취급됩니다.\n"
"  -n, --number-format=<형식>       <형식>에 따라 줄 번호를 씁니다\n"
"  -p, --no-renumber                페이지가 넘어가도 줄번호를 리셋하지 않습니"
"다\n"
"  -s, --number-separator=<문자열>  (가능하면) 줄 번호 다음에 <문자열>을 추가"
"합니다\n"

#: src/nl.c:203
msgid ""
"  -v, --starting-line-number=NUMBER  first line number for each section\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
msgstr ""
"  -v, --starting-line-number=<개수>  각 섹션의 첫번째 행 번호\n"
"  -w, --number-width=<개수>          행 번호를 <개수>열에 씁니다\n"

#: src/nl.c:209
msgid ""
"\n"
"Default options are: -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6\n"
"\n"
"CC are two delimiter characters used to construct logical page delimiters;\n"
"a missing second character implies ':'.  As a GNU extension one can specify\n"
"more than two characters, and also specifying the empty string (-d '')\n"
"disables section matching.\n"
msgstr ""
"\n"
"기본 옵션은, -bt -d'\\:' -fn -hn -i1 -l1 -n'rn' -s<TAB> -v1 -w6 입니다.\n"
"\n"
"<CC>는 페이지를 논리 개념으로 구분하는 데 쓰이는 두 개의 문자입니다.\n"
"두 번째 문자가 없다면 `:'을 사용합니다. GNU 확장 옵션으로 두 문자 이상\n"
"지정할 수 있으며, 섹션 일치 기능을 사용하지 않으려면 빈 문자열 (-d '')을\n"
"사용합니다.\n"

#: src/nl.c:218
msgid ""
"\n"
"STYLE is one of:\n"
"\n"
"  a      number all lines\n"
"  t      number only nonempty lines\n"
"  n      number no lines\n"
"  pBRE   number only lines that contain a match for the basic regular\n"
"         expression, BRE\n"
msgstr ""
"\n"
"<스타일>은 다음 중 하나입니다:\n"
"\n"
"  a          모든 줄에 번호를 붙입니다.\n"
"  t          빈 줄이 아닌 경우에만 번호를 붙입니다\n"
"  n          번호를 붙이지 않습니다\n"
"  p<정규식>  기본 <정규식>에 맞는 줄만 번호를 붙입니다\n"

#: src/nl.c:228
msgid ""
"\n"
"FORMAT is one of:\n"
"\n"
"  ln     left justified, no leading zeros\n"
"  rn     right justified, no leading zeros\n"
"  rz     right justified, leading zeros\n"
"\n"
msgstr ""
"\n"
"<형식>은 다음중 하나입니다:\n"
"\n"
"  ln     왼쪽 정렬, 앞에 0을 붙이지 않습니다\n"
"  rn     오른쪽 정렬, 앞에 0을 붙이지 않습니다\n"
"  rz     오른쪽 정렬, 앞에 0을 붙입니다\n"
"\n"

#: src/nl.c:284
msgid "line number overflow"
msgstr "행 번호 넘침"

#: src/nl.c:500
#, c-format
msgid "invalid header numbering style: %s"
msgstr "부적절한 페이지 상단 번호 부여 방식: %s"

#: src/nl.c:508
#, c-format
msgid "invalid body numbering style: %s"
msgstr "부적절한 본문 번호 부여 방식: %s"

#: src/nl.c:516
#, c-format
msgid "invalid footer numbering style: %s"
msgstr "부적절한 페이지 하단 번호 부여 방식: %s"

#: src/nl.c:523
msgid "invalid starting line number"
msgstr "부적절한 행 번호 시작"

#: src/nl.c:528
msgid "invalid line number increment"
msgstr "부적절한 행 번호 증가"

#: src/nl.c:535
msgid "invalid line number of blank lines"
msgstr "부적절한 빈 행의 행 번호"

#: src/nl.c:542
msgid "invalid line number field width"
msgstr "부적절한 행 번호 필드 폭"

#: src/nl.c:553
#, c-format
msgid "invalid line numbering format: %s"
msgstr "부적절한 행 번호 형식: %s"

#: src/nohup.c:50
#, c-format
msgid ""
"Usage: %s COMMAND [ARG]...\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s <명령> [<인자>]...\n"
"  또는: %s <옵션>\n"

#: src/nohup.c:56
msgid ""
"Run COMMAND, ignoring hangup signals.\n"
"\n"
msgstr "끊어짐 시그널을 무시하는 <명령>을 실행합니다.\n"

#: src/nohup.c:62
#, c-format
msgid ""
"\n"
"If standard input is a terminal, redirect it from an unreadable file.\n"
"If standard output is a terminal, append output to 'nohup.out' if possible,\n"
"'$HOME/nohup.out' otherwise.\n"
"If standard error is a terminal, redirect it to standard output.\n"
"To save output to FILE, use '%s COMMAND > FILE'.\n"
msgstr ""
"\n"
"표준 입력이 터미널이라면 읽을 수 없는 파일에서 전달합니다.\n"
"표준 출력이 터미널이라면 가능할 경우 'nohup.out' 파일에 \n"
"출력 내용을 붙이고, 아니면 '$HOME/nohup.out' 파일에 붙여넣습니다.\n"
"표준 오류가 터민러이라면 표준 출력으로 전달합니다.\n"
"<파일>로 출력을 저장하려면 '%s <명령> > <파일>' 명령을 활용하십시오.\n"

#: src/nohup.c:123
#, c-format
msgid "failed to render standard input unusable"
msgstr "사용할 수 없는 표준 입력 렌더링 실패"

#: src/nohup.c:125
#, c-format
msgid "ignoring input"
msgstr "입력 무시"

#: src/nohup.c:169
#, c-format
msgid "ignoring input and appending output to %s"
msgstr "입력을 무시하고 %s(으)로 출력을 추가합니다"

#: src/nohup.c:170
#, c-format
msgid "appending output to %s"
msgstr "%s에 출력 추가"

#: src/nohup.c:188
#, c-format
msgid "ignoring input and redirecting stderr to stdout"
msgstr "입력을 무시하고 표준 오류를 표준 출력으로 되돌립니다"

#: src/nohup.c:189
#, c-format
msgid "redirecting stderr to stdout"
msgstr "표준 오류를 표준 출력으로 되돌림"

#: src/nohup.c:193
#, c-format
msgid "failed to redirect standard error"
msgstr "표준 출력 되돌림 실패"

#. This is a proper name. See the gettext manual, section Names.
#: src/nproc.c:33 src/sync.c:34
msgid "Giuseppe Scrivano"
msgstr "Giuseppe Scrivano"

#: src/nproc.c:57 src/pwd.c:57 src/tty.c:65 src/uname.c:116 src/whoami.c:44
#, c-format
msgid "Usage: %s [OPTION]...\n"
msgstr "사용법: %s [<옵션>]...\n"

#: src/nproc.c:58
msgid ""
"Print the number of processing units available to the current process,\n"
"which may be less than the number of online processors\n"
"\n"
msgstr ""
"현재 프로세스에 가용 처리 장치 수를 출력합니다.\n"
"실제 가동중인 프로세서의 수보다 작을 수 있습니다\n"
"\n"

#: src/nproc.c:63
msgid ""
"      --all      print the number of installed processors\n"
"      --ignore=N  if possible, exclude N processing units\n"
msgstr ""
"      --all      장착 프로세서 수를 출력합니다\n"
"      --ignore=<숫자>  가능하다면 <숫자> 만큼의 CPU는 제외합니다\n"

#: src/numfmt.c:694
#, c-format
msgid "value too large to be converted: %s"
msgstr "변환할 값이 너무 큽니다: %s"

#: src/numfmt.c:698
#, c-format
msgid "invalid number: %s"
msgstr "부적절한 숫자: %s"

#: src/numfmt.c:702
#, c-format
msgid "rejecting suffix in input: %s (consider using --from)"
msgstr "입력 접미사 거절: %s (--from 옵션을 사용해보십시오)"

#: src/numfmt.c:706
#, c-format
msgid "invalid suffix in input: %s"
msgstr "입력에 부적절한 접미사: %s"

#: src/numfmt.c:710
#, c-format
msgid "missing 'i' suffix in input: %s (e.g Ki/Mi/Gi)"
msgstr "입력에 'i' 접미사 빠짐: %s (예: Ki/Mi/Gi)"

#: src/numfmt.c:757 src/numfmt.c:809
#, c-format
msgid "failed to prepare value '%Lf' for printing"
msgstr "인쇄용 '%Lf' 값 지정 실패"

#: src/numfmt.c:858
#, c-format
msgid "invalid unit size: %s"
msgstr "부적절한 단위 크기: %s"

#: src/numfmt.c:884
#, c-format
msgid "Usage: %s [OPTION]... [NUMBER]...\n"
msgstr "사용법: %s [<옵션>]... [<번호>]...\n"

#: src/numfmt.c:887
msgid ""
"Reformat NUMBER(s), or the numbers from standard input if none are "
"specified.\n"
msgstr ""
"<숫자>를 재구성 하거나, 아무것도 지정하지 않았다면 표준 입력의 숫자를 재구성"
"합니다.\n"

#: src/numfmt.c:891
msgid "      --debug          print warnings about invalid input\n"
msgstr "      --debug          부적절한 입력에 경고를 출력합니다\n"

#: src/numfmt.c:894
msgid ""
"  -d, --delimiter=X    use X instead of whitespace for field delimiter\n"
msgstr ""
"  -d, --delimiter=<X>  공백 문자 또는 필드 구분자 대신 <X> 를 사용합니다\n"

#: src/numfmt.c:897
msgid ""
"      --field=FIELDS   replace the numbers in these input fields "
"(default=1);\n"
"                         see FIELDS below\n"
msgstr ""
"      --field=<필드>   이 입력 필드의 숫자를 바꿉니다 (기본값=1).\n"
"                         하단 <필드> 참조\n"

#: src/numfmt.c:901
msgid ""
"      --format=FORMAT  use printf style floating-point FORMAT;\n"
"                         see FORMAT below for details\n"
msgstr ""
"      --format=<형식>  printf 방식 소숫점 표기 <표기> 형식을 활용합니다.\n"
"                         자세한 내용은 하단 <형식> 참조\n"

#: src/numfmt.c:905
msgid ""
"      --from=UNIT      auto-scale input numbers to UNITs; default is "
"'none';\n"
"                         see UNIT below\n"
msgstr ""
"      --from=<단위>    입력 숫자를 <단위>에 자동으로 맞춥니다. \n"
"                         기본값은 'none'입니다. 하단 <단위> 참조\n"

#: src/numfmt.c:909
msgid ""
"      --from-unit=N    specify the input unit size (instead of the default "
"1)\n"
msgstr ""
"      --from-unit=<숫자>    (기본값 1 대신) 입력 단위 크기를 지정합니다\n"

#: src/numfmt.c:912
msgid ""
"      --grouping       use locale-defined grouping of digits, e.g. "
"1,000,000\n"
"                         (which means it has no effect in the C/POSIX "
"locale)\n"
msgstr ""
"      --grouping       로캘에서 지정한 대로 자릿수 구분을 표시합니다. 예: "
"1,000,000\n"
"                         (C/POSIX 로캘에서는 동작하지 않음)\n"

#: src/numfmt.c:916
msgid ""
"      --header[=N]     print (without converting) the first N header lines;\n"
"                         N defaults to 1 if not specified\n"
msgstr ""
"      --header[=<숫자>]  처음 <숫자> 앞부분 줄을 (변환없이) 출력합니다.\n"
"                           지정하지 않았을 때 <숫자> 기본값은 1입니다\n"

#: src/numfmt.c:920
msgid ""
"      --invalid=MODE   failure mode for invalid numbers: MODE can be:\n"
"                         abort (default), fail, warn, ignore\n"
msgstr ""
"      --invalid=<모드>  잘못된 숫자에 대한 실패 처리 모드입니다. <모드>는\n"
"                          abort (기본), fail, warn, ignore 중 한가지 값일 수 "
"있습니다\n"

#: src/numfmt.c:924
msgid ""
"      --padding=N      pad the output to N characters; positive N will\n"
"                         right-align; negative N will left-align;\n"
"                         padding is ignored if the output is wider than N;\n"
"                         the default is to automatically pad if a "
"whitespace\n"
"                         is found\n"
msgstr ""
"      --padding=<숫자>  <숫자> 개의 문자로 출력 자릿수를 맞춥니다.; positive "
"N will\n"
"                          양의 <숫자> 값은 좌측 정렬, 음의 <숫자> 값은\n"
"                          우측 정렬입니다. <숫자> 값보다 출력이 길면 무시합니"
"다.\n"
"                          기본 동작은 공백을 발견하면 알아서 자릿수를 맞추"
"는\n"
"                          방식입니다\n"

#: src/numfmt.c:931
msgid ""
"      --round=METHOD   use METHOD for rounding when scaling; METHOD can be:\n"
"                         up, down, from-zero (default), towards-zero, "
"nearest\n"
msgstr ""
"      --round=<방식>   단위 조절시 반올림 <방식>을 사용합니다. 반올림 <방식>"
"은\n"
"                         up, down, from-zero (기본값), towards-zero, nearest"
"와 같습니다\n"

#: src/numfmt.c:935
msgid ""
"      --suffix=SUFFIX  add SUFFIX to output numbers, and accept optional\n"
"                         SUFFIX in input numbers\n"
msgstr ""
"      --suffix=<접미사>  숫자 출력 <접미사>를 추가하고, 입력 숫자에 추가\n"
"                           <접미사>를 허용합니다\n"

#: src/numfmt.c:939
msgid ""
"      --to=UNIT        auto-scale output numbers to UNITs; see UNIT below\n"
msgstr ""
"      --to=<단위>      <단위>에 맞춰 숫자 자동 단위 조절 출력합니다. 하단 <단"
"위> 참조\n"

#: src/numfmt.c:942
msgid ""
"      --to-unit=N      the output unit size (instead of the default 1)\n"
msgstr "      --to-unit=<숫자>  출력 단위 크기 (기본값 1 대신)\n"

#: src/numfmt.c:951
msgid ""
"\n"
"UNIT options:\n"
msgstr ""
"\n"
"<단위> 옵션:\n"

#: src/numfmt.c:954
msgid "  none       no auto-scaling is done; suffixes will trigger an error\n"
msgstr ""
"  none       자동 단위 조절을 안함. 접미사를 붙이면 오류가 나타납니다\n"

#: src/numfmt.c:957
msgid ""
"  auto       accept optional single/two letter suffix:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"
msgstr ""
"  auto       추가 단일/이중 문자 접미사를 허용합니다:\n"
"               1K = 1000,\n"
"               1Ki = 1024,\n"
"               1M = 1000000,\n"
"               1Mi = 1048576,\n"

#: src/numfmt.c:963
msgid ""
"  si         accept optional single letter suffix:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"
msgstr ""
"  si         추가 단일 문자 접미사를 허용합니다:\n"
"               1K = 1000,\n"
"               1M = 1000000,\n"
"               ...\n"

#: src/numfmt.c:968
msgid ""
"  iec        accept optional single letter suffix:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"
msgstr ""
"  iec        추가 단일 문자 접미사를 허용합니다:\n"
"               1K = 1024,\n"
"               1M = 1048576,\n"
"               ...\n"

#: src/numfmt.c:973
msgid ""
"  iec-i      accept optional two-letter suffix:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"
msgstr ""
"  iec-i      추가 이중 문자 접미사를 허용합니다:\n"
"               1Ki = 1024,\n"
"               1Mi = 1048576,\n"
"               ...\n"

#: src/numfmt.c:979
msgid ""
"\n"
"FIELDS supports cut(1) style field ranges:\n"
"  N    N'th field, counted from 1\n"
"  N-   from N'th field, to end of line\n"
"  N-M  from N'th to M'th field (inclusive)\n"
"  -M   from first to M'th field (inclusive)\n"
"  -    all fields\n"
"Multiple fields/ranges can be separated with commas\n"
msgstr ""
"\n"
"<필드> 는 cut(1) 방식 빌드 범위를 지원합니다:\n"
"  <숫자1>    1부터 시작하는 <숫자1>번째 필드, \n"
"  <숫자1>-   <숫자1>번째 필드부터 마지막 행까지\n"
"  <숫자1>-<숫자2>  <숫자1>번째 필드부터<숫자2>번째 필드까지 (범위포함)\n"
"  -<숫자2>   처음부터 <숫자2>번째 필드까지 (범위포함)\n"
"  -    모든 필드\n"
"다중 필드/범위는 쉼표로 구분할 수 있습니다\n"

#: src/numfmt.c:989
#, c-format
msgid ""
"\n"
"FORMAT must be suitable for printing one floating-point argument '%f'.\n"
"Optional quote (%'f) will enable --grouping (if supported by current "
"locale).\n"
"Optional width value (%10f) will pad output. Optional zero (%010f) width\n"
"will zero pad the number. Optional negative values (%-10f) will left align.\n"
"Optional precision (%.1f) will override the input determined precision.\n"
msgstr ""
"\n"
"<형식>은 소숫점 인자 '%f' 하나 출력에 맞춰야 합니다. 추가 따옴표 표시(%'f)\n"
"는 (현재 로캘에서 지원하는 경우) --grouping 옵션을 쓸 수 있습니다.\n"
"추가 너비 값(%10f)은 출력 자릿수를 맞춥니다. 추가 0(%010f)너비 표시는\n"
"자릿수 맞춤에 숫자 0을 사용합니다. 추가 음 부호 표시(%-10f)는 왼쪽 정렬을\n"
"수행합니다. 추가 정밀도 표시(%.1f)는 입력때 결정한 정밀도를 덮어씁니다.\n"

#: src/numfmt.c:997
#, c-format
msgid ""
"\n"
"Exit status is 0 if all input numbers were successfully converted.\n"
"By default, %s will stop at the first conversion error with exit status 2.\n"
"With --invalid='fail' a warning is printed for each conversion error\n"
"and the exit status is 2.  With --invalid='warn' each conversion error is\n"
"diagnosed, but the exit status is 0.  With --invalid='ignore' conversion\n"
"errors are not diagnosed and the exit status is 0.\n"
msgstr ""
"\n"
"모든 입력 숫자를 제대로 변환하면 종료 상태 값은 0 입니다. 기본적으로\n"
"%s은(는) 변환 오류 발생시 멈추고 2번 값을 반환합니다. --invalid='fail'\n"
"옵션을 주면 각 변환 오류 경고를 출력하고 종료 상태값 2번을 반환합니다. \n"
"--invalid='warn' 옵션을 주면 각 변환 오류를 진단하지만 종료 상태값 \n"
"0번을 반환합니다.  --invalid='ignore' 옵션을 주면 변환 오류를 진단하지\n"
"않고 종료 상태값 0번을 반환합니다.\n"

#: src/numfmt.c:1006
#, c-format
msgid ""
"\n"
"Examples:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"
msgstr ""
"\n"
"예제:\n"
"  $ %s --to=si 1000\n"
"            -> \"1.0K\"\n"
"  $ %s --to=iec 2048\n"
"           -> \"2.0K\"\n"
"  $ %s --to=iec-i 4096\n"
"           -> \"4.0Ki\"\n"
"  $ echo 1K | %s --from=si\n"
"           -> \"1000\"\n"
"  $ echo 1K | %s --from=iec\n"
"           -> \"1024\"\n"
"  $ df -B1 | %s --header --field 2-4 --to=si\n"
"  $ ls -l  | %s --header --field 5 --to=iec\n"
"  $ ls -lh | %s --header --field 5 --from=iec --padding=10\n"
"  $ ls -lh | %s --header --field 5 --from=iec --format %%10f\n"

#: src/numfmt.c:1059 src/seq.c:248
#, c-format
msgid "format %s has no %% directive"
msgstr "%s 형식에 %% 지시자가 없습니다"

#: src/numfmt.c:1086
#, c-format
msgid "invalid format %s (width overflow)"
msgstr "부적절한 %s 형식(폭 넘침)"

#: src/numfmt.c:1091
#, c-format
msgid "--format padding overriding --padding"
msgstr "--format 옵션은 --padding 옵션의 패딩 설정 값을 덮어씁니다"

#: src/numfmt.c:1110 src/seq.c:265
#, c-format
msgid "format %s ends in %%"
msgstr "%s 형식이 %% 기호로 끝납니다"

#: src/numfmt.c:1126
#, c-format
msgid "invalid precision in format %s"
msgstr "%s 형식에 부적절한 정밀도"

#: src/numfmt.c:1132
#, c-format
msgid "invalid format %s, directive must be %%[0]['][-][N][.][N]f"
msgstr "부적절한 %s 형식. 지시자는 %%[0]['][-][N][.][N]f 여야합니다"

#: src/numfmt.c:1140 src/seq.c:272
#, c-format
msgid "format %s has too many %% directives"
msgstr "%s 형식에 %% 지시자가 너무 많습니다"

#: src/numfmt.c:1183
#, c-format
msgid "invalid suffix in input %s: %s"
msgstr "%s 입력에 부적절한 접미사: %s"

#: src/numfmt.c:1212
#, c-format
msgid ""
"value/precision too large to be printed: '%Lg/%<PRIuMAX>' (consider using --"
"to)"
msgstr ""
"출력하기에 너무 큰 값/정밀도: '%Lg/%<PRIuMAX>' (--to 옵션을 사용해보십시오)"

#: src/numfmt.c:1216
#, c-format
msgid "value too large to be printed: '%Lg' (consider using --to)"
msgstr "출력하기에 너무 큰 값: '%Lg' (--to 옵션을 사용해보십시오)"

#: src/numfmt.c:1225
#, c-format
msgid "value too large to be printed: '%Lg' (cannot handle values > 999Y)"
msgstr "출력하기에 너무 큰 값: '%Lg' (999Y 초과 값은 처리할 수 없음)"

#: src/numfmt.c:1311
#, c-format
msgid "large input value %s: possible precision loss"
msgstr "큰 입력값 %s: 정밀 값을 잃을 수 있습니다"

#: src/numfmt.c:1501
#, c-format
msgid "invalid padding value %s"
msgstr "부적절한 패딩 값 %s"

#: src/numfmt.c:1514
msgid "multiple field specifications"
msgstr "다중 필드 지정"

#: src/numfmt.c:1548
#, c-format
msgid "invalid header value %s"
msgstr "부적절한 %s 헤더 값"

#: src/numfmt.c:1575
msgid "--grouping cannot be combined with --format"
msgstr "--grouping 옵션은 --format 옵션과 혼용할 수 없습니다"

#: src/numfmt.c:1578 src/sort.c:4769
#, c-format
msgid "failed to set locale"
msgstr "로캘 지정 실패"

#: src/numfmt.c:1583
#, c-format
msgid "no conversion option specified"
msgstr "변환 옵션을 지정하지 않았습니다"

#: src/numfmt.c:1591
msgid "grouping cannot be combined with --to"
msgstr "--grouping 옵션은 --to 옵션과 혼용할 수 없습니다"

#: src/numfmt.c:1593
#, c-format
msgid "grouping has no effect in this locale"
msgstr "이 로캘에서 자릿수 구분 표시는 의미가 없습니다"

#: src/numfmt.c:1606
#, c-format
msgid "--header ignored with command-line input"
msgstr "명령행 입력에 --header 옵션을 무시합니다"

#: src/numfmt.c:1631
#, c-format
msgid "error reading input"
msgstr "입력 읽기 오류"

#: src/numfmt.c:1635
#, c-format
msgid "failed to convert some of the input numbers"
msgstr "일부 입력 숫자 변환에 실패했습니다"

#: src/od.c:323
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\n"
"  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.]"
"[b]]\n"
msgstr ""
"사용법: %s [<옵션>]... [<파일>]...\n"
"  또는: %s [-abcdfilosx]... [<파일>] [[+]<오프셋>[.][b]]\n"
"  또는: %s --traditional [<옵션>]... [<파일>] [[+]<오프셋>[.][b] [+][<레이블"
">][.][b]]\n"
"\n"

#: src/od.c:329
msgid ""
"\n"
"Write an unambiguous representation, octal bytes by default,\n"
"of FILE to standard output.  With more than one FILE argument,\n"
"concatenate them in the listed order to form the input.\n"
msgstr ""
"\n"
"모호하지 않은 표현으로 기록합니다. 8진수 바이트가 기본이며,\n"
"<파일>로 기본 출력을 수행합니다.  <파일> 인자 하나 이상을 지정하면,\n"
"입력을 구성하여 나열한 파일을 합칩니다.\n"

# 8진수 suffix에 대해서 좀 이상하다
#: src/od.c:337
msgid ""
"\n"
"If first and second call formats both apply, the second format is assumed\n"
"if the last operand begins with + or (if there are 2 operands) a digit.\n"
"An OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\n"
"at first byte printed, incremented when dump is progressing.\n"
"For OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\n"
"suffixes may be . for octal and b for multiply by 512.\n"
msgstr ""
"\n"
"처음, 두번째 형식 포맷을 둘 다 적용한다면, 두번재 형식의 경우 \n"
"마지막 피연산자가 + 또는 숫자로 시작한다고 가정(피연산자가 \n"
"둘 있을 경우)합니다. <오프셋> 피연산자는 -j <오프셋>을 의미\n"
"합니다.  <레이블>의 경우 첫 바이트 출력시 가상 주소를 의미하며,\n"
"덤프를 처리할 떄 증가합니다. <오프셋>과 <레이블>에 대해 0x 또는\n"
"0X 접두사는 16진수를 의미하며, .(점)으로 끝날 접미사는 8진수를, \n"
"b로 끝나는 접미사는 512 배수를 의미합니다.\n"

#: src/od.c:349
msgid ""
"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\n"
"                                of [doxn], for Decimal, Octal, Hex or None\n"
"      --endian={big|little}   swap input bytes according the specified "
"order\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first\n"
msgstr ""
"  -A, --address-radix=<기수>  파일 오프셋의 출력 형식입니다. <기수>는\n"
"                                10진, 8진, 16진, 없음을 나타내는 [doxn]중 하"
"나입니다\n"
"      --endian={big|little}   지정 순서를 따라 입력 바이트를 전환합니다\n"
"  -j, --skip-bytes=<바이트>   처음 <바이트> 입력 바이트는 건너뜁니다\n"

#: src/od.c:355
msgid ""
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\n"
"  -S BYTES, --strings[=BYTES]  output strings of at least BYTES graphic "
"chars;\n"
"                                3 is implied when BYTES is not specified\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\n"
"                                32 is implied when BYTES is not specified\n"
"      --traditional           accept arguments in third form above\n"
msgstr ""
"  -N, --read-bytes=<바이트>   <바이트> 입력 만큼 덤프를 제한합니다\n"
"  -S <바이트>, --strings[=<바이트>]    최소 <바이트> 그래픽 문자의 문자열을 "
"출력합니다\n"
"                                <바이트> 값을 지정하지 않으면 기본값 3을 적용"
"합니다\n"
"  -t, --format=<형식>         출력 형식을 지정합니다\n"
"  -v, --output-duplicates     숨김 행에는 * 를 표시하지 않습니다\n"
"  -w[<바이트>], --width[=<바이트>]  출력의 한 줄에 <바이트> 바이트를 출력합니"
"다\n"
"                              <바이트> 값을 지정하지 않으면 기본값 32를 적용"
"합니다\n"
"      --traditional           고전적인 형식으로 인자를 받습니다\n"

#: src/od.c:368
msgid ""
"\n"
"\n"
"Traditional format specifications may be intermixed; they accumulate:\n"
"  -a   same as -t a,  select named characters, ignoring high-order bit\n"
"  -b   same as -t o1, select octal bytes\n"
"  -c   same as -t c,  select printable characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal 2-byte units\n"
msgstr ""
"\n"
"\n"
"고전적인 형식 지정자를 섞어서 쓸 수도 있습니다. 다음과 같습니다:\n"
"  -a   `-t a'와 동일하며, 문자 이름으로 지정합니다\n"
"  -b   `-t oC'와 동일하며, 8진수 바이트로 지정합니다\n"
"  -c   `-t c'와 동일하며, 출력 가능 문자 또는 역슬래시 이스케이프로 지정합니"
"다\n"
"  -d   `-t u2'와 동일하며, 10진수 2바이트 단위로 지정합니다\n"

#: src/od.c:377
msgid ""
"  -f   same as -t fF, select floats\n"
"  -i   same as -t dI, select decimal ints\n"
"  -l   same as -t dL, select decimal longs\n"
"  -o   same as -t o2, select octal 2-byte units\n"
"  -s   same as -t d2, select decimal 2-byte units\n"
"  -x   same as -t x2, select hexadecimal 2-byte units\n"
msgstr ""
"  -f   -t fF와 동일하며, 실수를 선택합니다\n"
"  -i   -t d2와 동일하며, 10진수 int를 선택합니다\n"
"  -l   -t d4와 동일하며, 10진수 long을 선택합니다\n"
"  -o   -t o2와 동일하며, 8진수  2바이트 단위를 선택합니다\n"
"  -s   -t d2와 동일하며, 10진수 2바이트 단위를 선택합니다\n"
"  -x   -t x2와 동일하며, 16진수 2바이트 단위를 선택합니다\n"

#: src/od.c:385
msgid ""
"\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"  a          named character, ignoring high-order bit\n"
"  c          printable character or backslash escape\n"
msgstr ""
"\n"
"\n"
"<형식>은 아래 지정값 중 하나 이상입니다:\n"
"  a          이름 붙은 문자, 상위 비트 무시\n"
"  c          출력 가능 문자 또는 역슬래시 이스케이프\n"

#: src/od.c:392
msgid ""
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per float\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
msgstr ""
"  d[<크기>]  부호있는 10진수, 각 정수별 <크기> 바이트\n"
"  f[<크기>]  부동 소수점, 각 실수별 <크기> 바이트\n"
"  o[<크기>]  8진수, 각 정수별 <크기> 바이트\n"
"  u[<크기>]  부호없는 10진수, 각 정수별 <크기> 바이트\n"
"  x[<크기>]  16진수, 각 정수별 <크기> 바이트\n"

#: src/od.c:399
msgid ""
"\n"
"SIZE is a number.  For TYPE in [doux], SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
msgstr ""
"\n"
"<크기>는 숫자입니다.  [doux]에서 <형식>의 경우, <크기>는 \n"
"sizeof(char)의 C, sizeof(short)의 S, sizeof(int)의 I, sizeof(long)\n"
"의 L로 쓸 수 있습니다. <형식>이 f이면, <크기>는 sizeof(float)의\n"
" F, sizeof(double)의 D, sizeof(long double)의 L이 됩니다.\n"

#: src/od.c:406
msgid ""
"\n"
"Adding a z suffix to any type displays printable characters at the end of\n"
"each output line.\n"
msgstr ""
"\n"
"표시 가능한 문자를 나타내는 어떤 형식으로든 각 출력 행 끝으로 z 접미사를 \n"
"추가합니다.\n"

#: src/od.c:411
msgid ""
"\n"
"\n"
"BYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"\n"
"<바이트> 는 0x 또는 0X 접두사가 붙은 16진수 값이며, 배수 접미사를 붙일 수 있"
"습니다:\n"
"  b    512\n"
"  KB   1000\n"
"  K    1024\n"
"  MB   1000*1000\n"
"  M    1024*1024\n"
"그리고 T, P, E, Z, Y에도 마찬가지입니다.\n"
"이진 접미사의 경우 마찬가지입니다. KiB=K, MiB=M, 등과 같습니다.\n"
"\n"

#: src/od.c:686 src/od.c:806
#, c-format
msgid "invalid type string %s"
msgstr "부적절한 형식의 문자열 %s"

#: src/od.c:696
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"부적절한 형식의 문자열 %s\n"
"이 시스템은 %lu 바이트 정수형을 지원하지 않습니다"

#: src/od.c:817
#, c-format
msgid ""
"invalid type string %s;\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"부적절한 형식의 문자열 %s\n"
"이 시스템은 %lu 바이트 부동소수점형식을 지원하지 않습니다"

#: src/od.c:875
#, c-format
msgid "invalid character '%c' in type string %s"
msgstr "%2$s 형식 문자열에 부적절한 문자 '%1$c'"

# combined input 번역 개선
#: src/od.c:1110
msgid "cannot skip past end of combined input"
msgstr "결합 입력의 끝을 넘어갈 수는 없습니다"

#: src/od.c:1661
#, c-format
msgid "invalid output address radix '%c'; it must be one character from [doxn]"
msgstr "부적절한 출력 주소 기수 '%c' [doxn] 문자 중 하나여야 합니다"

#: src/od.c:1698 src/od.c:1779
#, c-format
msgid "%s is too large"
msgstr "%s은(는) 너무 큽니다"

#: src/od.c:1799
msgid "no type may be specified when dumping strings"
msgstr "문자열을 덤프할 때에는 타입이 지정되면 안됩니다"

#: src/od.c:1874
msgid "compatibility mode supports at most one file"
msgstr "호환 모드에서는 최대 파일 하나만 지원합니다"

#: src/od.c:1895
msgid "skip-bytes + read-bytes is too large"
msgstr "skip-bytes + read-bytes 값이 너무 큽니다"

#: src/od.c:1938
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "경고: 부적절한 폭 %lu; 대신 %d을(를) 사용함"

#: src/paste.c:221
msgid "standard input is closed"
msgstr "표준 입력이 닫혔음"

#: src/paste.c:437
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
msgstr ""
"각 <파일>에서 순서대로 해당하는 행을 <탭>으로 구분하여 표준 출력에 기록합니"
"다.\n"
"\n"

#: src/paste.c:445
msgid ""
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
msgstr ""
"  -d, --delimiters=<목록>  <탭> 대신에 <목록> 안에 있는 문자를 사용합니다\n"
"  -s, --serial            동시에 하지 않고 한 번에 한 개의 파일을 붙입니다\n"

#: src/paste.c:515
#, c-format
msgid "delimiter list ends with an unescaped backslash: %s"
msgstr "구분자 목록이 이스케이핑 처리하지 않은 역슬래시로 끝납니다: %s"

#: src/pathchk.c:89
msgid ""
"Diagnose invalid or unportable file names.\n"
"\n"
"  -p                  check for most POSIX systems\n"
"  -P                  check for empty names and leading \"-\"\n"
"      --portability   check for all POSIX systems (equivalent to -p -P)\n"
msgstr ""
"부적절하거나 호환성이 떨어지는 파일 이름 여부를 진단합니다.\n"
"\n"
"  -p                  대부분의 POSIX 시스템 대상 검사\n"
"  -P                  빈 이름 또는 \"-\" 접두사 검사\n"
"      --portability   모든 POSIX 시스템 대상 검사 (-p -P 옵션과 동일)\n"

#: src/pathchk.c:169
#, c-format
msgid "leading '-' in a component of file name %s"
msgstr "%s 파일 이름 앞에 '-' 기호가 있습니다"

#: src/pathchk.c:195
#, c-format
msgid "nonportable character %s in file name %s"
msgstr "%2$s 파일 이름에 이식 불가능한 %1$s 문자"

#: src/pathchk.c:273
#, c-format
msgid "empty file name"
msgstr "빈 파일 이름"

#: src/pathchk.c:315
#, c-format
msgid "%s: unable to determine maximum file name length"
msgstr "%s: 최대 파일 이름 길이를 판단할 수 없습니다"

#: src/pathchk.c:326
#, c-format
msgid "limit %lu exceeded by length %lu of file name %s"
msgstr "%3$s 파일 이름의 %2$lu 길이가 %1$lu 제한을 초과했습니다"

#: src/pathchk.c:412
#, c-format
msgid "limit %lu exceeded by length %lu of file name component %s"
msgstr "%3$s 파일 이름 요소의 %2$lu 길이가 %1$lu 제한을 초과했습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:37 src/uptime.c:45 src/users.c:35 src/who.c:50
msgid "Joseph Arceneaux"
msgstr "Joseph Arceneaux"

#. This is a proper name. See the gettext manual, section Names.
#: src/pinky.c:39 src/uptime.c:47
msgid "Kaveh Ghazi"
msgstr "Kaveh Ghazi"

#. TRANSLATORS: Real name is unknown; at most 19 characters.
#: src/pinky.c:242
msgid "        ???"
msgstr "        ???"

#. TRANSLATORS: Idle time is unknown; at most 5 characters.
#: src/pinky.c:266
msgid "?????"
msgstr "?????"

#: src/pinky.c:314
#, c-format
msgid "Login name: "
msgstr "로그인 이름: "

#: src/pinky.c:317
#, c-format
msgid "In real life: "
msgstr "실제: "

#. TRANSLATORS: Real name is unknown; no hard limit.
#: src/pinky.c:321
msgid "???\n"
msgstr "???\n"

#: src/pinky.c:341
#, c-format
msgid "Directory: "
msgstr "디렉터리: "

#: src/pinky.c:343
#, c-format
msgid "Shell: "
msgstr "셸: "

#: src/pinky.c:362
#, c-format
msgid "Project: "
msgstr "프로젝트: "

#: src/pinky.c:386
#, c-format
msgid "Plan:\n"
msgstr "계획:\n"

#: src/pinky.c:405
msgid "Login"
msgstr "로그인"

#: src/pinky.c:407
msgid "Name"
msgstr "이름"

#: src/pinky.c:408
msgid " TTY"
msgstr " TTY"

#: src/pinky.c:410
msgid "Idle"
msgstr "대기"

#: src/pinky.c:411
msgid "When"
msgstr "시각"

#: src/pinky.c:414
msgid "Where"
msgstr "위치"

#: src/pinky.c:490
msgid ""
"\n"
"  -l              produce long format output for the specified USERs\n"
"  -b              omit the user's home directory and shell in long format\n"
"  -h              omit the user's project file in long format\n"
"  -p              omit the user's plan file in long format\n"
"  -s              do short format output, this is the default\n"
msgstr ""
"\n"
"  -l              지정 <사용자>에 대해 긴 형식 출력을 만듭니다\n"
"  -b              긴 형식에서 사용자 디렉터리와 셸을 생략합니다\n"
"  -h              긴 형식에서 하용자 프로젝트 파일을 생략합니다\n"
"  -p              긴 형식에서 사용자 계획 파일을 생략합니다\n"
"  -s              출력 형식을 줄입니다. 기본 동작\n"

#: src/pinky.c:498
msgid ""
"  -f              omit the line of column headings in short format\n"
"  -w              omit the user's full name in short format\n"
"  -i              omit the user's full name and remote host in short format\n"
"  -q              omit the user's full name, remote host and idle time\n"
"                  in short format\n"
msgstr ""
"  -f              짧은 형식에서 행의 열 제목 부분을 생략합니다\n"
"  -w              짧은 형식에서 사용자 전체 이름을 생략합니다\n"
"  -i              짧은 형식에서 사용자 전체 이름과 원격 호스트를 생략합니다\n"
"  -q              짧은 형식에서 사용자 전체 이름, 원격 호스트, 대기 시간을\n"
"                  생략합니다\n"

#: src/pinky.c:507
#, c-format
msgid ""
"\n"
"A lightweight 'finger' program;  print user information.\n"
"The utmp file will be %s.\n"
msgstr ""
"\n"
"가벼운 'finger' 프로그램입니다.  사용자 정보를 출력합니다.\n"
"utmp 파일은 %s 위치에 있습니다.\n"

#: src/pinky.c:591
#, c-format
msgid "no username specified; at least one must be specified when using -l"
msgstr ""
"사용자 이름을 지정하지 않았습니다. -l 옵션을 사용할 때는 최소한 하나를 지정해"
"야 합니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:332
msgid "Pete TerMaat"
msgstr "Pete TerMaat"

#. This is a proper name. See the gettext manual, section Names.
#: src/pr.c:333
msgid "Roland Huebner"
msgstr "Roland Huebner"

#: src/pr.c:778
msgid "integer overflow"
msgstr "정수 오버플로우"

#: src/pr.c:918
msgid "'--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "`--pages=<첫_페이지>[:<끝_페이지>]' 인자가 빠졌습니다"

#: src/pr.c:920
#, c-format
msgid "invalid page range %s"
msgstr "부적절한 페이지 범위 %s"

#: src/pr.c:980
msgid "'-l PAGE_LENGTH' invalid number of lines"
msgstr "`-l <페이지_길이>' 부적절한 행의 개수"

#: src/pr.c:995
msgid "'-N NUMBER' invalid starting line number"
msgstr "`-N <번호>' 부적절한 시작 행 번호"

#: src/pr.c:999
msgid "'-o MARGIN' invalid line offset"
msgstr "`-o <여백>' 부적절한 행 오프셋"

#: src/pr.c:1036
msgid "'-w PAGE_WIDTH' invalid number of characters"
msgstr "`-l <페이지_폭>' 부적절한 문자 개수"

#: src/pr.c:1045
msgid "'-W PAGE_WIDTH' invalid number of characters"
msgstr "`-l <페이지_폭>' 부적절한 문자 개수"

#: src/pr.c:1074
msgid "cannot specify number of columns when printing in parallel"
msgstr "병렬 인쇄시 열 항목 수를 지정할 수 없습니다"

#: src/pr.c:1078
msgid "cannot specify both printing across and printing in parallel"
msgstr "병렬 인쇄와 열에 걸친 인쇄를 동시에 지정할 수는 없습니다"

#: src/pr.c:1180
#, c-format
msgid "'-%c' extra characters or invalid number in the argument: %s"
msgstr "'-%c' 인자에서 불필요한 문자 또는 부적절한 숫자가 들어 있습니다: %s"

#: src/pr.c:1284
msgid "page width too narrow"
msgstr "페이지 폭이 너무 좁음"

#: src/pr.c:2346
#, c-format
msgid "starting page number %<PRIuMAX> exceeds page count %<PRIuMAX>"
msgstr ""
"시작 페이지 번호 %<PRIuMAX>번이 총 페이지 수 %<PRIuMAX>을(를) 넘었습니다"

#: src/pr.c:2373
msgid "page number overflow"
msgstr "페이지 수 초과"

#: src/pr.c:2378
#, c-format
msgid "Page %<PRIuMAX>"
msgstr "%<PRIuMAX> 페이지"

#: src/pr.c:2750
msgid "Paginate or columnate FILE(s) for printing.\n"
msgstr "<파일>을 출력 목적으로 페이지별, 열 항목 별로 정렬합니다.\n"

#: src/pr.c:2757
msgid ""
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    output COLUMN columns and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page\n"
msgstr ""
"  +<첫_페이지>[:<끝_페이지>], --pages=<첫_페이지>[:<끝_페이지>]\n"
"                    <첫_페이지>[<끝_페이지>]에서 인쇄를 시작합니다[끝냅니"
"다].\n"
"  -<열>, --columns=<열>\n"
"                    -a 옵션을 사용하지 않는다면 <열> 열의 출력물을 만들어 해"
"당 \n"
"                    열 항목을 페이지 단위로 인쇄합니다.  페이지에서 각각의 "
"열                     항목에 들어 있는 줄 수를 같게 유지합니다\n"

#: src/pr.c:2765
msgid ""
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
msgstr ""
"  -a, --across      한 줄 한 줄을 여러 열에 걸쳐서 인쇄합니다. -<열> 옵션과\n"
"                    같이 씁니다.\n"
"  -c, --show-control-chars\n"
"                    (^G와 같이) ^ 표시를 쓰지 않고 8진수 역슬래시 표시를 씁니"
"다\n"
"  -d, --double-space\n"
"                    한 줄씩 띄워서 인쇄합니다\n"

#: src/pr.c:2773
msgid ""
"  -D, --date-format=FORMAT\n"
"                    use FORMAT for the header date\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"  -D, --date-format=<형식>\n"
"                    <형식>에 맞춰 상단에 날짜를 표시합니다\n"
"  -e[<문자>[<폭>]], --expand-tabs[=<문자>[<폭>]]\n"
"                    입력된 <문자> 문자를 <폭>개의 탭(8)으로 바꿉니다.\n"
"  -F, -f, --form-feed\n"
"                    페이지를 구분하는 데 newline 대신 form feed를 씁니다\n"
"                    (-F는 3줄의 페이지 헤더, -F 없이는 5줄의 헤더와 \n"
"                    trailer)\n"

#: src/pr.c:2783
msgid ""
"  -h, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, --sep-string[=STRING] sets separators\n"
msgstr ""
"  -h, --header=<윗단>\n"
"                    페이지 상단에 파일 이름 대신에 가운데 정렬한 <윗단>을 씁"
"니다.\n"
"                    -h \"\"은 빈 줄을 씁니다.  -h \"\"라고 쓰지 마십시오.\n"
"  -i[<문자>[<폭>]], --output-tabs[=<문자>[<폭>]]\n"
"                    공백을 탭 <폭>(8)만큼의 <문자>(또는 탭으)로 바꿉니다\n"
"  -J, --join-lines  전체 줄을 합칩니다. -W 줄 잘라내기를 쓰지 않도록 만들"
"고,\n"
"                    열 항목 정렬을 하지 않으며, --sep-string=[<문자열>]로 구"
"분자를 지정합니다\n"

#: src/pr.c:2792
msgid ""
"  -l, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63).\n"
"                    implies -t if PAGE_LENGTH <= 10\n"
msgstr ""
"  -l, --length=<페이지_길이>\n"
"                    페이지 길이를 <페이지_길이> (66) 줄로 만듭니다\n"
"                    (줄 수의 기본값은 56이고, -F 옵션을 쓰면 63입니다)\n"
"                    <페이지_길이>가 10보다 작을 경우 -t가 들어갑니다\n"
"\n"

#: src/pr.c:2798
msgid ""
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
msgstr ""
"  -m, --merge       모든 파일을 병렬로, 열 항목 별로 출력합니다. \n"
"                    넘어가는 행을 자르되, -J 옵션으로 여러 행을 합쳐\n"
"                    행을 채웁니다\n"

#: src/pr.c:2802
msgid ""
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
msgstr ""
"  -n[<구분>[<숫자>]], --number-lines[=<구분>[<숫자>]]\n"
"                    <숫자>개의 숫자, 다음에 <구분>(탭)으로 줄마다 번호를\n"
"                    매깁니다.  기본적으로 1번째 줄부터 세어 나갑니다.\n"
"  -N, --first-line-number=<개수>\n"
"                    첫 번째 페이지의 첫 번째 줄을 <개수>로 해서 줄 번호를\n"
"                    세어 나갑니다 (+<첫_페이지> 참고)\n"

#: src/pr.c:2810
msgid ""
"  -o, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -o, --indent=<여백>\n"
"                    <여백>(0)개의 공백문자를 각 줄 앞에 씁니다.  -w나 -W에"
"는\n"
"                    영향을 주지 않으며, <여백>은 <페이지_폭>에 추가합니다\n"
"  -r, --no-file-warnings\n"
"                    파일을 열 수 없을 때 경고를 생략합니다.\n"

#: src/pr.c:2817
msgid ""
"  -s[CHAR], --separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -"
"w.\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
msgstr ""
"  -s[<문자>],--separator[=<문자>]\n"
"                    각 열 항목을 한 개의 <문자>로 구분합니다.  <문자>의 기본"
"값은 \n"
"                    -w가 없으면 탭 문자를 넣고, -w가 있으면 구분자를 넣지 않"
"습니다.\n"
"                    -s[<문자>]는 모든 3열 옵션의 (-<열>|-a -<열>|-m) \n"
"                    넘어가는 줄 자르기 기능을 (-w가 없으면) 끕니다.\n"

#: src/pr.c:2825
msgid ""
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by STRING,\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
msgstr ""
"  -S[<문자열>], --sep-string[=<문자열>]\n"
"                    여러 열 항목을 -S 없이 <문자열>로 구분합니다. \n"
"                    기본 구분자는 탭 문자와 -J이고 그 외의 경우 공백 문자입니"
"다\n"
"                    (-S\" \"와 동일). 열 항목 관련 옵션에 영향을 주지 않습니"
"다\n"

#: src/pr.c:2831
msgid ""
"  -t, --omit-header  omit page headers and trailers;\n"
"                     implied if PAGE_LENGTH <= 10\n"
msgstr ""
"  -t, --omit-header  페이지 앞부분 과 뒷부분을 생략합니다\n"
"                     PAGE_LENGTH <= 10 조건 설정을 생략했습니다\n"

#: src/pr.c:2835
msgid ""
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
msgstr ""
"  -T, --omit-pagination\n"
"                    페이지 헤더와 접두문자를 생략하고, 입력 파일에 들어 있"
"는\n"
"                    폼피드 페이지 구분을 없앱니다\n"
"  -v, --show-nonprinting\n"
"                    8진수 역슬래시 표시를 사용합니다\n"
"  -w, --width=<페이지_폭>\n"
"                    텍스트-열 항목 출력에서, -s[<문자>]를 쓰지 않았을 경우"
"에\n"
"                    페이지 폭을 <페이지_폭>(72)으로 합니다\n"

#: src/pr.c:2845
msgid ""
"  -W, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
msgstr ""
"  -W, --page-width=<페이지_폭>\n"
"                    페이지이 폭을 <페이지_폭>(72)으로 맞춥니다.  넘어가는 \n"
"                    줄은 잘려지고, -J 옵션과 같은 효과가 나오는 것을 제외하"
"면, \n"
"                    -S나 -s에 영향을 받지 않습니다.\n"

#: src/printenv.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [VARIABLE]...\n"
"Print the values of the specified environment VARIABLE(s).\n"
"If no VARIABLE is specified, print name and value pairs for them all.\n"
"\n"
msgstr ""
"사용법: %s [<옵션>]... [<변수>]...\n"
"지정한 환경 <변수> 값을 출력합니다.\n"
"<변수>를 지정하지 않았다면 환경 변수 이름과 값을 모두 출력합니다.\n"
"\n"

#: src/printenv.c:69
msgid "  -0, --null     end each output line with NUL, not newline\n"
msgstr "  -0, --null     각 출력 행을 개행 문자가 아닌 NUL로 끝냅니다\n"

#: src/printf.c:85
#, c-format
msgid ""
"warning: %s: character(s) following character constant have been ignored"
msgstr "경고: %s: 문자 상수가 뒤따르는 문자를 무시합니다"

#: src/printf.c:94
#, c-format
msgid ""
"Usage: %s FORMAT [ARGUMENT]...\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s <형식> [<인자>]...\n"
" 또는:  %s <옵션>\n"

#: src/printf.c:99
msgid ""
"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\n"
"\n"
msgstr ""
"<형식>에 따라 <인자>를 출력하거나 <옵션>에 따라 실행합니다:\n"
"\n"

#: src/printf.c:105
msgid ""
"\n"
"FORMAT controls the output as in C printf.  Interpreted sequences are:\n"
"\n"
"  \\\"      double quote\n"
msgstr ""
"\n"
"<형식> 은 C printf 처럼 출력을 제어합니다.  번역 시퀀스는 다음과 같습니다:\n"
"\n"
"  \\\"      큰 따옴표\n"

#: src/printf.c:123
msgid ""
"  \\NNN    byte with octal value NNN (1 to 3 digits)\n"
"  \\xHH    byte with hexadecimal value HH (1 to 2 digits)\n"
"  \\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\n"
"  \\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\n"
msgstr ""
"  \\NNN    8진수 바이트 NNN 값 (1 ~ 3 자리)\n"
"  \\xHH    16진수 바이트 HH 값 (1 ~ 2 자리)\n"
"  \\uHHHH  16진수 유니코드 (ISO/IEC 10646) 문자 HHHH 값 (4 자리)\n"
"  \\UHHHHHHHH  16진수 유니코드 문자 HHHHHHHH 값 (8 자리)\n"

#: src/printf.c:129
msgid ""
"  %%      a single %\n"
"  %b      ARGUMENT as a string with '\\' escapes interpreted,\n"
"          except that octal escapes are of the form \\0 or \\0NNN\n"
"  %q      ARGUMENT is printed in a format that can be reused as shell "
"input,\n"
"          escaping non-printable characters with the proposed POSIX $'' "
"syntax.\n"
"\n"
"and all C format specifications ending with one of diouxXfeEgGcs, with\n"
"ARGUMENTs converted to proper type first.  Variable widths are handled.\n"
msgstr ""
"  %%      단일 % 기호\n"
"  %b      '\\' 이스케이프를 표현한 문자열 <인자> 이며,\n"
"          \\0 또는 \\0NNN 모양새를 갖춘 8진 이스케이프는 해당하지 않습니다\n"
"  %q      셸 입력으로 재사용할 수 잇는 형식으로 출력한 <인자> 이며,\n"
"          출력 불가능한 문자는 미리 정의한 POSIX $'' 문법에 따라 이스케이핑합"
"니다.\n"
"\n"
"그리고 diouxXfeEgGcs 중 하나로 끝나는 모든 C 형식 명세에 대해서는 <인자>\n"
"에 대해 우선 형식을 변환합니다.  변수 너비 또한 처리합니다.\n"

#: src/printf.c:156
#, c-format
msgid "%s: expected a numeric value"
msgstr "%s: 숫자 값이 필요합니다"

#: src/printf.c:158
#, c-format
msgid "%s: value not completely converted"
msgstr "%s: 값을 완전히 변환하지 않았습니다"

#: src/printf.c:270 src/printf.c:297
msgid "missing hexadecimal number in escape"
msgstr "이스케이프 입력에 16진수가 빠짐"

#: src/printf.c:309
#, c-format
msgid "invalid universal character name \\%c%0*x"
msgstr "부적절한 통합 문자 이름 \\%c%0*x"

#: src/printf.c:582
#, c-format
msgid "invalid field width: %s"
msgstr "부적절한 필드 폭: %s"

#: src/printf.c:617
#, c-format
msgid "invalid precision: %s"
msgstr "부적절한 정밀도: %s"

#: src/printf.c:644
#, c-format
msgid "%.*s: invalid conversion specification"
msgstr "%.*s: 부적절한 변환 명세"

#: src/printf.c:727
#, c-format
msgid "warning: ignoring excess arguments, starting with %s"
msgstr "경고: %s(으)로 시작하는 넘치는 인자값 무시"

#. TRANSLATORS: Please translate "F. Pinard" to "François Pinard"
#. if "ç" (c-with-cedilla) is available in the translation's character
#. set and encoding.
#. This is a proper name. See the gettext manual, section Names.
#: src/ptx.c:41
msgid "F. Pinard"
msgstr "F. Pinard"

#: src/ptx.c:416
#, c-format
msgid "%s (for regexp %s)"
msgstr "%s (정규식 %s에 대해)"

#: src/ptx.c:819
#, c-format
msgid "error: regular expression has a match of length zero: %s"
msgstr "오류: 정규 표현식이 0 길이 문자열과 일치합니다: %s"

#: src/ptx.c:1707
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"사용법: %s [<옵션>]... [<입력>]...   (-G 제외)\n"
" 또는:  %s -G [<옵션>]... [<입력> [<출력>]]\n"
"\n"

#: src/ptx.c:1711
msgid ""
"Output a permuted index, including context, of the words in the input "
"files.\n"
msgstr ""
"입력 파일에 들어있는 단어의 컨텍스트가 들어간 선행 인덱스를 출력합니다.\n"

#: src/ptx.c:1718
msgid ""
"  -A, --auto-reference           output automatically generated references\n"
"  -G, --traditional              behave more like System V 'ptx'\n"
msgstr ""
"  -A, --auto-reference           자동으로 만든 참조를 출력합니다\n"
"  -G, --traditional              System V `ptx'와 더 비슷하게 동작합니다\n"

#: src/ptx.c:1722
msgid ""
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\n"
"                                 The default is '/'\n"
msgstr ""
"  -F, --flag-truncation=<문자열>  행 자르기 플래깅에 <문자열>을 사용합니다.\n"
"                                  기본 문자열은 '/' 입니다\n"

#: src/ptx.c:1726
msgid ""
"  -M, --macro-name=STRING        macro name to use instead of 'xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
msgstr ""
"  -M, --macro-name=<문자열>      `xx' 대신에 사용할 매크로 이름\n"
"  -O, --format=roff              출력을 roff로 합니다\n"
"  -R, --right-side-refs          참조를 오른쪽에 씁니다. -w의 경우 효과 없"
"음\n"
"  -S, --sentence-regexp=<정규식> 줄의 끝이나 문자의 끝을 나타내는 정규식\n"
"  -T, --format=tex               출력을 TeX 구문로 합니다\n"

#: src/ptx.c:1733
msgid ""
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
msgstr ""
"  -W, --word-regexp=<정규식>     키워드를 구분하는 데 <정규식>을 씁니다\n"
"  -b, --break-file=<파일>        이 <파일>에 단어 구분 문자가 들어 있습니다\n"
"  -f, --ignore-case              정렬에서 소문자와 대문자를 구별하지 않습니"
"다\n"
"  -g, --gap-size=<개수>          출력할 필드의 열 항목 사이 간격\n"
"  -i, --ignore-file=<파일>       이 <파일>에 들어 있는 단어를 무시합니다\n"
"  -o, --only-file=<파일>         이 <파일>에 들어 있는 단어를 읽습니다\n"

#: src/ptx.c:1741
msgid ""
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
msgstr ""
"  -r, --references               각 줄의 첫 번째 필드가 참조입니다\n"
"  -t, --typeset-mode               - 구현하지 않음 -\n"
"  -w, --width=<개수>             출력할 열 항목의 폭 (참조 제외)\n"

#: src/ptx.c:1838
#, c-format
msgid "invalid gap width: %s"
msgstr "부적절한 간격 폭: %s"

#: src/ptx.c:1865
#, c-format
msgid "invalid line width: %s"
msgstr "부적절한 행 길이: %s"

#: src/pwd.c:58
msgid ""
"Print the full filename of the current working directory.\n"
"\n"
msgstr ""
"현재 작업 디렉터리의 전체 파일 이름을 출력합니다.\n"
"\n"

#: src/pwd.c:62
msgid ""
"  -L, --logical   use PWD from environment, even if it contains symlinks\n"
"  -P, --physical  avoid all symlinks\n"
msgstr ""
"  -L, --logical   환경 변수 PWD에 심볼릭 링크가 있더라도 이 변수를 사용합니"
"다\n"
"  -P, --physical  모든 심볼릭 링크는 무시합니다\n"

#: src/pwd.c:68
msgid ""
"\n"
"If no option is specified, -P is assumed.\n"
msgstr ""
"\n"
"지정한 옵션이 없다면 -P 지정을 가정합니다.\n"

#: src/pwd.c:169
#, c-format
msgid "failed to chdir to %s"
msgstr "%s로의 현재 디렉터리 위치 이동 실패"

#: src/pwd.c:173 src/pwd.c:280 src/split.c:470
#, c-format
msgid "failed to stat %s"
msgstr "%s 정보 가져오기 실패"

#: src/pwd.c:238
#, c-format
msgid "couldn't find directory entry in %s with matching i-node"
msgstr "일치하는 아이노드의 %s에서 디렉터리 항목을 찾을 수 없습니다"

#: src/pwd.c:367
#, c-format
msgid "ignoring non-option arguments"
msgstr "옵션 아닌 인자 무시"

#. This is a proper name. See the gettext manual, section Names.
#: src/readlink.c:32
msgid "Dmitry V. Levin"
msgstr "Dmitry V. Levin"

#: src/readlink.c:62 src/realpath.c:71 src/shred.c:171 src/stat.c:1750
#: src/touch.c:217
#, c-format
msgid "Usage: %s [OPTION]... FILE...\n"
msgstr "사용법: %s [<옵션>]... <파일>...\n"

#: src/readlink.c:63
msgid ""
"Print value of a symbolic link or canonical file name\n"
"\n"
msgstr ""
"심볼릭 링크 값 또는 정규 파일 이름을 출력합니다.\n"
"\n"

#: src/readlink.c:65
msgid ""
"  -f, --canonicalize            canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively;\n"
"                                all but the last component must exist\n"
"  -e, --canonicalize-existing   canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                all components must exist\n"
msgstr ""
"  -f, --canonicalize            주어진 이름의 모든 요소에 있는 모든 심볼릭 링"
"크를\n"
"                                하위 연속적으로 따라가 정규화합니다\n"
"                                최종 요소는 반드시 있어야 합니다\n"
"  -e, --canonicalize-existing   주어진 이름의 모든 요소에 있는 모든 심볼릭 링"
"크를\n"
"                                하위 연속적으로 따라가 정규화합니다\n"
"                                모든 요소는 반드시 있어야 합니다\n"

#: src/readlink.c:75
msgid ""
"  -m, --canonicalize-missing    canonicalize by following every symlink in\n"
"                                every component of the given name "
"recursively,\n"
"                                without requirements on components "
"existence\n"
"  -n, --no-newline              do not output the trailing delimiter\n"
"  -q, --quiet\n"
"  -s, --silent                  suppress most error messages (on by "
"default)\n"
"  -v, --verbose                 report error messages\n"
"  -z, --zero                    end each output line with NUL, not newline\n"
msgstr ""
"  -m, --canonicalize-missing    해당 요소의 존재 여부 요구 없이 주어진\n"
"                                이름의 모든 요소에 있는 모든 심볼릭 링크를 하"
"위\n"
"                                연속적으로 따라가 정규화합니다\n"
"  -n, --no-newline              뒤따라오는 구분자는 출력하지 않습니다\n"
"  -q, --quiet\n"
"  -s, --silent                  대부분의 오류 메시지를 숨깁니다(활성화가 기"
"본)\n"
"  -v, --verbose                 오류 메시지를 출력합니다\n"
"  -z, --zero                    각 출력을 개행 문자가 아닌 NUL 문자로 끝냅니"
"다\n"

#: src/readlink.c:152
#, c-format
msgid "ignoring --no-newline with multiple arguments"
msgstr "다중 인자에 붙인 --no-newline 무시"

#: src/realpath.c:72
msgid ""
"Print the resolved absolute file name;\n"
"all but the last component must exist\n"
"\n"
msgstr ""
"완전한 절대 경로 파일 이름을 출력합니다.\n"
"마지막 요소까지는 반드시 있어야 합니다\n"
"\n"

#: src/realpath.c:77
msgid ""
"  -e, --canonicalize-existing  all components of the path must exist\n"
"  -m, --canonicalize-missing   no path components need exist or be a "
"directory\n"
"  -L, --logical                resolve '..' components before symlinks\n"
"  -P, --physical               resolve symlinks as encountered (default)\n"
"  -q, --quiet                  suppress most error messages\n"
"      --relative-to=DIR        print the resolved path relative to DIR\n"
"      --relative-base=DIR      print absolute paths unless paths below DIR\n"
"  -s, --strip, --no-symlinks   don't expand symlinks\n"
"  -z, --zero                   end each output line with NUL, not newline\n"
msgstr ""
"  -e, --canonicalize-existing  경로의 모든 요소가 반드시 있어야 합니다\n"
"  -m, --canonicalize-missing   경로요소가 있을 필요가 없거나 디렉터리면 됩니"
"다\n"
"  -L, --logical                심볼릭 링크 처리 전 '..' 요소를 해결합니다\n"
"  -P, --physical               심볼릭 링크를 거친 것으로 해결합니다 (기본)\n"
"  -q, --quiet                  대부분의 오류 메시지를 숨깁니다\n"
"      --relative-to=<디렉터리>        디렉터리에 상대적인 기 처리 경로로 출력"
"합니다\n"
"      --relative-base=<디렉터리>      <디렉터리>에 경로가 있지 않는 한 절대 "
"경로를 나타냅니다\n"
"  -s, --strip, --no-symlinks   심볼릭 링크를 확장하지 않습니다\n"
"  -z, --zero                   각 출력 행을 개행 문자가 아닌 NUL로 끝냅니다\n"

#: src/relpath.c:131
msgid "generating relative path"
msgstr "상대 경로 만드는 중"

#: src/remove.c:273
#, c-format
msgid "%s: descend into write-protected directory %s? "
msgstr "%s: 쓰기 금지한 %s 디렉터리로 거슬러 내려갈까요? "

#: src/remove.c:274
#, c-format
msgid "%s: descend into directory %s? "
msgstr "%s: %s 디렉터리로 거슬러 내려갈까요? "

#. TRANSLATORS: In the next two strings the second %s is
#. replaced by the type of the file.  To avoid grammatical
#. problems, it may be more convenient to translate these
#. strings instead as: "%1$s: %3$s is write-protected and
#. is of type '%2$s' -- remove it? ".
#: src/remove.c:291
#, c-format
msgid "%s: remove write-protected %s %s? "
msgstr "%s: 쓰기 금지한 %s %s을(를) 제거할까요?  "

#: src/remove.c:292
#, c-format
msgid "%s: remove %s %s? "
msgstr "%s: %s %s을(를) 제거할까요? "

#: src/remove.c:375
#, c-format
msgid "removed directory %s\n"
msgstr "%s 디렉터리를 제거했습니다\n"

#: src/remove.c:448
#, c-format
msgid "refusing to remove %s or %s directory: skipping %s"
msgstr "%s 또는 %s 디렉터리 제거 거절: %s 건너뜀"

#: src/remove.c:477
#, c-format
msgid "failed to stat %s: skipping %s"
msgstr "%s 상태 정보 확인 실패: %s 건너뜀"

#: src/remove.c:490 src/remove.c:541
#, c-format
msgid "skipping %s, since it's on a different device"
msgstr "다른 장치에 있어 %s 건너뜀"

#: src/remove.c:492
#, c-format
msgid "and --preserve-root=all is in effect"
msgstr "그리고 --preserve-root=all은 적용받지 않습니다"

#: src/remove.c:561
#, c-format
msgid "traversal failed: %s"
msgstr "순회 실패: %s"

#: src/remove.c:567
#, c-format
msgid ""
"unexpected failure: fts_info=%d: %s\n"
"please report to %s"
msgstr ""
"예상치 못한 실패: fts_info=%d: %s\n"
"%s에 보고하십시오"

#: src/rm.c:117
#, c-format
msgid "Try '%s ./%s' to remove the file %s.\n"
msgstr "%s 파일을 제거하려면 '%s ./%s' 명령을 사용하십시오.\n"

#: src/rm.c:134
msgid ""
"Remove (unlink) the FILE(s).\n"
"\n"
"  -f, --force           ignore nonexistent files and arguments, never "
"prompt\n"
"  -i                    prompt before every removal\n"
msgstr ""
"<파일>을 제거(unlink) 합니다.\n"
"\n"
"  -f, --force           없는 파일과 인자를 무시하고, 묻지 않습니다\n"
"  -i                    모든 항목을 제거할 때마다 질문\n"

#: src/rm.c:140
msgid ""
"  -I                    prompt once before removing more than three files, "
"or\n"
"                          when removing recursively; less intrusive than -"
"i,\n"
"                          while still giving protection against most "
"mistakes\n"
"      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or\n"
"                          always (-i); without WHEN, prompt always\n"
msgstr ""
"  -I                    파일 세개 이상 제거하기 전 또는 하위 연속으로 제거"
"시\n"
"                          질문합니다. 대부분의 실수를 막아주는 -i 옵션과는 달"
"리\n"
"                          간섭이 덜합니다\n"
"      --interactive[=<시기>]  <시기> 값에 따라 질문합니다. 해당 값: never, "
"once (-I), \n"
"                          always (-i). <시기> 값이 없으면 항상 질문합니다\n"

#: src/rm.c:147
msgid ""
"      --one-file-system  when removing a hierarchy recursively, skip any\n"
"                          directory that is on a file system different from\n"
"                          that of the corresponding command line argument\n"
msgstr ""
"      --one-file-system  계층을 하위 연속으로 삭제할 때, 해당 명령행의\n"
"                          인자와 다른 파일 시스템의 디렉터리는 건너뜁니다\n"

#: src/rm.c:152
msgid ""
"      --no-preserve-root  do not treat '/' specially\n"
"      --preserve-root[=all]  do not remove '/' (default);\n"
"                              with 'all', reject any command line argument\n"
"                              on a separate device from its parent\n"
msgstr ""
"      --no-preserve-root  '/' 경로를 특별하게 취급하지 않습니다\n"
"      --preserve-root[=all]  '/' 경로를 제거하지 않습니다 (기본).\n"
"                              'all' 옵션을 주면 개별 장치 자체 상위의 어떤 \n"
"                              명령행 인자든 무시합니다\n"

#: src/rm.c:158
msgid ""
"  -r, -R, --recursive   remove directories and their contents recursively\n"
"  -d, --dir             remove empty directories\n"
"  -v, --verbose         explain what is being done\n"
msgstr ""
"  -r, -R, --recursive   하위 디렉터리와 해당 경로의 파일도 제거합니다\n"
"  -d, --dir             빈 디렉터리 제거합니다\n"
"  -v, --verbose         진행 동작을 설명합니다\n"

#: src/rm.c:165
msgid ""
"\n"
"By default, rm does not remove directories.  Use the --recursive (-r or -R)\n"
"option to remove each listed directory, too, along with all of its "
"contents.\n"
msgstr ""
"\n"
"기본적으로 rm 명령은 디렉터리를 제거하지 않습니다.  디렉터리와 해당 경로의\n"
"파일을 함께 제거하려면 --recursive(-r 또는 -R) 옵션을 활용하십시오.\n"

#: src/rm.c:170
#, c-format
msgid ""
"\n"
"To remove a file whose name starts with a '-', for example '-foo',\n"
"use one of these commands:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"
msgstr ""
"\n"
"'-foo'와 같이 '-' 문자로 시작하는 파일을 제거하려면,\n"
"다음과 같이 명령을 사용하십시오:\n"
"  %s -- -foo\n"
"\n"
"  %s ./-foo\n"

#: src/rm.c:179
msgid ""
"\n"
"Note that if you use rm to remove a file, it might be possible to recover\n"
"some of its contents, given sufficient expertise and/or time.  For greater\n"
"assurance that the contents are truly unrecoverable, consider using "
"shred(1).\n"
msgstr ""
"\n"
"참고로 rm 명령으로 파일을 제거했을 경우, 충분한 전문성과 시간을 확보했다면\n"
"일부 내용을 복원할 수도 있습니다.  완전하게 복원할 수 없게끔 하려면 "
"shred(1) \n"
"명령 사용을 검토하십시오.\n"

#: src/rm.c:297
msgid "you may not abbreviate the --no-preserve-root option"
msgstr "--no-preserve-root 옵션은 약자로 쓸 수 없습니다"

#: src/rm.c:309
#, c-format
msgid "unrecognized --preserve-root argument: %s"
msgstr "인식할 수 없는 --preserve-root 인자: %s"

#: src/rm.c:359
#, c-format
msgid "%s: remove %<PRIuMAX> argument recursively? "
msgid_plural "%s: remove %<PRIuMAX> arguments recursively? "
msgstr[0] "%s: %<PRIuMAX> 인자를 하위 연속적으로 제거할까요? "

#: src/rm.c:362
#, c-format
msgid "%s: remove %<PRIuMAX> argument? "
msgid_plural "%s: remove %<PRIuMAX> arguments? "
msgstr[0] "%s: %<PRIuMAX> 인자를 제거할까요? "

#: src/rmdir.c:133 src/rmdir.c:249
#, c-format
msgid "removing directory, %s"
msgstr "%s 디렉터리 제거 중"

#: src/rmdir.c:152
#, c-format
msgid "failed to remove directory %s"
msgstr "%s 디렉터리 제거 실패"

#: src/rmdir.c:157 src/rmdir.c:292
#, c-format
msgid "failed to remove %s"
msgstr "%s 제거 실패"

#: src/rmdir.c:175
msgid ""
"Remove the DIRECTORY(ies), if they are empty.\n"
"\n"
msgstr ""
"<디렉터리>가 비어있으면 제거합니다.\n"
"\n"

#: src/rmdir.c:179
msgid ""
"      --ignore-fail-on-non-empty\n"
"                    ignore each failure that is solely because a directory\n"
"                    is non-empty\n"
"\n"
msgstr ""
"      --ignore-fail-on-non-empty\n"
"                  디렉터리가 비어있지 않아 드물게 실패하는 경우를\n"
"                  무시합니다\n"

#: src/rmdir.c:185
msgid ""
"  -p, --parents     remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/"
"c'\n"
"                    is similar to 'rmdir a/b/c a/b a'\n"
"\n"
msgstr ""
"  -p, --parents   <디렉터리>와 해당 하위 요소를 지웁니다\n"
"                  예) `rmdir -p a/b/c'는 `rmdir a/b/c a/b a'과 비슷합니다\n"
"\n"

#: src/rmdir.c:191
msgid "  -v, --verbose     output a diagnostic for every directory processed\n"
msgstr ""
"  -v, --verbose   처리하는 모든 디렉터리의 진단 메시지를 출력합니다\n"
"\n"

#: src/rmdir.c:281
#, c-format
msgid "failed to remove %s: Symbolic link not followed"
msgstr "%s 제거 실패: 심볼릭 링크를 따라가지 않음"

#: src/runcon.c:78
#, c-format
msgid ""
"Usage: %s CONTEXT COMMAND [args]\n"
"  or:  %s [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [args]\n"
msgstr ""
"사용법: %s <컨텍스트> 명령 [<인자>]\n"
"  또는:  %s [ -c ] [-u <사용자>] [-r <역할>] [-t <형식>] [-l <범위>] <명령> "
"[<인자>]\n"

#: src/runcon.c:82
msgid ""
"Run a program in a different SELinux security context.\n"
"With neither CONTEXT nor COMMAND, print the current security context.\n"
msgstr ""
"개별 SELinux 보안 컨텍스트에서 프로그램을 실행합니다.\n"
"<컨텍스트> 또는 <명령> 그 어느 하나라도 지정하지 않으면, 현재 보안 컨텍스트"
"를 출력합니다.\n"

#: src/runcon.c:89
msgid ""
"  CONTEXT            Complete security context\n"
"  -c, --compute      compute process transition context before modifying\n"
"  -t, --type=TYPE    type (for same role as parent)\n"
"  -u, --user=USER    user identity\n"
"  -r, --role=ROLE    role\n"
"  -l, --range=RANGE  levelrange\n"
msgstr ""
"  <컨텍스트>            완전한 보안 컨텍스트\n"
"  -c, --compute      수정 전 프로세스 이행 컨텍스트를 처리합니다\n"
"  -t, --type=<형식>    형식 (상위 역할 개념과 동일)\n"
"  -u, --user=<사용자>    사용자 식별 이름\n"
"  -r, --role=<역할>    역할\n"
"  -l, --range=<범위>  수준 범위\n"

#: src/runcon.c:138
msgid "multiple roles"
msgstr "다중 역할"

#: src/runcon.c:143
msgid "multiple types"
msgstr "다중 형식"

#: src/runcon.c:148
msgid "multiple users"
msgstr "다중 사용자"

#: src/runcon.c:153
msgid "multiple levelranges"
msgstr "다중 수준범위"

#: src/runcon.c:171 src/runcon.c:207
msgid "failed to get current context"
msgstr "현재 컨텍스트 가져오기 실패"

#: src/runcon.c:181
#, c-format
msgid "you must specify -c, -t, -u, -l, -r, or context"
msgstr "-c, -t, -u, -l, -r, 컨텍스트 중 하나를 지정해야 합니다"

#: src/runcon.c:189
#, c-format
msgid "no command specified"
msgstr "명령을 지정하지 않았습니다"

#: src/runcon.c:194
#, c-format
msgid "%s may be used only on a SELinux kernel"
msgstr "%s은(는) SELinux 커널에서만 사용할 수 있습니다"

#: src/runcon.c:221
msgid "failed to compute a new context"
msgstr "새 컨텍스트 처리 실패"

#: src/runcon.c:235
#, c-format
msgid "failed to set new user: %s"
msgstr "새 사용자 지정 실패: %s"

#: src/runcon.c:238
#, c-format
msgid "failed to set new type: %s"
msgstr "새 형식 지정 실패: %s"

#: src/runcon.c:241
#, c-format
msgid "failed to set new range: %s"
msgstr "새 범위 지정 실패: %s"

#: src/runcon.c:244
#, c-format
msgid "failed to set new role: %s"
msgstr "새 역할 지정 실패: %s"

#: src/runcon.c:253
#, c-format
msgid "unable to set security context %s"
msgstr "%s 보안 컨텍스트를 지정할 수 없습니다"

#: src/seq.c:80
#, c-format
msgid ""
"Usage: %s [OPTION]... LAST\n"
"  or:  %s [OPTION]... FIRST LAST\n"
"  or:  %s [OPTION]... FIRST INCREMENT LAST\n"
msgstr ""
"사용법: %s [<옵션>] ... <종단>\n"
"  또는:  %s [<옵션>]... <처음> <종단>\n"
"  또는:  %s [<옵션>]... <처음> <증가> <종단>\n"

#: src/seq.c:85
msgid "Print numbers from FIRST to LAST, in steps of INCREMENT.\n"
msgstr ""
"<처음> 부터 <종단> 까지의 숫자를 <증가>값 만큼 단계별로 증가하여 출력합니"
"다.\n"

#: src/seq.c:91
msgid ""
"  -f, --format=FORMAT      use printf style floating-point FORMAT\n"
"  -s, --separator=STRING   use STRING to separate numbers (default: \\n)\n"
"  -w, --equal-width        equalize width by padding with leading zeroes\n"
msgstr ""
"  -f, --format=<형식>      printf 방식 소숫점 표기 <형식>을 활용합니다\n"
"  -s, --separator=<문자열>   <문자열>로 숫자를 구분합니다(기본값: \\n)\n"
"  -w, --equal-width        앞에 숫자 0을 붙여 너비를 동일하게 출력합니다\n"

#: src/seq.c:98
msgid ""
"\n"
"If FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\n"
"omitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"
msgstr ""
"\n"
"<처음> 또는 <증가> 값을 생략하면 기본값은 1입니다. <종단> 값이 <처음> 값보"
"다\n"
"작더라도 생략한 <증가> 기본값은 1입니다.\n"
"The sequence of numbers ends when the sum of the current number and\n"
"INCREMENT would become greater than LAST.\n"
"FIRST, INCREMENT, and LAST are interpreted as floating point values.\n"
"INCREMENT is usually positive if FIRST is smaller than LAST, and\n"
"INCREMENT is usually negative if FIRST is greater than LAST.\n"
"INCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\n"

#: src/seq.c:109
msgid ""
"FORMAT must be suitable for printing one argument of type 'double';\n"
"it defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\n"
"decimal numbers with maximum precision PREC, and to %g otherwise.\n"
msgstr ""
"<형식>은 'double' 형 인자 중 하나를 출력하는데 안성맞춤입니다.\n"
"%.<정밀도>f가 기본이며 <처음>, <증가>, <종단> 값이 고정 소숫점이라면\n"
"최대 <정밀도> 값으로 소숫점을 출력하며 그렇지 않으면 %g로 맞춥니다.\n"

#: src/seq.c:155
#, c-format
msgid "invalid floating point argument: %s"
msgstr "부적절한 부동 소숫점 인자: %s"

#: src/seq.c:161
#, c-format
msgid "invalid %s argument: %s"
msgstr "부적절한 %s 인자: %s"

#: src/seq.c:268
#, c-format
msgid "format %s has unknown %%%c directive"
msgstr "%s 형식에 알 수 없는 %%%c 지시어가 있습니다"

#: src/seq.c:650
#, c-format
msgid "format string may not be specified when printing equal width strings"
msgstr "동일 폭 문자열을 출력할 때는 문자열 형식을 지정할 수 없습니다"

#: src/seq.c:694
#, c-format
msgid "invalid Zero increment value: %s"
msgstr "부적절한 0 증가 값: %s"

#: src/set-fields.c:166
msgid "invalid byte or character range"
msgstr "부적절한 바이트 또는 문자 범위"

#: src/set-fields.c:167
msgid "invalid field range"
msgstr "부적절한 필드 범위"

#: src/set-fields.c:174 src/set-fields.c:220
msgid "byte/character positions are numbered from 1"
msgstr "바이트/문자 위치는 1부터 시작합니다"

#: src/set-fields.c:175 src/set-fields.c:221
msgid "fields are numbered from 1"
msgstr "필드 번호가 1부터 시작합니다"

#: src/set-fields.c:195
msgid "invalid range with no endpoint: -"
msgstr "종단점 없는 부적절한 범위: -"

#: src/set-fields.c:209
msgid "invalid decreasing range"
msgstr "부적절한 감소 범위"

#: src/set-fields.c:258
#, c-format
msgid "byte/character offset %s is too large"
msgstr "%s 바이트/문자 오프셋 값이 너무 큽니다"

#: src/set-fields.c:259
#, c-format
msgid "field number %s is too large"
msgstr "%s 필드 번호가 너무 큽니다"

#: src/set-fields.c:270
#, c-format
msgid "invalid byte/character position %s"
msgstr "부적절한 %s 바이트/문자 위치"

#: src/set-fields.c:271
#, c-format
msgid "invalid field value %s"
msgstr "부적절한 필드 값 %s"

#: src/set-fields.c:279
msgid "missing list of byte/character positions"
msgstr "바이트/문자 위치 목록이 빠짐"

#: src/set-fields.c:280
msgid "missing list of fields"
msgstr "필드 목록 빠짐"

#. This is a proper name. See the gettext manual, section Names.
#: src/shred.c:74
msgid "Colin Plumb"
msgstr "Colin Plumb"

#: src/shred.c:172
msgid ""
"Overwrite the specified FILE(s) repeatedly, in order to make it harder\n"
"for even very expensive hardware probing to recover the data.\n"
msgstr ""
"데이터 복구에 매우 비싼 하드웨어 복구 과정 조차도 수행하기 어렵도록\n"
"지정 <파일>을 반복하여 덮어씁니다.\n"

#: src/shred.c:176
msgid ""
"\n"
"If FILE is -, shred standard output.\n"
msgstr ""
"\n"
"<파일>이 - 이면, 표준 출력을 자릅니다.\n"

#: src/shred.c:183
#, c-format
msgid ""
"  -f, --force    change permissions to allow writing if necessary\n"
"  -n, --iterations=N  overwrite N times instead of the default (%d)\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -s, --size=N   shred this many bytes (suffixes like K, M, G accepted)\n"
msgstr ""
"  -f, --force    필요하다면 기록 권한을 바꿉니다\n"
"  -n, --iterations=<숫자>  기본 횟수(%d) 대신 <숫자>횟수만큼 덮어씁니다\n"
"      --random-source=<파일>  <파일>에서 임의 바이트를 가져옵니다\n"
"  -s, --size=<숫자>   지정 바이트 수만큼 파기합니다 (K, M, G 같은 접미사 허"
"용)\n"

#: src/shred.c:189
msgid ""
"  -u             deallocate and remove file after overwriting\n"
"      --remove[=HOW]  like -u but give control on HOW to delete;  See below\n"
"  -v, --verbose  show progress\n"
"  -x, --exact    do not round file sizes up to the next full block;\n"
"                   this is the default for non-regular files\n"
"  -z, --zero     add a final overwrite with zeros to hide shredding\n"
msgstr ""
"  -u             덮어쓴 후 파일 할당을 해제하고 제거합니다\n"
"      --remove[=<방식>]  -u 옵션과 비슷하지만 삭제 <방법>을 제시합니다. 하단 "
"참조\n"
"  -v, --verbose  진행 과정을 나타냅니다\n"
"  -x, --exact    다음 전체 블록 만큼의 파일 크기를 넘기지 않습니다.\n"
"                   비정규 파일에 대한 기본 설정입니다\n"
"  -z, --zero     잘게 자른 부분을 숨길 목적으로 마지막 0값 덮어쓰기를 추가합"
"니다\n"

#: src/shred.c:199
msgid ""
"\n"
"Delete FILE(s) if --remove (-u) is specified.  The default is not to remove\n"
"the files because it is common to operate on device files like /dev/hda,\n"
"and those files usually should not be removed.\n"
"The optional HOW parameter indicates how to remove a directory entry:\n"
"'unlink' => use a standard unlink call.\n"
"'wipe' => also first obfuscate bytes in the name.\n"
"'wipesync' => also sync each obfuscated byte to the device.\n"
"The default mode is 'wipesync', but note it can be expensive.\n"
"\n"
msgstr ""
"\n"
"--remove (-u) 옵션을 지정하면 <파일>을 삭제합니다.  기본 동작은 파일 제거가 "
"아니고,\n"
"/dev/hda와 같은 장치 파일에서 처리하는게 일반적이며, 이 파일은 보통 제거하면 "
"안됩니다.\n"
"추가 <방식> 매개변수는 디렉터리 항목 제거 방식을 나타냅니다:\n"
"'unlink' => 표준 unlink 호출을 활용합니다.\n"
"'wipe' => 이름에 처음 애매한 바이트도 삭제합니다.\n"
"'wipesync' => 애매한 각 바이트도 장치에 동기화합니다.\n"
"기본 모드는 'wipesync' 이지만 참고로 처리 시간이 꽤 걸릴 수 있습니다.\n"
"\n"

#: src/shred.c:211
msgid ""
"CAUTION: shred assumes the file system and hardware overwrite data in "
"place.\n"
"Although this is common, many platforms operate otherwise.  Also, backups\n"
"and mirrors may contain unremovable copies that will let a shredded file\n"
"be recovered later.  See the GNU coreutils manual for details.\n"
msgstr ""
"중대경고: shred는 파일 시스템과 하드웨어에서 데이터가 있던 자리에 그대로 덮어"
"씀을\n"
"간주합니다. 비록 일반적인 일이긴 하지만 다른 플랫폼에서는 그렇지 않습니다. 또"
"한,\n"
"백업과 비러링에는 결국 파쇄하겠지만 나중에 복구할 삭제할 수 없는 복제본이 있"
"을 수\n"
"있습니다.  자세한 내용은 GNU coreutils 설명서를 참조하십시오.\n"

#: src/shred.c:311
#, c-format
msgid "%s: fdatasync failed"
msgstr "%s: fdatasync 실패"

#: src/shred.c:322
#, c-format
msgid "%s: fsync failed"
msgstr "%s: fsync 실패"

#: src/shred.c:436
#, c-format
msgid "%s: cannot rewind"
msgstr "%s: 돌아갈 수 없습니다"

#: src/shred.c:456
#, c-format
msgid "%s: pass %lu/%lu (%s)..."
msgstr "%s: 진행: %lu/%lu (%s)..."

#: src/shred.c:507
#, c-format
msgid "%s: error writing at offset %s"
msgstr "%s: %s 오프셋 쓰기 오류"

#: src/shred.c:528
#, c-format
msgid "%s: lseek failed"
msgstr "%s: lseek 실패"

#: src/shred.c:540
#, c-format
msgid "%s: file too large"
msgstr "%s: 파일이 너무 큽니다"

#: src/shred.c:564
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s"
msgstr "%s: 진행: %lu/%lu (%s)...%s"

#: src/shred.c:580
#, c-format
msgid "%s: pass %lu/%lu (%s)...%s/%s %d%%"
msgstr "%s: 진행: %lu/%lu (%s)...%s/%s %d%%"

#: src/shred.c:838
#, c-format
msgid "%s: fstat failed"
msgstr "%s: fstat 실패"

#: src/shred.c:849
#, c-format
msgid "%s: invalid file type"
msgstr "%s: 부적절한 파일 형식"

#: src/shred.c:854
#, c-format
msgid "%s: file has negative size"
msgstr "%s: 파일이 음의 크기를 갖습니다"

#: src/shred.c:950 src/sort.c:975 src/split.c:476
#, c-format
msgid "%s: error truncating"
msgstr "%s: 잘림 오류"

#: src/shred.c:969
#, c-format
msgid "%s: fcntl failed"
msgstr "%s: fcntl 실패"

#: src/shred.c:974
#, c-format
msgid "%s: cannot shred append-only file descriptor"
msgstr "%s: 쓰기 전용 파일 디스크립터는 파기할 수 없습니다"

#: src/shred.c:1057
#, c-format
msgid "%s: removing"
msgstr "%s: 제거중"

#: src/shred.c:1082
#, c-format
msgid "%s: renamed to %s"
msgstr "%s: %s(으)로 이름 바뀜"

#: src/shred.c:1091
#, c-format
msgid "%s: failed to remove"
msgstr "%s: 제거 실패"

#: src/shred.c:1095
#, c-format
msgid "%s: removed"
msgstr "%s: 제거함"

#: src/shred.c:1102 src/shred.c:1145
#, c-format
msgid "%s: failed to close"
msgstr "%s: 닫기 실패"

#: src/shred.c:1138
#, c-format
msgid "%s: failed to open for writing"
msgstr "%s: 쓰기용 열기 실패"

#: src/shred.c:1201
msgid "invalid number of passes"
msgstr "부적절한 허용 횟수"

#: src/shred.c:1206 src/shuf.c:462 src/sort.c:4591
msgid "multiple random sources specified"
msgstr "임의 소스를 여러번 지정했습니다"

#: src/shred.c:1220
msgid "invalid file size"
msgstr "부적절한 파일 크기"

#: src/shuf.c:62
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]\n"
"  or:  %s -e [OPTION]... [ARG]...\n"
"  or:  %s -i LO-HI [OPTION]...\n"
msgstr ""
"사용법: %s [<옵션>]... [<파일>]\n"
" 또는:  %s -e [<옵션>]... [<인자>]...\n"
" 또는:  %s -i <최소-최대> [<옵션>]...\n"

#: src/shuf.c:68
msgid "Write a random permutation of the input lines to standard output.\n"
msgstr "입력행의 임의 치환 내용을 표준 출력으로 기록합니다.\n"

#: src/shuf.c:75
msgid ""
"  -e, --echo                treat each ARG as an input line\n"
"  -i, --input-range=LO-HI   treat each number LO through HI as an input "
"line\n"
"  -n, --head-count=COUNT    output at most COUNT lines\n"
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"      --random-source=FILE  get random bytes from FILE\n"
"  -r, --repeat              output lines can be repeated\n"
msgstr ""
"  -e, --echo                각각의 <인자>를 입력 라인으로 취급합니다\n"
"  -i, --input-range=<저-고>  <저>부터 <고>까지의 각 번호를 입력 라인으로 취급"
"합니다\n"
"  -n, --head-count=<계수>   처음 <계수> 행 만큼 출력합니다\n"
"  -o, --output=<파일>       표준 입력 대신 <파일>로 결과를 기록합니다\n"
"      --random-source=<파일>  <파일>에서 임의 바이트를 가져옵니다\n"
"  -r, --repeat              출력 행을 반복할 수 있습니다\n"

#: src/shuf.c:83 src/sort.c:503 src/uniq.c:201
msgid "  -z, --zero-terminated     line delimiter is NUL, not newline\n"
msgstr ""
"  -z, --zero-terminated     행 종결자를 개행 문자 대신 NUL 문자를 씁니다\n"

#: src/shuf.c:226
msgid "too many input lines"
msgstr "너무 많은 입력 파일"

#: src/shuf.c:418
msgid "multiple -i options specified"
msgstr "-i 옵션을 여러번 지정했습니다"

#: src/shuf.c:425 src/shuf.c:431 src/shuf.c:436
msgid "invalid input range"
msgstr "부적절한 입력 범위"

#: src/shuf.c:449
#, c-format
msgid "invalid line count: %s"
msgstr "부적절한 행 갯수: %s"

#: src/shuf.c:456 src/sort.c:4585
msgid "multiple output files specified"
msgstr "다중 출력 파일을 지정했습니다"

#: src/shuf.c:486
#, c-format
msgid "cannot combine -e and -i options"
msgstr "-e와 -i 옵션을 함께 활용할 수 없습니다"

#: src/shuf.c:576
msgid "no lines to repeat"
msgstr "반복할 행이 없습니다"

#: src/sleep.c:44
#, c-format
msgid ""
"Usage: %s NUMBER[SUFFIX]...\n"
"  or:  %s OPTION\n"
"Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),\n"
"'m' for minutes, 'h' for hours or 'd' for days.  NUMBER need not be an\n"
"integer.  Given two or more arguments, pause for the amount of time\n"
"specified by the sum of their values.\n"
"\n"
msgstr ""
"사용법: %s <숫자>[<접미사>]...\n"
"  또는:  %s <옵션>\n"
"<숫자> 초 동안 멈춥니다.  <접미사>는 초의 's' (기본값), 분의 'm', \n"
"시간의 'h', 일의 'd'를 쓸 수 있습니다.  <숫자>는 정수여야 합니다.\n"
"둘 이상의 인자를 제시하면 해당 지정 값을 합한 시간 동안 멈춥니다.\n"
"\n"

#: src/sleep.c:132 src/timeout.c:365
#, c-format
msgid "invalid time interval %s"
msgstr "부적절한 시간 간격 %s"

#: src/sleep.c:143 src/tail.c:1314
msgid "cannot read realtime clock"
msgstr "실시간 시계를 읽을 수 없습니다"

#: src/sort.c:423
msgid "Write sorted concatenation of all FILE(s) to standard output.\n"
msgstr "모든 <파일>을 정렬한 연속 내용을 표준 출력에 씁니다.\n"

#: src/sort.c:430
msgid ""
"Ordering options:\n"
"\n"
msgstr ""
"정렬 옵션:\n"
"\n"

#: src/sort.c:434
msgid ""
"  -b, --ignore-leading-blanks  ignore leading blanks\n"
"  -d, --dictionary-order      consider only blanks and alphanumeric "
"characters\n"
"  -f, --ignore-case           fold lower case to upper case characters\n"
msgstr ""
"  -b, --ignore-leading-blanks  앞 공백을 무시합니다\n"
"  -d, --dictionary-order      공백, 알파벳, 숫자만을 고려합니다\n"
"  -f, --ignore-case           대소문자를 구별하지 않습니다\n"

#: src/sort.c:440
msgid ""
"  -g, --general-numeric-sort  compare according to general numerical value\n"
"  -i, --ignore-nonprinting    consider only printable characters\n"
"  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n"
msgstr ""
"  -g, --general-numeric-sort  일반적인 수치 값에 따라 비교합니다\n"
"  -i, --ignore-nonprinting    표시 가능한 문자만 고려합니다\n"
"  -M, --month-sort            (그외) < '1월' < ... < '12월'의 순서대로 비교\n"

#: src/sort.c:445
msgid ""
"  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n"
msgstr "  -h, --human-numeric-sort    인지 가능한 숫자 비교(예: 2K 1G)\n"

#: src/sort.c:448
msgid ""
"  -n, --numeric-sort          compare according to string numerical value\n"
"  -R, --random-sort           shuffle, but group identical keys.  See "
"shuf(1)\n"
"      --random-source=FILE    get random bytes from FILE\n"
"  -r, --reverse               reverse the result of comparisons\n"
msgstr ""
"  -n, --numeric-sort          문자열의 수치 값에 따라 비교합니다\n"
"  -R, --random-sort           뒤섞되, 그룹 식별키를 부여합니다.  shuf(1) 참"
"고\n"
"      --random-source=<파일>    <파일>에서 임의 바이트를 가져옵니다\n"
"  -r, --reverse               비교의 결과를 뒤바꿉니다\n"

#: src/sort.c:454
msgid ""
"      --sort=WORD             sort according to WORD:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          natural sort of (version) numbers within text\n"
"\n"
msgstr ""
"      --sort=<단어>             <단어>에 따라 정렬합니다. 해당 값:\n"
"                                general-numeric -g, human-numeric -h, month -"
"M,\n"
"                                numeric -n, random -R, version -V\n"
"  -V, --version-sort          텍스트 내의 (버전) 번호를 자연스레 정렬합니다\n"
"\n"

#: src/sort.c:462
msgid ""
"Other options:\n"
"\n"
msgstr ""
"기타 옵션:\n"
"\n"

#: src/sort.c:466
msgid ""
"      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n"
"                            for more use temp files\n"
msgstr ""
"      --batch-size=<병합횟수>   <병합횟수> 만큼의 입력을 한번에 병합하며\n"
"                            더 많은 병합작업을 위해 임시 파일을 활용합니다\n"

#: src/sort.c:470
msgid ""
"  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n"
"  -C, --check=quiet, --check=silent  like -c, but do not report first bad "
"line\n"
"      --compress-program=PROG  compress temporaries with PROG;\n"
"                              decompress them with PROG -d\n"
msgstr ""
"  -c, --check, --check=diagnose-first  정렬 입력을 검사합니다. 정렬하지 않"
"음\n"
"  -C, --check=quiet, --check=silent  -c와 유사하나, 처음 불량 행은 보고하지않"
"습니다\n"
"      --compress-program=<프로그램>  <프로그램>으로 임시 요소를 압축합니다\n"
"                              압축 해제는 <프로그램> -d 명령으로 처리합니다\n"

#: src/sort.c:477
msgid ""
"      --debug               annotate the part of the line used to sort,\n"
"                              and warn about questionable usage to stderr\n"
"      --files0-from=F       read input from the files specified by\n"
"                            NUL-terminated names in file F;\n"
"                            If F is - then read names from standard input\n"
msgstr ""
"      --debug               정렬에 활용한 행 부분을 설명하며,\n"
"                              의문점이 생긴 부분은 표준 출력으로 경고합니다\n"
"      --files0-from=<파일>  <파일>에서 NUL 종단 지정한 파일 이름을 읽어들입니"
"다\n"
"                            <파일>이 - 이면 표준 입력의 이름을 읽습니다\n"

#: src/sort.c:484
msgid ""
"  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n"
"  -m, --merge               merge already sorted files; do not sort\n"
msgstr ""
"  -k, --key=<키정의>        키 순서로 정렬. <키정의>는 위치, 형식 정보를 제공"
"합니다\n"
"  -m, --merge               이미 정렬한 파일을 병합합니다. 정렬하지 않음\n"

# last-resort comparison?
#: src/sort.c:488
msgid ""
"  -o, --output=FILE         write result to FILE instead of standard output\n"
"  -s, --stable              stabilize sort by disabling last-resort "
"comparison\n"
"  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n"
msgstr ""
"  -o, --output=<파일>       결과를 표준 출력 대신에 <파일>에 씁니다\n"
"  -s, --stable              마지막-재정렬 비교과정을 없애 정렬을 안정화합니"
"다\n"
"  -S, --buffer-size=<크기>  메인 메모리 버퍼를 <크기>만큼 씁니다\n"

#: src/sort.c:494
#, c-format
msgid ""
"  -t, --field-separator=SEP  use SEP instead of non-blank to blank "
"transition\n"
"  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or "
"%s;\n"
"                              multiple options specify multiple directories\n"
"      --parallel=N          change the number of sorts run concurrently to "
"N\n"
"  -u, --unique              with -c, check for strict ordering;\n"
"                              without -c, output only the first of an equal "
"run\n"
msgstr ""
"  -t, --field-separator=<구분>  공백을 (빈 칸으로 바꾸는 대신) <구분>으로 바"
"꿈\n"
"  -T, --temporary-directory=DIR  임시 파일에 $TMPDIR이나 %s 대신 <디렉터리>"
"를\n"
"                              사용합니다. 옵션 여러 개는 여러 개 디렉터리를 "
"지정\n"
"      --parallel=<개수>     동시에 실행할 여러 정렬 프로그램 수를 <개수>개로 "
"지정합니다\n"
"  -u, --unique              -c 옵션 추가: 엄격한 순서를 검사합니다\n"
"                              -c 옵션 제외: 동일한 내용 중 첫 번째만 출력합니"
"다\n"

#: src/sort.c:508
msgid ""
"\n"
"KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is "
"a\n"
"field number and C a character position in the field; both are origin 1, "
"and\n"
"the stop position defaults to the line's end.  If neither -t nor -b is in\n"
"effect, characters in a field are counted from the beginning of the "
"preceding\n"
"whitespace.  OPTS is one or more single-letter ordering options "
"[bdfgiMhnRrV],\n"
"which override global ordering options for that key.  If no key is given, "
"use\n"
"the entire line as the key.  Use --debug to diagnose incorrect key usage.\n"
"\n"
"SIZE may be followed by the following multiplicative suffixes:\n"
msgstr ""
"\n"
"<키정의>는 시작, 끝 지점에 대해 F[.C][OPTS][,F[.C][OPTS]] 입니다.\n"
"F는 필드 번호, C는 필드의 문자 위치이며, 1부터 시작합니다. 그리고,\n"
"기본적으로 끝나는 위치는 줄의 끝에 있습니다. -t 또는 -b 둘 중 어느\n"
"하나 조차도 적용 효과가 없다면, 필드의 문자는 공백 문자를 하나 센 후\n"
"계수 처리합니다. OPTS는 하나 이상의 단일 문자 순서 지정 옵션으로\n"
"[bdfgiMhnRrV] 중 하나이며, 해당 키에 대한 기본 전역 정렬 옵션에 \n"
"우선합니다. 키를 제시하지 않으면, 전체 줄을 키로 취급합니다.\n"
"잘못된 키 사용 여부를 확인하려면 --debug 옵션을 사용하십시오.\n"
"\n"
"<크기> 다음에는 다음 곱하기 접미어가 따라올 수 있습니다:\n"

#: src/sort.c:521
msgid ""
"% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n"
"\n"
"*** WARNING ***\n"
"The locale specified by the environment affects sort order.\n"
"Set LC_ALL=C to get the traditional sort order that uses\n"
"native byte values.\n"
msgstr ""
"% 문자는 메모리의 1퍼센트, b는 1, k는 1024(기본값), 그 외에 M, G, T, P, E, "
"Z, Y가 있습니다.\n"
"\n"
"*** 경고 ***\n"
"환경 변수에 지정한 로캘이 정렬 순서에 영향을 줍니다.\n"
"바이트값에 따라 정렬하는 전통 방식을 원한다면\n"
"\"LC_ALL=C\"로 설정하십시오\n"

#: src/sort.c:719
#, c-format
msgid "waiting for %s [-d]"
msgstr "%s 기다리는 중 [-d]"

#: src/sort.c:724
#, c-format
msgid "%s [-d] terminated abnormally"
msgstr "%s [-d] 을(를) 비정상 중단했습니다"

#: src/sort.c:879
#, c-format
msgid "cannot create temporary file in %s"
msgstr "%s에 임시 파일을 만들 수 없습니다"

#: src/sort.c:994 src/sort.c:2106 src/sort.c:3224 src/sort.c:3867
#: src/sort.c:3958 src/sort.c:3961
msgid "open failed"
msgstr "열기 실패"

#: src/sort.c:1013
msgid "fflush failed"
msgstr "fflush 실패"

#: src/sort.c:1018 src/sort.c:2109 src/sort.c:4853
msgid "close failed"
msgstr "닫기 실패"

#: src/sort.c:1157
msgid "couldn't create temporary file"
msgstr "임시 파일을 만들 수 없습니다"

#: src/sort.c:1196
#, c-format
msgid "couldn't create process for %s -d"
msgstr "%s -d의 프로세스를 만들 수 없습니다"

#: src/sort.c:1269
#, c-format
msgid "warning: cannot remove: %s"
msgstr "경고: 제거할 수 없음: %s"

#: src/sort.c:1355
#, c-format
msgid "invalid --%s argument %s"
msgstr "부적절한 --%s 인자값 %s"

#: src/sort.c:1358
#, c-format
msgid "minimum --%s argument is %s"
msgstr "최소 --%s 인자값은 %s"

#: src/sort.c:1373
#, c-format
msgid "--%s argument %s too large"
msgstr "--%s 인자값 %s이(가) 너무 큽니다"

#: src/sort.c:1376
#, c-format
msgid "maximum --%s argument with current rlimit is %s"
msgstr "현재 rlimit 값을 사용하는 최대 --%s 인자는 %s 입니다"

#: src/sort.c:1458
msgid "number in parallel must be nonzero"
msgstr "병렬 처리 수가 0 이어서는 안됩니다"

#: src/sort.c:1541
msgid "stat failed"
msgstr "stat 실패"

#: src/sort.c:1804
msgid "read failed"
msgstr "읽기 실패"

#: src/sort.c:2124
#, c-format
msgid "string transformation failed"
msgstr "문자열 변환에 실패했습니다"

#: src/sort.c:2127
#, c-format
msgid "the untransformed string was %s"
msgstr "변환하지 않았던 문자열: %s"

#: src/sort.c:2290
#, c-format
msgid "^ no match for key\n"
msgstr "^ 키와 일치하지 않음\n"

#: src/sort.c:2474
#, c-format
msgid "obsolescent key %s used; consider %s instead"
msgstr "오래된 %s 키를 사용합니다. %s을(를) 대신 사용하십시오"

#: src/sort.c:2481
#, c-format
msgid "key %lu has zero width and will be ignored"
msgstr "%lu 키 길이가 0이어서 무시합니다"

#: src/sort.c:2490
#, c-format
msgid "leading blanks are significant in key %lu; consider also specifying 'b'"
msgstr ""
"빈 칸을 뒤에 붙인 %lu 키에 특별한 의미가 있습니다. 'b' 지정을 고려하십시오"

#: src/sort.c:2504
#, c-format
msgid "key %lu is numeric and spans multiple fields"
msgstr "%lu 키는 숫자키이며 다중 필드에 걸쳐있습니다"

#: src/sort.c:2539
#, c-format
msgid "field separator %s is treated as a group separator in numbers"
msgstr "%s 필드 구분 문자는 숫자 그룹 구분자로 취급합니다"

#: src/sort.c:2552
#, c-format
msgid "field separator %s is treated as a decimal point in numbers"
msgstr "%s 필드 구분 문자는 숫자 소숫점으로 취급합니다"

#: src/sort.c:2560
#, c-format
msgid "field separator %s is treated as a minus sign in numbers"
msgstr "%s 필드 구분 문자는 숫자 음수 기호로 취급합니다"

#: src/sort.c:2567
#, c-format
msgid "field separator %s is treated as a plus sign in numbers"
msgstr "%s 필드 구분 문자는 숫자 양수 기호로 취급합니다"

#: src/sort.c:2579
#, c-format
msgid "%snumbers use %s as a decimal point in this locale"
msgstr "이 로캘에서는 %s 숫자에 %s 문자를 소숫점으로 사용합니다"

#: src/sort.c:2580
msgid "note "
msgstr "참고 "

#: src/sort.c:2588
#, c-format
msgid "the multi-byte number group separator in this locale is not supported"
msgstr "이 로캘에서 멀티바이트 숫자 그룹 구분 문자를 지원하지 않습니다"

#: src/sort.c:2604
#, c-format
msgid "option '-%s' is ignored"
msgid_plural "options '-%s' are ignored"
msgstr[0] "'-%s' 옵션을 무시합니다"

#: src/sort.c:2610
#, c-format
msgid "option '-r' only applies to last-resort comparison"
msgstr "'-r' 옵션 동작은 최종 비교 동작에만 활용합니다"

#: src/sort.c:2884 src/sort.c:2893
msgid "write failed"
msgstr "쓰기 실패"

#: src/sort.c:2936
#, c-format
msgid "%s: %s:%s: disorder: "
msgstr "%s: %s:%s: 순서가 맞지 않음: "

#: src/sort.c:2939
msgid "standard error"
msgstr "표준 오류"

#: src/sort.c:3851
msgid "cannot read"
msgstr "읽을 수 없음"

#: src/sort.c:4125
#, c-format
msgid "%s: invalid field specification %s"
msgstr "%s: 부적절한 필드 지정 %s"

#: src/sort.c:4134
#, c-format
msgid "options '-%s' are incompatible"
msgstr "'-%s' 옵션은 호환성이 없습니다"

# count?
#: src/sort.c:4184
#, c-format
msgid "%s: invalid count at start of %s"
msgstr "%s: %s 시작 부분에 부적절한 갯수"

#: src/sort.c:4445
msgid "invalid number after '-'"
msgstr "`-' 다음 부적절한 숫자"

#: src/sort.c:4452 src/sort.c:4538 src/sort.c:4566
msgid "invalid number after '.'"
msgstr "`.' 다음 부적절한 숫자"

#: src/sort.c:4465 src/sort.c:4571
msgid "stray character in field spec"
msgstr "필드 스펙에 벗어난 문자"

#: src/sort.c:4512
msgid "multiple compress programs specified"
msgstr "다중 압축 프로그램을 지정했습니다"

#: src/sort.c:4529
msgid "invalid number at field start"
msgstr "필드 처음에 부적절한 숫자"

#: src/sort.c:4533 src/sort.c:4561
msgid "field number is zero"
msgstr "필드 개수가 0입니다"

#: src/sort.c:4542
msgid "character offset is zero"
msgstr "문자 오프셋이 0입니다"

#: src/sort.c:4557
msgid "invalid number after ','"
msgstr "`,' 다음 부적절한 숫자"

#: src/sort.c:4607
msgid "empty tab"
msgstr "빈 탭"

#: src/sort.c:4690 src/wc.c:891
#, c-format
msgid "cannot read file names from %s"
msgstr "%s에서 파일 이름을 읽을 수 없습니다"

#: src/sort.c:4712
#, c-format
msgid "%s:%lu: invalid zero-length file name"
msgstr "%s:%lu: 부적절한 0 길이 파일 이름"

#: src/sort.c:4718
#, c-format
msgid "no input from %s"
msgstr "%s 입력 없음"

#: src/sort.c:4771
#, c-format
msgid "text ordering performed using %s sorting rules"
msgstr "%s 정렬 규칙으로 텍스트 정렬을 수행했습니다"

#: src/sort.c:4775
msgid "text ordering performed using simple byte comparison"
msgstr "단순 바이트 비교 방식으로 텍스트 정렬을 수행했습니다"

# extra operand? 뭔 소리야?
#: src/sort.c:4807
#, c-format
msgid "extra operand %s not allowed with -%c"
msgstr "추가 피연산자 %s은(는) -%c와(과) 혼용할 수 없습니다"

#: src/split.c:210
#, c-format
msgid "the suffix length needs to be at least %<PRIuMAX>"
msgstr "접미사 길이는 최소한 %<PRIuMAX>(이)여야 합니다"

#: src/split.c:227
#, c-format
msgid "Usage: %s [OPTION]... [FILE [PREFIX]]\n"
msgstr "사용법: %s [<옵션>]... [<파일>[<접두어>]]\n"

#: src/split.c:231
msgid ""
"Output pieces of FILE to PREFIXaa, PREFIXab, ...;\n"
"default size is 1000 lines, and default PREFIX is 'x'.\n"
msgstr ""
"<파일> 일부를 <접미사>aa, <접미사>ab, ... 처럼 출력합니다.\n"
"기본 크기는 1000줄이며, 기본 <접미사>는 'x' 입니다.\n"

#: src/split.c:239
#, c-format
msgid ""
"  -a, --suffix-length=N   generate suffixes of length N (default %d)\n"
"      --additional-suffix=SUFFIX  append an additional SUFFIX to file names\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of records per output file\n"
"  -d                      use numeric suffixes starting at 0, not "
"alphabetic\n"
"      --numeric-suffixes[=FROM]  same as -d, but allow setting the start "
"value\n"
"  -x                      use hex suffixes starting at 0, not alphabetic\n"
"      --hex-suffixes[=FROM]  same as -x, but allow setting the start value\n"
"  -e, --elide-empty-files  do not generate empty output files with '-n'\n"
"      --filter=COMMAND    write to shell COMMAND; file name is $FILE\n"
"  -l, --lines=NUMBER      put NUMBER lines/records per output file\n"
"  -n, --number=CHUNKS     generate CHUNKS output files; see explanation "
"below\n"
"  -t, --separator=SEP     use SEP instead of newline as the record "
"separator;\n"
"                            '\\0' (zero) specifies the NUL character\n"
"  -u, --unbuffered        immediately copy input to output with '-n r/...'\n"
msgstr ""
"  -a, --suffix-length=<숫자>   <숫자> 길이의 접미사를 생성합니다(기본 %d문"
"자)\n"
"      --additional-suffix=<접미사>  파일 이름에 추가 <접미사>를 붙입니다\n"
"  -b, --bytes=<크기>        출력 파일 별 <크기> 바이트를 기록합니다\n"
"  -C, --line-bytes=<크기>   출력 파일 별 레코드당 <크기> 바이트를 기록합니"
"다\n"
"  -d                      숫자 접미사를 알파벳이 아닌 0에서 시작합니다\n"
"      --numeric-suffixes[=<시작>]  -d와 같지만 시작 값 설정을 허용합니다\n"
"  -x                      16진수 접미사를 알파벳이 아닌 0에서 시작합니다\n"
"      --hex-suffixes[=<시작>]  -x와 같지만 시작 값 설정을 허용합니다\n"
"  -e, --elide-empty-files  '-n' 옵션으로 빈 출력 파일을 생성하지 않습니다\n"
"      --filter=<명령>    셸 <명령>에 기록합니다. 파일 이름은 $FILE로 설정합니"
"다\n"
"  -l, --lines=<숫자>      출력 파일 별로 <숫자> 행/레코드 만큼 기록합니다\n"
"  -n, --number=<청크>     <청크> 출력 파일을 만듭니다. 하단 설명 참조\n"
"  -t, --separator=<구분자>     레코드 구분자인 개행 문자 대신 <구분자>를 사용"
"합니다\n"
"                            '\\0'(영)은 NUL 문자를 지정합니다\n"
"  -u, --unbuffered        '-n r/...' 옵션을 통해 입력을 즉시 출력으로 복사합"
"니다.\n"

#: src/split.c:257
msgid ""
"      --verbose           print a diagnostic just before each\n"
"                            output file is opened\n"
msgstr ""
"      --verbose           각 출력 파일을 열기 전 확인 내용을 \n"
"                            출력합니다\n"
"\n"

#: src/split.c:264
msgid ""
"\n"
"CHUNKS may be:\n"
"  N       split into N files based on size of input\n"
"  K/N     output Kth of N to stdout\n"
"  l/N     split into N files without splitting lines/records\n"
"  l/K/N   output Kth of N to stdout without splitting lines/records\n"
"  r/N     like 'l' but use round robin distribution\n"
"  r/K/N   likewise but only output Kth of N to stdout\n"
msgstr ""
"\n"
"다음 값을 <청크> 값으로 쓸 수 있습니다:\n"
"  <개수>       입력 크기에 따라 <개수>개 파일로 나눕니다\n"
"  <서수>/<개수>     <개수>개의 <서수>번째 출력을 표준 출력으로 내보냅니다\n"
"  l/<개수>     행/레코드로 나누지 않고 <개수>개 파일로 나눕니다\n"
"  l/<서수>/<개수>   행/레코드로 나누지 않고 <개수>개의 <서수>번째 출력을 표"
"준 출력으로 내보냅니다\n"
"  r/<개수>     'l'과 유사하나 라운드 로빈 방식을 사용합니다\n"
"  r/<서수>/<개수>   위와 마찬가지지만 <개수>개의 <서수> 번째 출력 만을 표준 "
"출력으로 내보냅니다\n"

#: src/split.c:451
msgid "output file suffixes exhausted"
msgstr "출력 파일 접미어가 바닥났습니다"

#: src/split.c:463
#, c-format
msgid "creating file %s\n"
msgstr "%s 파일 만드는 중\n"

#: src/split.c:472
#, c-format
msgid "%s would overwrite input; aborting"
msgstr "%s이(가) 입력을 덮어씁니다. 중지하는 중"

#: src/split.c:489
msgid "failed to set FILE environment variable"
msgstr "FILE 환경 변수 설정 실패"

#: src/split.c:491
#, c-format
msgid "executing with FILE=%s\n"
msgstr "FILE=%s(으)로 실행\n"

#: src/split.c:493
msgid "failed to create pipe"
msgstr "파이프 만들기 실패"

#: src/split.c:507
msgid "closing prior pipe"
msgstr "이전 파이프 닫는 중"

#: src/split.c:509
msgid "closing output pipe"
msgstr "출력 파이프 닫는 중"

#: src/split.c:513
msgid "moving input pipe"
msgstr "입력 파이프 이동"

#: src/split.c:515
msgid "closing input pipe"
msgstr "입력 파이프 닫는 중"

#: src/split.c:520
#, c-format
msgid "failed to run command: \"%s -c %s\""
msgstr "명령 실행 실패: \"%s -c %s\""

#: src/split.c:526
msgid "failed to close input pipe"
msgstr "입력 파이프 닫기 실패"

#: src/split.c:562
msgid "waiting for child process"
msgstr "하위 프로세스 기다리는 중"

#: src/split.c:572
#, c-format
msgid "with FILE=%s, signal %s from command: %s"
msgstr "FILE=%s일 때, 명령에서 나온 시그널 %s: %s"

#: src/split.c:580
#, c-format
msgid "with FILE=%s, exit %d from command: %s"
msgstr "FILE=%s일 때, 명령에서 나온 종료 코드 %d: %s"

#: src/split.c:587
#, c-format
msgid "unknown status from command (0x%X)"
msgstr "명령에서 알 수 없는 상태 반환 (0x%X)"

#: src/split.c:1279
#, c-format
msgid "cannot split in more than one way"
msgstr "한 가지 이상의 방법으로 분할할 수 없습니다"

#: src/split.c:1291 src/split.c:1406 src/split.c:1606
msgid "invalid number of chunks"
msgstr "부적절한 청크 갯수"

#: src/split.c:1296
msgid "invalid chunk number"
msgstr "부적절한 청크 번호"

#: src/split.c:1343
msgid "invalid suffix length"
msgstr "부적절한 접미사 길이"

#: src/split.c:1417
msgid "empty record separator"
msgstr "빈 레코드 구분자"

#: src/split.c:1428
#, c-format
msgid "multi-character separator %s"
msgstr "다중 문자 구분자 %s"

#: src/split.c:1436
msgid "multiple separator characters specified"
msgstr "다중 구분자 문자를 지정했습니다"

#: src/split.c:1467
#, c-format
msgid "line count option -%s%c... is too large"
msgstr "행 계수 옵션 값 -%s%c...이 너무 큽니다"

#: src/split.c:1484
#, c-format
msgid "%s: invalid start value for numerical suffix"
msgstr "%s: 숫자 접미사에 부적절한 시작 값"

#: src/split.c:1485
#, c-format
msgid "%s: invalid start value for hexadecimal suffix"
msgstr "%s: 16진수 접미사에 잘못된 시작값"

#: src/split.c:1509
msgid "invalid IO block size"
msgstr "부적절한 입출력 블록 크기"

#: src/split.c:1527
#, c-format
msgid "--filter does not process a chunk extracted to stdout"
msgstr ""
"--filter 옵션은 표준 출력으로 청크를 추출하는 프로세스를 수행하지 않습니다"

#: src/split.c:1567
#, c-format
msgid "numerical suffix start value is too large for the suffix length"
msgstr "숫자 접미사 시작 값이 접미사 길이에 비해 큽니다"

#: src/split.c:1598
#, c-format
msgid "%s: cannot determine file size"
msgstr "%s: 파일 크기를 알 수 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/stat.c:198
msgid "Michael Meskes"
msgstr "Michael Meskes"

#: src/stat.c:1007
#, c-format
msgid "failed to canonicalize %s"
msgstr "%s 정규화 실패"

#: src/stat.c:1110
#, c-format
msgid "warning: unrecognized escape '\\%c'"
msgstr "경고: 인식할 수 없는 이스케이프'\\%c'"

#: src/stat.c:1174
#, c-format
msgid "%s: invalid directive"
msgstr "%s: 부적절한 지시자"

#: src/stat.c:1236
#, c-format
msgid "warning: backslash at end of format"
msgstr "경고: 형 지정자 뒤 역슬래시"

#: src/stat.c:1268
#, c-format
msgid "using %s to denote standard input does not work in file system mode"
msgstr ""
"표준 입력을 나타내려 사용한 %s 옵션은 파일 시스템 모드에서 동작하지 않습니다"

#: src/stat.c:1275
#, c-format
msgid "cannot read file system information for %s"
msgstr "%s의 파일 시스템 정보를 읽을 수 없습니다"

#: src/stat.c:1404 src/stat.c:1472
#, c-format
msgid "cannot stat standard input"
msgstr "표준 입력으로 상태 정보 전달 불가"

#: src/stat.c:1406
#, c-format
msgid "cannot statx %s"
msgstr "%s에 statx 처리할 수 없음"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' with --file-system, and NOT from printf.
#: src/stat.c:1667
msgid ""
"  File: \"%n\"\n"
"    ID: %-8i Namelen: %-7l Type: %T\n"
"Block size: %-10s Fundamental block size: %S\n"
"Blocks: Total: %-10b Free: %-10f Available: %a\n"
"Inodes: Total: %-10c Free: %d\n"
msgstr ""
"  파일: \"%n\"\n"
"    ID: %-8i 이름 길이: %-7l 형식: %T\n"
"블록 크기: %-10s 기본 블록 크기: %S\n"
"블록: 전체: %-10b 여유: %-10f 가용: %a\n"
"아이노드: 전체: %-10c 여유: %d\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1688
msgid ""
"  File: %N\n"
"  Size: %-10s\tBlocks: %-10b IO Block: %-6o %F\n"
msgstr ""
"  파일: %N\n"
"  크기: %-10s\t블록: %-10b 입출력 블록: %-6o %F\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1698
msgid "Device: %Hd,%Ld\tInode: %-10i  Links: %-5h Device type: %Hr,%Lr\n"
msgstr "장치: %Hd,%Ld\t아이노드: %-10i  링크: %-5h 장치 형식: %Hr,%Lr\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1706
msgid "Device: %Hd,%Ld\tInode: %-10i  Links: %h\n"
msgstr "장치: %Hd,%Ld\t아이노드: %-10i  링크: %h\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1715
msgid "Access: (%04a/%10.10A)  Uid: (%5u/%8U)   Gid: (%5g/%8G)\n"
msgstr "접근: (%04a/%10.10A)  UID: (%5u/%8U)   GID: (%5g/%8G)\n"

#. TRANSLATORS: This string uses format specifiers from
#. 'stat --help' without --file-system, and NOT from printf.
#: src/stat.c:1725
#, c-format
msgid "Context: %C\n"
msgstr "컨텍스트: %C\n"

#: src/stat.c:1733
msgid ""
"Access: %x\n"
"Modify: %y\n"
"Change: %z\n"
" Birth: %w\n"
msgstr ""
"접근: %x\n"
"수정: %y\n"
"변경: %z\n"
"생성: %w\n"

#: src/stat.c:1751
msgid "Display file or file system status.\n"
msgstr "파일 또는 파일 시스템 상태를 표시합니다.\n"

#: src/stat.c:1757
msgid ""
"  -L, --dereference     follow links\n"
"  -f, --file-system     display file system status instead of file status\n"
msgstr ""
"  -L, --dereference     링크를 따라갑니다\n"
"  -f, --file-system     파일 상태 대신 파일 시스테 상태를 나타냅니다\n"

#: src/stat.c:1761
msgid ""
"      --cached=MODE     specify how to use cached attributes;\n"
"                          useful on remote file systems. See MODE below\n"
msgstr ""
"      --cached=<모드>   캐시 속성 활용 방법을 지정합니다\n"
"                          원격 파일 시스템에 요긴합니다. 하단 <모드> 참조\n"

#: src/stat.c:1765
msgid ""
"  -c  --format=FORMAT   use the specified FORMAT instead of the default;\n"
"                          output a newline after each use of FORMAT\n"
"      --printf=FORMAT   like --format, but interpret backslash escapes,\n"
"                          and do not output a mandatory trailing newline;\n"
"                          if you want a newline, include \\n in FORMAT\n"
"  -t, --terse           print the information in terse form\n"
msgstr ""
"  -c  --format=<형식>   기본 설정 대신 지정 <형식>을 사용합니다\n"
"                          각 <형식> 사용 후 개행 문자를 출력합니다\n"
"      --printf=<형식>   --format 옵션과 유사하나, 역슬래시 이스케이프를\n"
"                          해석하며 필수 마침 개행 문자를 출력하지 않습니다.\n"
"                          개행 문자를 출력하려면 <형식>에 \\n을 넣으십시오\n"
"  -t, --terse           terse 양식 정보를 출력합니다\n"

#: src/stat.c:1776
msgid ""
"\n"
"The MODE argument of --cached can be: always, never, or default.\n"
"'always' will use cached attributes if available, while\n"
"'never' will try to synchronize with the latest attributes, and\n"
"'default' will leave it up to the underlying file system.\n"
msgstr ""
"\n"
"--cached <모드> 인자는 always, never, default가 될 수 있습니다.\n"
"`always` 가용 상태일 동안 캐시 속성을 계속 활용합니다.\n"
"`never` 최근 속성대로 동기화를 시도합니다.\n"
"`default` 파일 시스템에 따라 그대로 동작합니다.\n"

#: src/stat.c:1783
msgid ""
"\n"
"The valid format sequences for files (without --file-system):\n"
"\n"
"  %a   permission bits in octal (note '#' and '0' printf flags)\n"
"  %A   permission bits and file type in human readable form\n"
"  %b   number of blocks allocated (see %B)\n"
"  %B   the size in bytes of each block reported by %b\n"
"  %C   SELinux security context string\n"
msgstr ""
"\n"
"적절한 파일 대응 형식 시퀀스는 다음과 같습니다(--file-system 제외):\n"
"\n"
"  %a   8진수 권한 비트 표시 ('#'과 '0' printf 플래그 표시)\n"
"  %A   가독 형식의 권한 비트와 파일 형식\n"
"  %b   할당 블록 수 (%B 참고)\n"
"  %B   %b에서 보고한 각 블록의 바이트 단위 크기\n"
"  %C   SELinux 보안 컨텍스트 문자열\n"

#: src/stat.c:1792
msgid ""
"  %d   device number in decimal (st_dev)\n"
"  %D   device number in hex (st_dev)\n"
"  %Hd  major device number in decimal\n"
"  %Ld  minor device number in decimal\n"
"  %f   raw mode in hex\n"
"  %F   file type\n"
"  %g   group ID of owner\n"
"  %G   group name of owner\n"
msgstr ""
"  %d   10진수 장치 번호 (st_dev)\n"
"  %D   16진수 장치 번호 (st_dev)\n"
"  %Hd  10진수 주 장치 번호\n"
"  %Ld  10진수 부 장치 번호\n"
"  %f   16진수 RAW 모드\n"
"  %F   파일 형식\n"
"  %g   소유 그룹 ID\n"
"  %G   소유 그룹 이름\n"

#: src/stat.c:1802
msgid ""
"  %h   number of hard links\n"
"  %i   inode number\n"
"  %m   mount point\n"
"  %n   file name\n"
"  %N   quoted file name with dereference if symbolic link\n"
"  %o   optimal I/O transfer size hint\n"
"  %s   total size, in bytes\n"
"  %r   device type in decimal (st_rdev)\n"
"  %R   device type in hex (st_rdev)\n"
"  %Hr  major device type in decimal, for character/block device special "
"files\n"
"  %Lr  minor device type in decimal, for character/block device special "
"files\n"
"  %t   major device type in hex, for character/block device special files\n"
"  %T   minor device type in hex, for character/block device special files\n"
msgstr ""
"  %h   하드 링크 갯수\n"
"  %i   아이노드 번호\n"
"  %m   마운트 지점\n"
"  %n   파일 이름\n"
"  %N   심볼릭 링크일 때 역참조할 따옴표 처리 파일 이름\n"
"  %o   최적 입출력 전송 크기 힌트\n"
"  %s   바이트 단위 전체 크기\n"
"  %r   10진수 장치 형식 번호 (st_rdev)\n"
"  %R   16진수 장치 형식 번호 (st_rdev)\n"
"  %Hr  문자/블록 장치 특수 파일용 10진수 주 장치 형식 번호\n"
"  %Lr  문자/블록 장치 특수 파일용 16진수 부 장치 형식 번호\n"
"  %t   문자/블록 장치 특수 파일용 16진수 주 장치 형식 번호\n"
"  %T   문자/블록 장치 특수 파일용 16진수 부 장치 형식 번호\n"

#: src/stat.c:1817
msgid ""
"  %u   user ID of owner\n"
"  %U   user name of owner\n"
"  %w   time of file birth, human-readable; - if unknown\n"
"  %W   time of file birth, seconds since Epoch; 0 if unknown\n"
"  %x   time of last access, human-readable\n"
"  %X   time of last access, seconds since Epoch\n"
"  %y   time of last data modification, human-readable\n"
"  %Y   time of last data modification, seconds since Epoch\n"
"  %z   time of last status change, human-readable\n"
"  %Z   time of last status change, seconds since Epoch\n"
"\n"
msgstr ""
"  %u   소유 사용자 ID\n"
"  %U   소유 사용자 이름\n"
"  %w   가독성 있는 파일 생성 시각.알 수 없을 경우 -\n"
"  %W   에포크 일시 이후 파일 생성 초 시각. 알 수 없을 경우 0\n"
"  %x   가독성 있는 최종 접근 시각\n"
"  %X   에포크 일시 이후 최종 접근 시각\n"
"  %y   가독성 있는 데이터 최종 수정 시각\n"
"  %Y   에포크 일시 이후 데이터 최종 수정 초 시각\n"
"  %z   가독성 있는 최종 상태 변경 시각\n"
"  %Z   에포크 일시 이후 최종 상태 변경 초 시각\n"
"\n"

#: src/stat.c:1831
msgid ""
"Valid format sequences for file systems:\n"
"\n"
"  %a   free blocks available to non-superuser\n"
"  %b   total data blocks in file system\n"
"  %c   total file nodes in file system\n"
"  %d   free file nodes in file system\n"
"  %f   free blocks in file system\n"
msgstr ""
"파일 시스템에 적절한 형식 시퀀스는 다음과 같습니다:\n"
"\n"
"  %a   비 수퍼유저 가용 여분 블록\n"
"  %b   파일 시스템 총 데이터 블록 수\n"
"  %c   파일 시스템 총 파일 노드 수\n"
"  %d   파일 시스템 가용 파일 노드 수\n"
"  %f   파일 시스템 가용 블록 수\n"

#: src/stat.c:1840
msgid ""
"  %i   file system ID in hex\n"
"  %l   maximum length of filenames\n"
"  %n   file name\n"
"  %s   block size (for faster transfers)\n"
"  %S   fundamental block size (for block counts)\n"
"  %t   file system type in hex\n"
"  %T   file system type in human readable form\n"
msgstr ""
"  %i   16진수 파일 시스템 ID\n"
"  %l   파일 이름 최대 길이\n"
"  %n   파일 이름\n"
"  %s   블록 크기 (고속 전송용)\n"
"  %S   기본 블록 크기 (블록 계수용)\n"
"  %t   파일 시스템 형식 16진수 표기\n"
"  %T   가독 형식 파일 시스템 형식\n"

#: src/stat.c:1850
#, c-format
msgid ""
"\n"
"--terse is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"\n"
"--terse 옵션은 다음<형식> 과 동일합니다:\n"
"    %s"

#: src/stat.c:1861
#, c-format
msgid ""
"--terse --file-system is equivalent to the following FORMAT:\n"
"    %s"
msgstr ""
"--terse --file-system 옵션은 다음 <형식>과 동일합니다:\n"
"    %s"

#: src/stdbuf.c:91
#, c-format
msgid "Usage: %s OPTION... COMMAND\n"
msgstr "사용법: %s <옵션>... <명령>\n"

#: src/stdbuf.c:92
msgid ""
"Run COMMAND, with modified buffering operations for its standard streams.\n"
msgstr "표준 스트림에 대해 버퍼링 수정 처리 동작을 하는 <명령>을 실행합니다.\n"

#: src/stdbuf.c:98
msgid ""
"  -i, --input=MODE   adjust standard input stream buffering\n"
"  -o, --output=MODE  adjust standard output stream buffering\n"
"  -e, --error=MODE   adjust standard error stream buffering\n"
msgstr ""
"  -i, --input=<모드>   표준 입력 스트림 버퍼링을 조정합니다\n"
"  -o, --output=<모드>  표준 출력 스트림 버퍼링을 조정합니다\n"
"  -e, --error=<모드>   표준 오류 스트림 버퍼링을 조정합니다\n"

#: src/stdbuf.c:105
msgid ""
"\n"
"If MODE is 'L' the corresponding stream will be line buffered.\n"
"This option is invalid with standard input.\n"
msgstr ""
"\n"
"<모드>가 'L'이면 해당 스트림을 행단위 버퍼링 처리합니다.\n"
"이 옵션은 표준 입력에 적절하지 않습니다.\n"

#: src/stdbuf.c:108
msgid ""
"\n"
"If MODE is '0' the corresponding stream will be unbuffered.\n"
msgstr ""
"\n"
"<모드>가 '0' 이면 해당 스트림을 버퍼링하지 않습니다.\n"

#: src/stdbuf.c:111
msgid ""
"\n"
"Otherwise MODE is a number which may be followed by one of the following:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"In this case the corresponding stream will be fully buffered with the "
"buffer\n"
"size set to MODE bytes.\n"
msgstr ""
"\n"
"그 외에, <모드>에는 다음 중 하나가 따라올 수 있는 숫자입니다:\n"
"KB 1000, K 1024, MB 1000*1000, M 1024*1024, 그리고 T, P, E, Z, Y에도 마찬가지"
"입니다.\n"
"이진 접미사의 경우 마찬가지입니다. KiB=K, MiB=M, 등과 같습니다.\n"
"이 경우 해당 스트림은 <모드> 바이트 크기 버퍼로 완전히 버퍼링 처리합니다.\n"
"\n"

#: src/stdbuf.c:118
msgid ""
"\n"
"NOTE: If COMMAND adjusts the buffering of its standard streams ('tee' does\n"
"for example) then that will override corresponding changes by 'stdbuf'.\n"
"Also some filters (like 'dd' and 'cat' etc.) don't use streams for I/O,\n"
"and are thus unaffected by 'stdbuf' settings.\n"
msgstr ""
"\n"
"참고: <명령>이 표준 스트림 버퍼링을 조정한다면 (예를 들면 'tee'의 동작)\n"
"'stdbuf'를 통해 해당 명령 실행의 동작 설정을 덮어쓸 수 있습니다.\n"
"또한 일부 필터('dd', 'cat', 등)는 입출력에 스트림을 사용하지 않기에\n"
"'stdbuf' 설정의 영향을 받지 않습니다.\n"

#: src/stdbuf.c:243
#, c-format
msgid "failed to find %s"
msgstr "%s 찾기 실패"

#: src/stdbuf.c:267 src/stdbuf.c:300
#, c-format
msgid "failed to update the environment with %s"
msgstr "%s 환경 업데이트 실패"

#: src/stdbuf.c:346
#, c-format
msgid "line buffering stdin is meaningless"
msgstr "행 버퍼링 표준 입력은 의미가 없습니다"

#: src/stdbuf.c:377
#, c-format
msgid "you must specify a buffering mode option"
msgstr "버퍼링 모드 옵션을 지정해야 합니다"

#: src/stty.c:529
#, c-format
msgid ""
"Usage: %s [-F DEVICE | --file=DEVICE] [SETTING]...\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-a|--all]\n"
"  or:  %s [-F DEVICE | --file=DEVICE] [-g|--save]\n"
msgstr ""
"사용법: %s [-F <장치> | --file=<장치>] [<설정>]...\n"
"  또는:  %s [-F <장치> | --file=<장치>] [-a|--all]\n"
"  또는:  %s [-F <장치> | --file=<장치>] [-g|--save]\n"

#: src/stty.c:535
msgid "Print or change terminal characteristics.\n"
msgstr "터미널 특징을 출력하거나 바꿉니다.\n"

#: src/stty.c:541
msgid ""
"  -a, --all          print all current settings in human-readable form\n"
"  -g, --save         print all current settings in a stty-readable form\n"
"  -F, --file=DEVICE  open and use the specified DEVICE instead of stdin\n"
msgstr ""
"  -a, --all          모든 설정을 가독 형식으로 출력합니다\n"
"  -g, --save         모든 설정을 stty 인식 가능 형식으로 출력합니다\n"
"  -F, --file=<장치>  표준 입력 대신 지정 <장치>를 열어 활용합니다\n"

#: src/stty.c:548
msgid ""
"\n"
"Optional - before SETTING indicates negation.  An * marks non-POSIX\n"
"settings.  The underlying system defines which settings are available.\n"
msgstr ""
"\n"
"설정 앞의 추가 - 표기는 반전을 의미합니다.   * 표시는 비 POSIX 방식 설정\n"
"입니다.  기반 시스템에서는 어떤 설정을 사용할 수 있는지를 정의합니다.\n"

#: src/stty.c:553
msgid ""
"\n"
"Special characters:\n"
msgstr ""
"\n"
"특수 문자:\n"

#: src/stty.c:557
msgid " * discard CHAR  CHAR will toggle discarding of output\n"
msgstr " * discard <문자>  <문자>를 출력에서 제외할 지 여부를 전환합니다\n"

#: src/stty.c:562
msgid ""
" * dsusp CHAR    CHAR will send a terminal stop signal once input flushed\n"
msgstr ""
" * dsusp <문자>    입력을 소거하고 나면 <문자>를 터미널 중단 시그널로 보냅니"
"다\n"

#: src/stty.c:566
msgid ""
"   eof CHAR      CHAR will send an end of file (terminate the input)\n"
"   eol CHAR      CHAR will end the line\n"
msgstr ""
"   eof <문자>      <문자>로 파일 끝 문자를 보냅니다(입력 중단)\n"
"   eol <문자>      <문자>는 행의 끝이 됩니다\n"

#: src/stty.c:571
msgid " * eol2 CHAR     alternate CHAR for ending the line\n"
msgstr " * eol2 <문자>     행 종결 문자를 <문자> 대체\n"

#: src/stty.c:575
msgid ""
"   erase CHAR    CHAR will erase the last character typed\n"
"   intr CHAR     CHAR will send an interrupt signal\n"
"   kill CHAR     CHAR will erase the current line\n"
msgstr ""
"   erase <문자>    <문자>로 마지막에 입력 문자를 지웁니다\n"
"   intr <문자>     <문자>로 인터럽트 시그널을 보냅니다\n"
"   kill <문자>     <문자>로 현재 행을 지웁니다\n"

#: src/stty.c:581
msgid " * lnext CHAR    CHAR will enter the next character quoted\n"
msgstr " * lnext <문자>    <문자>를 따옴표 처리한 다음 문자로 넣습니다\n"

#: src/stty.c:586
msgid " * status CHAR   CHAR will send an info signal\n"
msgstr " * status <문자>   <문자>로 정보 시그널을 보냅니다\n"

#: src/stty.c:590
msgid "   quit CHAR     CHAR will send a quit signal\n"
msgstr "   quit <문자>     <문자>로 끝내기 시그널을 보냅니다\n"

#: src/stty.c:594
msgid " * rprnt CHAR    CHAR will redraw the current line\n"
msgstr " * rprnt <문자>    <문자>로 현재 행을 다시 그립니다\n"

#: src/stty.c:598
msgid ""
"   start CHAR    CHAR will restart the output after stopping it\n"
"   stop CHAR     CHAR will stop the output\n"
"   susp CHAR     CHAR will send a terminal stop signal\n"
msgstr ""
"   start <문자>    <문자>로 정지후 출력을 다시 시작합니다\n"
"   stop <문자>     <문자>로 출력을 정지합니다\n"
"   susp <문자>     <문자>로 터미널 정지 시그널을 보냅니다\n"

#: src/stty.c:604
msgid " * swtch CHAR    CHAR will switch to a different shell layer\n"
msgstr " * swtch <문자>    <문자>로 다른 셸 계층으로 전환합니다\n"

#: src/stty.c:609
msgid " * werase CHAR   CHAR will erase the last word typed\n"
msgstr " * werase <문자>   <문자>로 가장 마지막에 입력한 단어를 지웁니다\n"

#: src/stty.c:613
msgid ""
"\n"
"Special settings:\n"
"   N             set the input and output speeds to N bauds\n"
msgstr ""
"\n"
"특수 설정:\n"
"   N             N 보(baud) 전송율로 입출력 속도를 설정\n"

#: src/stty.c:619
msgid ""
" * cols N        tell the kernel that the terminal has N columns\n"
" * columns N     same as cols N\n"
msgstr ""
" * cols <숫자>        커널에 터미널 열 길이 <숫자>를 알려줍니다\n"
" * columns <숫자>     cols <숫자>와 동일\n"

#: src/stty.c:624
#, c-format
msgid ""
" * [-]drain      wait for transmission before applying settings (%s by "
"default)\n"
msgstr " * [-]drain      설정 적용 전 전송을 기다립니다 (기본값: %s)\n"

#: src/stty.c:626
msgid "on"
msgstr "on"

#: src/stty.c:626
msgid "off"
msgstr "off"

#: src/stty.c:627
msgid "   ispeed N      set the input speed to N\n"
msgstr "   ispeed <숫자>      입력 속도를 <숫자>로 설정합니다\n"

#: src/stty.c:631
msgid " * line N        use line discipline N\n"
msgstr " * line N        회선 규정을 <숫자>로 활용합니다\n"

#: src/stty.c:635
msgid ""
"   min N         with -icanon, set N characters minimum for a completed "
"read\n"
"   ospeed N      set the output speed to N\n"
msgstr ""
"   min <숫자>     -icanon 옵션을 붙여, 완전히 읽어들이는 최소 <숫자> 문자수"
"를 지정합니다\n"
"   ospeed <숫자>  출력 속도를 <숫자>로 설정합니다\n"
"\n"

#: src/stty.c:640
msgid ""
" * rows N        tell the kernel that the terminal has N rows\n"
" * size          print the number of rows and columns according to the "
"kernel\n"
msgstr ""
" * rows <숫자>   커널에 터미널 행 갯수 <숫자>를 알려줍니다\n"
" * size          커널의 행렬 크기를 출력합니다\n"

#: src/stty.c:645
msgid ""
"   speed         print the terminal speed\n"
"   time N        with -icanon, set read timeout of N tenths of a second\n"
msgstr ""
"   speed         터미널 속도를 출력합니다\n"
"   time N        -icanon 옵션을 붙여, 10초 단위 <숫자> 읽기제한 시간을 설정합"
"니다\n"

#: src/stty.c:649
msgid ""
"\n"
"Control settings:\n"
"   [-]clocal     disable modem control signals\n"
"   [-]cread      allow input to be received\n"
msgstr ""
"\n"
"제어 설정:\n"
"   [-]clocal     모뎀 제어 신호 사용 안함\n"
"   [-]cread      수신 입력 허용\n"

#: src/stty.c:656
msgid " * [-]crtscts    enable RTS/CTS handshaking\n"
msgstr " * [-]crtscts    RTS/CTS 핸드셰이킹을 활성화합니다\n"

#: src/stty.c:661
msgid " * [-]cdtrdsr    enable DTR/DSR handshaking\n"
msgstr " * [-]cdtrdsr    DTR/DSR 핸드셰이킹을 활성화합니다\n"

#: src/stty.c:665
msgid "   csN           set character size to N bits, N in [5..8]\n"
msgstr ""
"   cs<숫자>      문자 크기를 <숫자> 비트 만큼 설정합니다. <숫자>는 5, 6, 7, "
"8\n"

#: src/stty.c:668
msgid ""
"   [-]cstopb     use two stop bits per character (one with '-')\n"
"   [-]hup        send a hangup signal when the last process closes the tty\n"
"   [-]hupcl      same as [-]hup\n"
"   [-]parenb     generate parity bit in output and expect parity bit in "
"input\n"
"   [-]parodd     set odd parity (or even parity with '-')\n"
msgstr ""
"   [-]cstopb     문자당 정지 비트 2개 사용(하나는 '-')\n"
"   [-]hup        마지막 프로세스에서 tty를 닫을 때 연결 끊기 시그널 보내기\n"
"   [-]hupcl      [-]hup과 동일\n"
"   [-]parenb     입력시 패리티 비트와 동일한 방식으로 출력 패리티 비트 생성\n"
"   [-]parodd     홀수 패리티 설정 (또는 '-'을 붙여 짝수 패리티 설정)\n"

#: src/stty.c:676
msgid " * [-]cmspar     use \"stick\" (mark/space) parity\n"
msgstr " * [-]cmspar     \"stick\" (마크/공백) 패리티 사용\n"

#: src/stty.c:680
msgid ""
"\n"
"Input settings:\n"
"   [-]brkint     breaks cause an interrupt signal\n"
"   [-]icrnl      translate carriage return to newline\n"
"   [-]ignbrk     ignore break characters\n"
"   [-]igncr      ignore carriage return\n"
"   [-]ignpar     ignore characters with parity errors\n"
msgstr ""
"\n"
"입력 설정:\n"
"   [-]brkint     중단 시그널을 내는 중단 입력\n"
"   [-]icrnl      캐리지 리턴을 개행 문자로 변환\n"
"   [-]ignbrk     중단 입력 무시\n"
"   [-]igncr      캐리지 리턴 무시\n"
"   [-]ignpar     패리티 오류 문자 무시\n"

#: src/stty.c:690
msgid ""
" * [-]imaxbel    beep and do not flush a full input buffer on a character\n"
msgstr ""
" * [-]imaxbel    비프음을 내고 문자에 대한 전체 입력 버퍼를 지우지 않음\n"

#: src/stty.c:694
msgid ""
"   [-]inlcr      translate newline to carriage return\n"
"   [-]inpck      enable input parity checking\n"
"   [-]istrip     clear high (8th) bit of input characters\n"
msgstr ""
"   [-]inlcr      개행 문자를 캐리지 리턴으로 변환\n"
"   [-]inpck      입력 패리티 검사 활성\n"
"   [-]istrip     입력 문자의 상위 (8번째) 비트 지우기\n"

#: src/stty.c:700
msgid " * [-]iutf8      assume input characters are UTF-8 encoded\n"
msgstr " * [-]iutf8      UTF-8 인코딩 입력 문자로 가정\n"

#: src/stty.c:705
msgid " * [-]iuclc      translate uppercase characters to lowercase\n"
msgstr " * [-]iuclc      대문자를 소문자로 변환\n"

#: src/stty.c:710
msgid ""
" * [-]ixany      let any character restart output, not only start character\n"
msgstr ""
" * [-]ixany      시작 문자 뿐만 아니라 임의의 문자출력도 다시 시작하게 함\n"

#: src/stty.c:714
msgid ""
"   [-]ixoff      enable sending of start/stop characters\n"
"   [-]ixon       enable XON/XOFF flow control\n"
"   [-]parmrk     mark parity errors (with a 255-0-character sequence)\n"
"   [-]tandem     same as [-]ixoff\n"
msgstr ""
"   [-]ixoff      시작/정지 문자 보내기 활성\n"
"   [-]ixon       XON/XOFF 흐름 제어 활성\n"
"   [-]parmrk     패리티 오류 표시(255-0-문자 시퀀스로)\n"
"   [-]tandem     [-]ixoff와 동일\n"

#: src/stty.c:720
msgid ""
"\n"
"Output settings:\n"
msgstr ""
"\n"
"출력 설정:\n"

#: src/stty.c:725
msgid " * bsN           backspace delay style, N in [0..1]\n"
msgstr " * bs<숫자>      백스페이스 지연 방식, <숫자>는 [0..1]\n"

#: src/stty.c:730
msgid " * crN           carriage return delay style, N in [0..3]\n"
msgstr " * cr<숫자>      캐리지 리턴 지연 방식, <숫자> 는 [0..3]\n"

#: src/stty.c:735
msgid " * ffN           form feed delay style, N in [0..1]\n"
msgstr " * ff<숫자>      폼 피드 지연 방식, <숫자> 는 [0..1]\n"

#: src/stty.c:740
msgid " * nlN           newline delay style, N in [0..1]\n"
msgstr " * nl<숫자>      개행 문자 지연 방식, <숫자> 는 [0..1]\n"

#: src/stty.c:745
msgid " * [-]ocrnl      translate carriage return to newline\n"
msgstr " * [-]ocrnl      캐리지 리턴을 개행 문자로 변환\n"

#: src/stty.c:750
msgid ""
" * [-]ofdel      use delete characters for fill instead of NUL characters\n"
msgstr " * [-]ofdel      채움 문자를 NUL 문자 대신 딜리트 문자 사용\n"

#: src/stty.c:755
msgid ""
" * [-]ofill      use fill (padding) characters instead of timing for delays\n"
msgstr " * [-]ofill      지연 시간동안 기다리는 대신 문자 (공간)채움\n"

#: src/stty.c:760
msgid " * [-]olcuc      translate lowercase characters to uppercase\n"
msgstr " * [-]olcuc      소문자를 대문자로 변환\n"

#: src/stty.c:765
msgid " * [-]onlcr      translate newline to carriage return-newline\n"
msgstr " * [-]onlcr      개행 문자를 캐리지 리턴-개행 문자로 변환\n"

#: src/stty.c:770
msgid " * [-]onlret     newline performs a carriage return\n"
msgstr " * [-]onlret     개행 문자로 캐리지 리턴 수행\n"

#: src/stty.c:775
msgid " * [-]onocr      do not print carriage returns in the first column\n"
msgstr " * [-]onocr      처음 열에 캐리지 리턴 출력 안함\n"

#: src/stty.c:779
msgid "   [-]opost      postprocess output\n"
msgstr "   [-]opost      처리 후 출력\n"

#: src/stty.c:783
msgid ""
" * tabN          horizontal tab delay style, N in [0..3]\n"
" * tabs          same as tab0\n"
" * -tabs         same as tab3\n"
msgstr ""
" * tab<숫자>     수평 탭 지연 방식. <숫자> 는 [0..3]\n"
" * tabs          tab0와 동일\n"
" * -tabs         tab3와 동일\n"

#: src/stty.c:790
msgid " * vtN           vertical tab delay style, N in [0..1]\n"
msgstr " * vt<숫자>      수직 탭 지연 방식, <숫자> 는 [0..1]\n"

#: src/stty.c:794
msgid ""
"\n"
"Local settings:\n"
"   [-]crterase   echo erase characters as backspace-space-backspace\n"
msgstr ""
"\n"
"로컬 설정:\n"
"   [-]crterase   지우기 문자를 backspace-space-backspace로 출력\n"

#: src/stty.c:800
msgid ""
" * crtkill       kill all line by obeying the echoprt and echoe settings\n"
" * -crtkill      kill all line by obeying the echoctl and echok settings\n"
msgstr ""
" * crtkill       echoprt와 echoe 설정을 따르는 모든 라인 연결을 강제 종료\n"
" * -crtkill      echoctl와 echok 설정을 따르는 모든 라인 연결을 강제 종료\n"

#: src/stty.c:806
msgid " * [-]ctlecho    echo control characters in hat notation ('^c')\n"
msgstr " * [-]ctlecho    고깔 표기 ('^c') 제어 문자를 출력\n"

#: src/stty.c:810
msgid "   [-]echo       echo input characters\n"
msgstr "   [-]echo       입력 문자를 반복 출력합니다\n"

#: src/stty.c:814
msgid " * [-]echoctl    same as [-]ctlecho\n"
msgstr " * [-]echoctl    [-]ctlecho와 동일\n"

#: src/stty.c:818
msgid ""
"   [-]echoe      same as [-]crterase\n"
"   [-]echok      echo a newline after a kill character\n"
msgstr ""
"   [-]echoe      [-]crterase와 동일\n"
"   [-]echok      강제 종료 문자 다음 개행 문자 출력\n"

#: src/stty.c:823
msgid " * [-]echoke     same as [-]crtkill\n"
msgstr " * [-]echoke     [-]crtkill과 동일\n"

#: src/stty.c:827
msgid "   [-]echonl     echo newline even if not echoing other characters\n"
msgstr "   [-]echonl     다른 문자를 출력하지 않아도 개행 문자 출력\n"

#: src/stty.c:831
msgid ""
" * [-]echoprt    echo erased characters backward, between '\\' and '/'\n"
msgstr " * [-]echoprt    '\\' 문자와 '/' 문자 사이 삭제 후위 문자 출력\n"

#: src/stty.c:836
msgid " * [-]extproc    enable \"LINEMODE\"; useful with high latency links\n"
msgstr " * [-]extproc    \"LINEMODE\" 활성. 하이 레이턴시 연결에 요긴함\n"

#: src/stty.c:841
msgid " * [-]flusho     discard output\n"
msgstr " * [-]flusho     출력 제거\n"

#: src/stty.c:845
#, c-format
msgid ""
"   [-]icanon     enable special characters: %s\n"
"   [-]iexten     enable non-POSIX special characters\n"
msgstr ""
"   [-]icanon     특수 문자 사용 활성: %s\n"
"   [-]iexten     비 POSIX용 특수 문자 활성\n"

#: src/stty.c:856
msgid ""
"   [-]isig       enable interrupt, quit, and suspend special characters\n"
"   [-]noflsh     disable flushing after interrupt and quit special "
"characters\n"
msgstr ""
"   [-]isig       interrupt, quit, suspend 특수 문자 활성\n"
"   [-]noflsh     interrupt, quit 특수 문자 뒤 삭제 비활성\n"

#: src/stty.c:861
msgid " * [-]prterase   same as [-]echoprt\n"
msgstr " * [-]prterase   [-]echoprt와 동일\n"

#: src/stty.c:866
msgid ""
" * [-]tostop     stop background jobs that try to write to the terminal\n"
msgstr " * [-]tostop     터미널에 기록하려는 백그라운드 작업 중지\n"

#: src/stty.c:871
msgid ""
" * [-]xcase      with icanon, escape with '\\' for uppercase characters\n"
msgstr ""
" * [-]xcase      icanon 옵션을 붙여, 대문자 문자를 '\\' 문자로 이스케이핑\n"

#: src/stty.c:875
msgid ""
"\n"
"Combination settings:\n"
msgstr ""
"\n"
"조합 설정:\n"

#: src/stty.c:880
msgid " * [-]LCASE      same as [-]lcase\n"
msgstr " * [-]LCASE      [-]lcase와 동일\n"

#: src/stty.c:884
msgid ""
"   cbreak        same as -icanon\n"
"   -cbreak       same as icanon\n"
msgstr ""
"   cbreak        -icanon과 동일\n"
"   -cbreak       icanon과 동일\n"

#: src/stty.c:888
msgid ""
"   cooked        same as brkint ignpar istrip icrnl ixon opost isig\n"
"                 icanon, eof and eol characters to their default values\n"
"   -cooked       same as raw\n"
msgstr ""
"   cooked        brkint ignpar istrip icrnl ixon opost isig와 동일\n"
"                 icanon, eof, eol 문자를 기본값으로 넣습니다\n"
"   -cooked       raw와 동일\n"

#: src/stty.c:893
#, c-format
msgid "   crt           same as %s\n"
msgstr "   crt           %s와(과) 동일\n"

#: src/stty.c:903
#, c-format
msgid ""
"   dec           same as %s intr ^c erase 0177\n"
"                 kill ^u\n"
msgstr ""
"   dec           다음과 동일: %s intr ^c erase 0177\n"
"                 kill ^u\n"

#: src/stty.c:918
msgid " * [-]decctlq    same as [-]ixany\n"
msgstr " * [-]decctlq    [-]ixany와 동일\n"

#: src/stty.c:922
msgid ""
"   ek            erase and kill characters to their default values\n"
"   evenp         same as parenb -parodd cs7\n"
"   -evenp        same as -parenb cs8\n"
msgstr ""
"   ek            기본값을 삭제, 강제 종료 문자로 지정\n"
"   evenp         sparenb -parodd cs7과 동일\n"
"   -evenp        -parenb cs8과 동일\n"

#: src/stty.c:928
msgid " * [-]lcase      same as xcase iuclc olcuc\n"
msgstr " * [-]lcase      xcase iuclc olcuc와 동일\n"

#: src/stty.c:932
msgid ""
"   litout        same as -parenb -istrip -opost cs8\n"
"   -litout       same as parenb istrip opost cs7\n"
msgstr ""
"   litout        -parenb -istrip -opost cs8과 동일\n"
"   -litout       parenb istrip opost cs7과 동일\n"

#: src/stty.c:936
#, c-format
msgid ""
"   nl            same as %s\n"
"   -nl           same as %s\n"
msgstr ""
"   nl            %s와(과) 동일\n"
"   -nl           %s와(과) 동일\n"

#: src/stty.c:954
msgid ""
"   oddp          same as parenb parodd cs7\n"
"   -oddp         same as -parenb cs8\n"
"   [-]parity     same as [-]evenp\n"
"   pass8         same as -parenb -istrip cs8\n"
"   -pass8        same as parenb istrip cs7\n"
msgstr ""
"   oddp          parenb parodd cs7과 동일\n"
"   -oddp         -parenb cs8과 동일\n"
"   [-]parity     [-]evenp와 동일\n"
"   pass8         -parenb -istrip cs8과 동일\n"
"   -pass8        parenb istrip cs7과 동일\n"

#: src/stty.c:961
#, c-format
msgid ""
"   raw           same as -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0\n"
"   -raw          same as cooked\n"
msgstr ""
"   raw           -ignbrk -brkint -ignpar -parmrk -inpck -istrip\n"
"                 -inlcr -igncr -icrnl -ixon -ixoff -icanon -opost\n"
"                 -isig%s min 1 time 0과 동일\n"
"   -raw          cooked와 동일\n"

#: src/stty.c:980
#, c-format
msgid ""
"   sane          same as cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 all special characters to their default values\n"
msgstr ""
"   sane          cread -ignbrk brkint -inlcr -igncr icrnl\n"
"                 icanon iexten echo echoe echok -echonl -noflsh와 동일\n"
"                 %s\n"
"                 %s\n"
"                 %s,\n"
"                 모든 특수 문자를 기본값으로 넣습니다\n"

#: src/stty.c:1066
msgid ""
"\n"
"Handle the tty line connected to standard input.  Without arguments,\n"
"prints baud rate, line discipline, and deviations from stty sane.  In\n"
"settings, CHAR is taken literally, or coded as in ^c, 0x37, 0177 or\n"
"127; special values ^- or undef used to disable special characters.\n"
msgstr ""
"\n"
"표준 입력에 연결한 tty 라인을 처리합니다.  어떤 인자도 설정하지 않으면,\n"
"보 전송율, 연결 규칙, stty sane 과의 편차를 출력합니다.  설정에서 <문자>\n"
"는 문자 그대로 또는 ^c, 0x37, 0177, 127 처럼 코딩합니다. ^- 특수값 또는 \n"
"비정의값은 특수 문자 비활성에 활용합니다.\n"

#: src/stty.c:1095
#, c-format
msgid "missing argument to %s"
msgstr "%s에 인자값 빠짐"

#: src/stty.c:1138 src/stty.c:1256
#, c-format
msgid "invalid argument %s"
msgstr "부적절한 %s 인자값"

#: src/stty.c:1190
#, c-format
msgid "%s: error setting %s"
msgstr "%s: %s 설정 오류"

#: src/stty.c:1232
#, c-format
msgid "invalid line discipline %s"
msgstr "부적절한 행 규정 %s"

#: src/stty.c:1324
msgid "only one device may be specified"
msgstr "장치 하나만 지정할 수 있습니다"

#: src/stty.c:1358
msgid ""
"the options for verbose and stty-readable output styles are\n"
"mutually exclusive"
msgstr ""
"자세한 출력에 쓰는 옵션과 stty-읽기 출력 방식 옵션은 혼용할 수 없습니다"

#: src/stty.c:1364
msgid "when specifying an output style, modes may not be set"
msgstr "출력 방식을 지정할 때는 모드를 설정할 수 없습니다"

#: src/stty.c:1382
#, c-format
msgid "%s: couldn't reset non-blocking mode"
msgstr "%s: 논 블로킹 모드로 초기화할 수 없습니다"

#: src/stty.c:1445
#, c-format
msgid "%s: unable to perform all requested operations"
msgstr "%s: 모든 요청 작업을 처리할 수 없습니다"

#: src/stty.c:1790
#, c-format
msgid "%s: no size information for this device"
msgstr "%s: 이 장치에 크기 정보가 없습니다"

#: src/stty.c:2322
msgid "invalid integer argument"
msgstr "부적절한 정수 인자"

#: src/sync.c:64
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "사용법: %s [<옵션>] [<파일>]...\n"

#: src/sync.c:65
msgid ""
"Synchronize cached writes to persistent storage\n"
"\n"
"If one or more files are specified, sync only them,\n"
"or their containing file systems.\n"
"\n"
msgstr ""
"캐싱한 파일을 동일하게 영구 저장장치에 기록합니다\n"
"\n"
"하나 이상의 파일을 지정하면, 해당 파일만 동기화하거나,\n"
"해당 파일 시스템을 동기화합니다.\n"
"\n"
"\n"

#: src/sync.c:73
msgid "  -d, --data             sync only file data, no unneeded metadata\n"
msgstr ""
"  -d, --data             불필요한 메타데이터를 뺀 파일 데이터만 동기화합니"
"다\n"

#: src/sync.c:76
msgid "  -f, --file-system      sync the file systems that contain the files\n"
msgstr "  -f, --file-system      파일이 있는 파일 시스템을 동기화합니다\n"

#: src/sync.c:115
#, c-format
msgid "error opening %s"
msgstr "%s 열기 오류"

#: src/sync.c:126
#, c-format
msgid "couldn't reset non-blocking mode %s"
msgstr "%s 논 블로킹 모드로 초기화할 수 없습니다"

#: src/sync.c:157
#, c-format
msgid "error syncing %s"
msgstr "%s 동기화 오류"

#: src/sync.c:215
msgid "cannot specify both --data and --file-system"
msgstr "--data와 --file-system을 함께 지정할 수 없습니다"

#: src/sync.c:219
msgid "--data needs at least one argument"
msgstr "--data 에는 최소한 인자 하나가 필요합니다"

#: src/system.h:350
#, c-format
msgid ""
"\n"
"NOTE: your shell may have its own version of %s, which usually supersedes\n"
"the version described here.  Please refer to your shell's documentation\n"
"for details about the options it supports.\n"
msgstr ""
"\n"
"참고: 사용중인 셸의 버전은 여기서 설명한 버전보다 최신인 %s인 것 같습니다.\n"
"이 기능을 지원하는 옵션의 동작 세부 내용을 알아보시려면 셸 문서를 참고하십시"
"오.\n"

#: src/system.h:356
msgid "      --help        display this help and exit\n"
msgstr "      --help        이 도움말을 표시하고 나갑니다\n"

#: src/system.h:358
msgid "      --version     output version information and exit\n"
msgstr "      --version     버전 정보를 출력하고 나갑니다\n"

#: src/system.h:576
msgid ""
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"\n"
"<파일>이 주어지지 않거나 - 이면 표준 입력을 읽습니다.\n"

#: src/system.h:583
msgid ""
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
msgstr ""
"\n"
"긴 옵션의 필수 인자값은 짧은 옵션에서도 마찬가지입니다.\n"

#: src/system.h:591
msgid ""
"\n"
"The SIZE argument is an integer and optional unit (example: 10K is "
"10*1024).\n"
"Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
msgstr ""
"\n"
"<크기> 인자는 정수값과 추가 단위로 구성합니다 (예: 10K는 10*1024).\n"
"단위는 K,M,G,T,P,E,Z,Y (1024 배수) 또는 KB,MB,... (1000 배수) 입니다.\n"
"이진 접미사의 경우 마찬가지입니다. KiB=K, MiB=M, 등과 같습니다.\n"

#: src/system.h:601
#, c-format
msgid ""
"\n"
"Display values are in units of the first available SIZE from --block-size,\n"
"and the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\n"
"Otherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n"
msgstr ""
"\n"
"--block-size 옵션에서는 가용 <크기> 단위에 맞춘 값과 %s_BLOCK_SIZE,\n"
"BLOCK_SIZE, BLOCKSIZE 환경 변수 값을 출력합니다.\n"
"아니면, 단위 기본을 1024 바이트 (또는 POSIXLY_CORRECT를 설정했다면 512)\n"
"에 맞춥니다.\n"

#: src/system.h:611
msgid ""
"\n"
"The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.\n"
"The version control method may be selected via the --backup option or "
"through\n"
"the VERSION_CONTROL environment variable.  Here are the values:\n"
"\n"
msgstr ""
"\n"
"--suffix 또는 SIMPLE_BACKUP_SUFFIX에서 지정하지 않는 한, 백업 접미사는 '~'입"
"니다.\n"
"버전 관리 방식은 --backup 옵션 또는 VERSION_CONTROL 환경 변수로 선택합니다.\n"
"해당 값은 다음과 같습니다:\n"
"\n"

#: src/system.h:618
msgid ""
"  none, off       never make backups (even if --backup is given)\n"
"  numbered, t     make numbered backups\n"
"  existing, nil   numbered if numbered backups exist, simple otherwise\n"
"  simple, never   always make simple backups\n"
msgstr ""
"  none, off       백업을 하지 않습니다(--backup 옵션을 붙여도)\n"
"  numbered, t     번호가 주어진 백업을 만듭니다\n"
"  existing, nil   번호가 주어진 백업이 있으면 번호를 주고, 그렇지 않으면\n"
"                  단순하게 합니다\n"
"  simple, never   항상 단순 백업을 합니다\n"

#: src/system.h:648
#, c-format
msgid ""
"\n"
"%s online help: <%s>\n"
msgstr ""
"\n"
"%s 온라인 도움말: <%s>\n"

#. TRANSLATORS: Replace LANG_CODE in this URL with your language code
#. <https://translationproject.org/team/LANG_CODE.html> to form one of
#. the URLs at https://translationproject.org/team/.  Otherwise, replace
#. the entire URL with your translation team's email address.
#: src/system.h:659
msgid "Report any translation bugs to <https://translationproject.org/team/>\n"
msgstr ""
"번역 버그는 <https://translationproject.org/team/ko.html>에 알려주십시오\n"

#: src/system.h:666
#, c-format
msgid "Full documentation <%s%s>\n"
msgstr "완전한 문서 <%s%s>\n"

#: src/system.h:668
#, c-format
msgid "or available locally via: info '(coreutils) %s%s'\n"
msgstr "또는 로컬 문서: info '(coreutils) %s%s'\n"

#: src/system.h:679
#, c-format
msgid "Try '%s --help' for more information.\n"
msgstr "자세한 정보는 '%s --help'를 입력하십시오.\n"

#: src/system.h:723
#, c-format
msgid ""
"WARNING: Circular directory structure.\n"
"This almost certainly means that you have a corrupted file system.\n"
"NOTIFY YOUR SYSTEM MANAGER.\n"
"The following directory is part of the cycle:\n"
"  %s\n"
msgstr ""
"경고: 순환 디렉터리 구조.\n"
"대부분의 경우 파일 시스템이 손상을 입었음을 의미합니다.\n"
"**시스템 관리자에게 알리십시오**\n"
"다음 디렉터리가 순환 구조의 일부입니다:\n"
"  %s\n"
"\n"

#. This is a proper name. See the gettext manual, section Names.
#: src/tac.c:57
msgid "Jay Lepreau"
msgstr "Jay Lepreau"

#: src/tac.c:136
msgid "Write each FILE to standard output, last line first.\n"
msgstr "각 <파일>을 마지막 줄부터 표준 출력에 씁니다.\n"

#: src/tac.c:143
msgid ""
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
msgstr ""
"  -b, --before             구분자를 뒤에 놓지 않고 앞에 놓습니다\n"
"  -r, --regex              구분자를 정규식으로 생각합니다\n"
"  -s, --separator=<문자열> 줄바꿈 대신에 <문자열>을 구분자로 씁니다\n"

#: src/tac.c:223 src/tac.c:233 src/tac.c:343
#, c-format
msgid "%s: seek failed"
msgstr "%s: 탐색 실패"

#: src/tac.c:276
msgid "record too large"
msgstr "레코드가 너무 깁니다"

#: src/tac.c:458
#, c-format
msgid "failed to create temporary file in %s"
msgstr "%s에 임시 파일 만들기 실패"

#: src/tac.c:466
#, c-format
msgid "failed to open %s for writing"
msgstr "%s 쓰기 용도 열기 실패"

#: src/tac.c:484
#, c-format
msgid "failed to rewind stream for %s"
msgstr "%s 스트림 되돌리기 실패"

#: src/tac.c:521 src/tac.c:533
#, c-format
msgid "%s: write error"
msgstr "%s: 쓰기 오류"

#: src/tac.c:582
#, c-format
msgid "failed to open %s for reading"
msgstr "%s 읽기 용도 열기 실패"

#: src/tac.c:650
msgid "separator cannot be empty"
msgstr "구분 단위가 빈 문자열이 될 수는 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/tail.c:79
msgid "Ian Lance Taylor"
msgstr "Ian Lance Taylor"

#: src/tail.c:270
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
msgstr ""
"각 <파일>의 마지막 %d줄을 표준 출력에 표시합니다.\n"
"두 개 이상의 <파일>이면, 각 파일에 대한 파일 이름 헤더를 먼저 나타냅니다.\n"

#: src/tail.c:278
msgid ""
"  -c, --bytes=[+]NUM       output the last NUM bytes; or use -c +NUM to\n"
"                             output starting with byte NUM of each file\n"
msgstr ""
"  -c, --bytes=[+]<숫자>       마지막 <숫자> 바이트를 출력합니다.\n"
"                             각 파일에서 <숫자> 바이트부터 출력을 시작하려"
"면\n"
"                             -c +<숫자>를 사용하십시오\n"
"\n"

#: src/tail.c:282
msgid ""
"  -f, --follow[={name|descriptor}]\n"
"                           output appended data as the file grows;\n"
"                             an absent option argument means 'descriptor'\n"
"  -F                       same as --follow=name --retry\n"
msgstr ""
"  -f, --follow[={name|descriptor}]\n"
"                           파일에 계속 추가하는 데이터를 출력합니다.\n"
"                             옵션 값을 빼면 'descriptor'를 의미합니다.\n"
"  -F                       --follow=name --retry와 같습니다\n"

#: src/tail.c:288
#, c-format
msgid ""
"  -n, --lines=[+]NUM       output the last NUM lines, instead of the last "
"%d;\n"
"                             or use -n +NUM to output starting with line "
"NUM\n"
"      --max-unchanged-stats=N\n"
"                           with --follow=name, reopen a FILE which has not\n"
"                             changed size after N (default %d) iterations\n"
"                             to see if it has been unlinked or renamed\n"
"                             (this is the usual case of rotated log files);\n"
"                             with inotify, this option is rarely useful\n"
msgstr ""
"  -n, --lines=[+]<숫자>    마지막 %d 대신 마지막 <숫자>줄을 출력합니다\n"
"                             <숫자>줄부터 출력을 시작하려면 -n +<숫자>\n"
"                             옵션을 사용하십시오\n"
"      --max-unchanged-stats=N\n"
"                           --follow=name과 같이 써서, N(기본값 %d)번 이후로\n"
"                             크기가 바뀌지 않은 <파일>을 다시 열어서,\n"
"                             파일이 지워지거나 이름이 바뀌지 않았는지 검사합"
"니다\n"
"                             (순환 로그 파일의 경우 이러합니다)\n"

#: src/tail.c:301
msgid ""
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"      --retry              keep trying to open a file if it is inaccessible\n"
msgstr ""
"      --pid=PID            -f와 같이 쓰여, 프로세스 ID PID가 죽으면 끝납니"
"다\n"
"  -q, --quiet, --silent    파일 이름이 들어 있는 헤더를 출력하지 않습니다\n"
"      --retry              파일을 열 수 없을 때 계속 열기를 다시 시도합니다\n"

#: src/tail.c:306
msgid ""
"  -s, --sleep-interval=N   with -f, sleep for approximately N seconds\n"
"                             (default 1.0) between iterations;\n"
"                             with inotify and --pid=P, check process P at\n"
"                             least once every N seconds\n"
"  -v, --verbose            always output headers giving file names\n"
msgstr ""
"  -s, --sleep-interval=<숫자>  -f 옵션을 붙여 반복 동작 실행한 대략적인\n"
"                             <숫자> 초 시간동안 멈줍니다(기본 1.0). \n"
"                             inotify와 --pid=P 옵션으로, 매 <숫자> 초 동안\n"
"                             최소한 한번은 P 프로세스를 확인합니다\n"
"  -v, --verbose            주어진 파일 이름 헤더를 항상 출력합니다\n"

#: src/tail.c:318
msgid ""
"\n"
"NUM may have a multiplier suffix:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y.\n"
"Binary prefixes can be used, too: KiB=K, MiB=M, and so on.\n"
"\n"
msgstr ""
"\n"
"<숫자>에는 배수 단위 접미사가 붙을 수 있습니다:\n"
"b 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\n"
"GB 1000*1000*1000, G 1024*1024*1024, 그리고 T, P, E, Z, Y에도 마찬가지입니"
"다.\n"
"이진 접미사의 경우 마찬가지입니다. KiB=K, MiB=M, 등과 같습니다.\n"
"\n"

#: src/tail.c:326
msgid ""
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file in a way that accommodates renaming, removal and creation.\n"
msgstr ""
"--follow (-f) 옵션으로 파일 서술자의 출력 내용을 기본으로 따라갑니다.\n"
"이는 출력 내용을 따라가던 파일 이름이 바뀌더라도, 끝까지 계속 따라감을\n"
"의미합니다. 이 기본 동작은 파일의 서술자가 아닌 실제 이름을 따라가도록\n"
"하려고 할 때 기본 동작이 뜻대로 동작하지 않습니다(예: 로그 전환). 이 경우\n"
"--follow=name 명령을 활용하십시오. 이렇게 하면 파일 이름을 지정했을\n"
"때 이름을 바꾸고, 제거 후 다시 만든다 하더라도 tail에서 계속 추적합니다.\n"

#: src/tail.c:421
#, c-format
msgid "closing %s (fd=%d)"
msgstr "%s(fd=%d)을(를) 닫습니다"

#: src/tail.c:520
#, c-format
msgid "%s: cannot seek to end-relative offset %s"
msgstr "%s: 종단점 기준 상대 오프셋 %s(으)로 탐색할 수 없음"

#: src/tail.c:954
#, c-format
msgid "cannot determine location of %s. reverting to polling"
msgstr "%s의 위치를 알 수 없습니다. 폴링으로 되돌림"

# 좀 더 자연스럽게
#: src/tail.c:1010
#, c-format
msgid "%s has been replaced with an untailable symbolic link"
msgstr "%s 파일이 추적할 수 없는 심볼릭 링크로 바뀌었습니다"

#: src/tail.c:1025
#, c-format
msgid "%s has become inaccessible"
msgstr "%s에 접근할 수 없게 바뀌었습니다"

# 좀 더 자연스럽게
#: src/tail.c:1043
#, c-format
msgid "%s has been replaced with an untailable file%s"
msgstr "%s 파일이 추적할 수 없는 %s 파일로 바뀌었습니다"

#: src/tail.c:1045 src/tail.c:2034
msgid "; giving up on this name"
msgstr "; 이 이름은 포기함"

# 좀 더 자연스럽게
#: src/tail.c:1051
#, c-format
msgid "%s has been replaced with an untailable remote file"
msgstr "%s 파일이 추적할 수 없는 원격 파일로 바뀌었습니다"

#: src/tail.c:1072
#, c-format
msgid "%s has become accessible"
msgstr "%s에 접근할 수 있게 바뀌었습니다"

# 좀 더 자연스럽게
#: src/tail.c:1084
#, c-format
msgid "%s has appeared;  following new file"
msgstr "%s이(가) 나타났습니다. 새 파일 내용을 따라갑니다"

# 좀 더 자연스럽게
#: src/tail.c:1094
#, c-format
msgid "%s has been replaced;  following new file"
msgstr "%s을(를) 바꾸었습니다. 새 파일 내용을 따라갑니다"

#: src/tail.c:1209
#, c-format
msgid "%s: cannot change nonblocking mode"
msgstr "%s: 논 블로킹 모드로 전환할 수 없음"

#: src/tail.c:1255 src/tail.c:1430
#, c-format
msgid "%s: file truncated"
msgstr "%s: 파일이 잘렸음"

#: src/tail.c:1289 src/tail.c:1623
#, c-format
msgid "no files remaining"
msgstr "파일이 남아 있지 않습니다"

#: src/tail.c:1526
#, c-format
msgid "cannot watch parent directory of %s"
msgstr "%s 상위 디렉터리 관찰 불가"

#: src/tail.c:1529 src/tail.c:1546 src/tail.c:1740
#, c-format
msgid "inotify resources exhausted"
msgstr "inotify 자원이 바닥남"

#: src/tail.c:1550 src/tail.c:1746
#, c-format
msgid "cannot watch %s"
msgstr "%s 관찰 불가"

#: src/tail.c:1594
#, c-format
msgid "%s was replaced"
msgstr "%s이(가) 필요합니다"

#: src/tail.c:1666
msgid "error waiting for inotify and output events"
msgstr "inofity와 출력 이벤트 대기 오류"

#: src/tail.c:1685
msgid "error reading inotify event"
msgstr "inotify 이벤트 읽기 오류"

#: src/tail.c:1703
#, c-format
msgid "directory containing watched file was removed"
msgstr "감시 파일이 들어있는 디렉터리를 제거했습니다"

#: src/tail.c:2032
#, c-format
msgid "%s: cannot follow end of this type of file%s"
msgstr "%s: %s 파일 형식 끝을 따라갈 수 없습니다"

#: src/tail.c:2213
msgid "invalid maximum number of unchanged stats between opens"
msgstr "열어둔 파일 핸들간의 부적절한 최대 미변경 상태 정보 수"

#: src/tail.c:2221
msgid "invalid PID"
msgstr "부적절한 PID"

#: src/tail.c:2237
#, c-format
msgid "invalid number of seconds: %s"
msgstr "부적절한 초 값: %s"

#: src/tail.c:2256
#, c-format
msgid "option used in invalid context -- %c"
msgstr "잘못된 컨텍스트에서 사용한 옵션 -- %c"

#: src/tail.c:2268
#, c-format
msgid "warning: --retry ignored; --retry is useful only when following"
msgstr ""
"경고: --retry는 무시합니다 --retry는 출력 내용을 따라갈 때만 쓸 수 있습니다"

#: src/tail.c:2272
#, c-format
msgid "warning: --retry only effective for the initial open"
msgstr "경고: --retry는 초기 열기 동작에 대해서만 동작합니다"

#: src/tail.c:2277
#, c-format
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "경고: PID 무시. --pid=PID는 --follow 옵션을 추가했을 때만 유효합니다"

#: src/tail.c:2280
#, c-format
msgid "warning: --pid=PID is not supported on this system"
msgstr "경고: --pid=PID는 이 시스템에서 지원하지 않습니다"

#: src/tail.c:2384
#, c-format
msgid "cannot follow %s by name"
msgstr "%s 출력을 이름대로 따라갈 수 없습니다"

#: src/tail.c:2399
#, c-format
msgid "warning: following standard input indefinitely is ineffective"
msgstr "경고: 다음의 무기한 표준 입력은 동작에 영향을 주지 않습니다"

#: src/tail.c:2494
#, c-format
msgid "inotify cannot be used, reverting to polling"
msgstr "inotify를 사용할 수 없습니다. 폴링으로 복귀함"

#: src/tee.c:88
msgid ""
"Copy standard input to each FILE, and also to standard output.\n"
"\n"
"  -a, --append              append to the given FILEs, do not overwrite\n"
"  -i, --ignore-interrupts   ignore interrupt signals\n"
msgstr ""
"표준 입력을 각 <파일>과 표준 출력에 복사합니다.\n"
"\n"
"  -a, --append              주어진 <파일> 뒷부분에 추가하고 덮어쓰지 않음\n"
"  -i, --ignore-interrupts   중단 시그널 무시\n"

#: src/tee.c:94
msgid ""
"  -p                        diagnose errors writing to non pipes\n"
"      --output-error[=MODE]   set behavior on write error.  See MODE below\n"
msgstr ""
"  -p                        논 파이프에 기록하는 오류 진단\n"
"      --output-error[=<모드>]  기록 오류시 동작을 설정합니다.  하단 <모드> 참"
"고\n"

#: src/tee.c:100
msgid ""
"\n"
"MODE determines behavior with write errors on the outputs:\n"
"  warn           diagnose errors writing to any output\n"
"  warn-nopipe    diagnose errors writing to any output not a pipe\n"
"  exit           exit on error writing to any output\n"
"  exit-nopipe    exit on error writing to any output not a pipe\n"
"The default MODE for the -p option is 'warn-nopipe'.\n"
"The default operation when --output-error is not specified, is to\n"
"exit immediately on error writing to a pipe, and diagnose errors\n"
"writing to non pipe outputs.\n"
msgstr ""
"\n"
"<모드>는 출력에 오류를 기록하는 동작 방식을 결정합니다:\n"
"  warn         임의 출력 대상에 기록하는 오류를 진단합니다\n"
"  warn-nopipe  파이프가 아닌 임의 출력 대상에 기록하는 오류를 진단합니다\n"
"  exit         임의 출력에 기록하는 오류가 발생하면 나갑니다\n"
"  exit-nopipe  파이프가 아닌 임의 출력하는 대상에 기록하는 오류가 발생하면 나"
"갑니다\n"
"-p 옵션의 기본 <모드> 값은 'warn-nopipe' 입니다.\n"
"--output-error를 지정하지 않았을 때 기본 동작은 파이프에 기록하는\n"
"오류 발생시 즉시 빠져나가며, 파이프가 아닌 출력에 기록하는 오류를 \n"
"분석합니다.\n"

#: src/test.c:125
#, c-format
msgid "missing argument after %s"
msgstr "%s 다음 인자 빠짐"

#: src/test.c:161
#, c-format
msgid "invalid integer %s"
msgstr "부적절한 정수 %s"

#: src/test.c:239
#, c-format
msgid "%s expected"
msgstr "%s이(가) 와야함"

#: src/test.c:242
#, c-format
msgid "%s expected, found %s"
msgstr "%s을(를) 기대했으나, %s이(가) 있습니다"

#: src/test.c:323
msgid "-nt does not accept -l"
msgstr "-nt 옵션은 -l 옵션을 받아들이지 않습니다"

#: src/test.c:336
msgid "-ef does not accept -l"
msgstr "-ef 옵션은 -l 옵션을 받아들이지 않습니다"

#: src/test.c:352
msgid "-ot does not accept -l"
msgstr "-ot 옵션은 -l 옵션을 받아들이지 않습니다"

#: src/test.c:361
#, c-format
msgid "%s: unknown binary operator"
msgstr "%s: 알 수 없는 이항 연산자"

#: src/test.c:391
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: 단항 연산자가 있어야 합니다"

#: src/test.c:627
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: 이항 연산자가 필요합니다"

#: src/test.c:686
msgid ""
"Usage: test EXPRESSION\n"
"  or:  test\n"
"  or:  [ EXPRESSION ]\n"
"  or:  [ ]\n"
"  or:  [ OPTION\n"
msgstr ""
"사용법: test <표현식>\n"
" 또는:  test\n"
" 또는:  [<표현식>]\n"
" 또는:  [ ]\n"
" 또는:  [<옵션>]\n"

#: src/test.c:693
msgid ""
"Exit with the status determined by EXPRESSION.\n"
"\n"
msgstr "<표현식>의 상태를 반환하며 빠져나갑니다\n"

#: src/test.c:699
msgid ""
"\n"
"An omitted EXPRESSION defaults to false.  Otherwise,\n"
"EXPRESSION is true or false and sets exit status.  It is one of:\n"
msgstr ""
"\n"
"생략한 <표현식>의 기본 반환값은 거짓입니다. 그렇지 않으면,\n"
"<표현식>이 참인지 거짓인지 판별하고 종료 상태로 설정합니다.  표현식은 다음과 "
"같습니다:\n"

#: src/test.c:704
msgid ""
"\n"
"  ( EXPRESSION )               EXPRESSION is true\n"
"  ! EXPRESSION                 EXPRESSION is false\n"
"  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\n"
"  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\n"
msgstr ""
"\n"
"  ( <표현식> )                 <표현식>이 참인지 여부\n"
"  ! <표현식>                   <표현식>이 거짓인 지 여부\n"
"  <표현식1> -a <표현식2>       <표현식1> 과 <표현식2>이 모두 참인지 여부\n"
"  <표현식1> -o <표현식2>       <표현식1> 또는 <표현식2> 둘 중 하나가 참인지 "
"여부\n"

#: src/test.c:711
msgid ""
"\n"
"  -n STRING            the length of STRING is nonzero\n"
"  STRING               equivalent to -n STRING\n"
"  -z STRING            the length of STRING is zero\n"
"  STRING1 = STRING2    the strings are equal\n"
"  STRING1 != STRING2   the strings are not equal\n"
msgstr ""
"\n"
"  -n <문자열>             길이가 있는 <문자열>인지 여부 \n"
"  <문자열>                -n <문자열> 과 동일\n"
"  -z <문자열>             <문자열>의 길이가 0인지 여부\n"
"  <문자열1> = <문자열2>   문자열이 동일한 지 여부l\n"
"  <문자열1> != <문자열2>  문자열이 다른 지 여부\n"

#: src/test.c:719
msgid ""
"\n"
"  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\n"
"  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\n"
"  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\n"
"  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\n"
"  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\n"
"  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\n"
msgstr ""
"\n"
"  <정수1> -eq <정수2>     <정수1>가 <정수2>와 같은지 여부\n"
"  <정수1> -ge <정수2>     <정수1>가 <정수2>보다 크거나 같은지 여부\n"
"  <정수1> -gt <정수2>     <정수1>가 <정수2>보다 큰 지 여부\n"
"  <정수1> -le <정수2>     <정수1>가 <정수2>보다 작거나 같은지 여부\n"
"  <정수1> -lt <정수2>     <정수1>가 <정수2>보다 작은 지 여부\n"
"  <정수1> -ne <정수2>     <정수1>가 <정수2>와 다른지 여부\n"

#: src/test.c:728
msgid ""
"\n"
"  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\n"
"  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\n"
"  FILE1 -ot FILE2   FILE1 is older than FILE2\n"
msgstr ""
"\n"
"  <파일1> -ef <파일2>   <파일1>과 <파일2>이 동일한 장치와 inode 번호를 지니"
"고 있는지 여부\n"
"  <파일1> -nt <파일2>   <파일1>이 (수정 일자가) <파일2>보다 최신인 지 여부\n"
"  <파일1> -ot <파일2>   <파일1>이 <파일2>보다 오래되었는 지 여부\n"

#: src/test.c:734
msgid ""
"\n"
"  -b FILE     FILE exists and is block special\n"
"  -c FILE     FILE exists and is character special\n"
"  -d FILE     FILE exists and is a directory\n"
"  -e FILE     FILE exists\n"
msgstr ""
"\n"
"  -b <파일>   <파일>이 존재하는 블록 특수 파일인지 여부\n"
"  -c <파일>   <파일>이 존재하는 문자 특수 파일인지 여부\n"
"  -d <파일>   <파일>이 존재하는 디렉터리인지 여부\n"
"  -e <파일>   <파일>이 존재하는 지 여부\n"

#: src/test.c:741
msgid ""
"  -f FILE     FILE exists and is a regular file\n"
"  -g FILE     FILE exists and is set-group-ID\n"
"  -G FILE     FILE exists and is owned by the effective group ID\n"
"  -h FILE     FILE exists and is a symbolic link (same as -L)\n"
"  -k FILE     FILE exists and has its sticky bit set\n"
msgstr ""
"  -f <파일>   <파일>이 존재하는 일반 파일인지 여부\n"
"  -g <파일>   <파일>이 존재하며 SETGID를 설정했는 지 여부\n"
"  -G <파일>   <파일>이 존재하며 유효한 그룹 ID의 소유인지 여부\n"
"  -h <파일>   <파일>이 존재하는 심볼릭 링크인지 여부 (-L과 동일)\n"
"  -k <파일>   <파일>이 존재하며 끈적이 비트를 설정했는지 여부\n"

#: src/test.c:748
msgid ""
"  -L FILE     FILE exists and is a symbolic link (same as -h)\n"
"  -N FILE     FILE exists and has been modified since it was last read\n"
"  -O FILE     FILE exists and is owned by the effective user ID\n"
"  -p FILE     FILE exists and is a named pipe\n"
"  -r FILE     FILE exists and the user has read access\n"
"  -s FILE     FILE exists and has a size greater than zero\n"
msgstr ""
"  -L <파일>   <파일>이 존재하며 심볼릭 링크인지 여부 (-h와 동일)\n"
"  -N <파일>   <파일>이 존재하며 마지막으로 읽은 후 수정했는지 여부\n"
"  -O <파일>   <파일>이 존재하며 유효한 사용자 ID의 소유인지 여부\n"
"  -p <파일>   <파일>이 존재하며 이름이 붙은 파이프인지 여부\n"
"  -r <파일>   <파일>이 존재하며 읽기 가능한 지 여부\n"
"  -s <파일>   <파일>이 존재하며 크기가 0보다 큰 지 여부\n"

#: src/test.c:756
msgid ""
"  -S FILE     FILE exists and is a socket\n"
"  -t FD       file descriptor FD is opened on a terminal\n"
"  -u FILE     FILE exists and its set-user-ID bit is set\n"
"  -w FILE     FILE exists and the user has write access\n"
"  -x FILE     FILE exists and the user has execute (or search) access\n"
msgstr ""
"  -S <파일>   <파일>이 존재하는 소켓인지 여부\n"
"  -t <파일서술자>  <파일서술자>가 터미널에서 열렸는 지 여부\n"
"  -u <파일>   <파일>이 존재하며 SETUID 비트를 설정했는 지 여부\n"
"  -w <파일>   <파일>이 존재하며 쓰기 가능한 지 여부\n"
"  -x <파일>   <파일>이 존재하며 실행(또는 검색) 가능한 지 여부\n"

#: src/test.c:763
msgid ""
"\n"
"Except for -h and -L, all FILE-related tests dereference symbolic links.\n"
"Beware that parentheses need to be escaped (e.g., by backslashes) for "
"shells.\n"
"INTEGER may also be -l STRING, which evaluates to the length of STRING.\n"
msgstr ""
"\n"
"-h와 -L을 제외한 모든 <파일> 관련 테스트에서는 심볼릭 링크를 역참조합니다.\n"
"셸에서의 괄호는 이스케이핑 처리(예: 역슬래시로)해야 합니다.\n"
"<정수>는 <문자열>의 길이를 따지는 -l <문자열>일 수 있습니다.\n"

#: src/test.c:769
msgid ""
"\n"
"NOTE: Binary -a and -o are inherently ambiguous.  Use 'test EXPR1 && test\n"
"EXPR2' or 'test EXPR1 || test EXPR2' instead.\n"
msgstr ""
"\n"
"참고: 이진 -a 옵션과 -o 옵션이 태생적으로 애매합니다.  'test <표현식1> && "
"test\n"
"<표현식2>'명령 또는 'test <표현식1> || test <표현식2>'명령을 대신 활용하십시"
"오.\n"

#: src/test.c:774
msgid ""
"\n"
"NOTE: [ honors the --help and --version options, but test does not.\n"
"test treats each of those as it treats any other nonempty STRING.\n"
msgstr ""
"\n"
"참고: [ 명령은 --help와 --version 옵션을 활용하지만, test는 그렇지 않습니"
"다.\n"
"test는 임의의 기타 비어있지 않은 <문자열>을 취급하듯이 다룹니다.\n"

#: src/test.c:779
msgid "test and/or ["
msgstr "test 그리고/또는 ["

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:791
msgid "Kevin Braunsdorf"
msgstr "Kevin Braunsdorf"

#. This is a proper name. See the gettext manual, section Names.
#: src/test.c:792
msgid "Matthew Bradburn"
msgstr "Matthew Bradburn"

#: src/test.c:846
#, c-format
msgid "missing %s"
msgstr "%s 빠짐"

#: src/test.c:860
#, c-format
msgid "extra argument %s"
msgstr "추가 인자 %s"

#: src/timeout.c:130
#, c-format
msgid "warning: timer_settime"
msgstr "경고: timer_settime"

#: src/timeout.c:135
#, c-format
msgid "warning: timer_create"
msgstr "경고: timer_create"

#: src/timeout.c:161
#, c-format
msgid "warning: setitimer"
msgstr "경고: setitimer"

#: src/timeout.c:231
#, c-format
msgid "sending signal %s to command %s"
msgstr "%2$s 명령에 %1$s 시그널 보내는 중"

#: src/timeout.c:259
#, c-format
msgid ""
"Usage: %s [OPTION] DURATION COMMAND [ARG]...\n"
"  or:  %s [OPTION]\n"
msgstr ""
"사용법: %s [<옵션>] <경과시간> <명령> [<인자>]...\n"
"  또는: %s [<옵션>]\n"

#: src/timeout.c:263
msgid "Start COMMAND, and kill it if still running after DURATION.\n"
msgstr "<명령> 실행을 시작하고, <경과시간> 후 실행시 강제 종료합니다.\n"

#: src/timeout.c:269
msgid ""
"      --preserve-status\n"
"                 exit with the same status as COMMAND, even when the\n"
"                   command times out\n"
"      --foreground\n"
"                 when not running timeout directly from a shell prompt,\n"
"                   allow COMMAND to read from the TTY and get TTY signals;\n"
"                   in this mode, children of COMMAND will not be timed out\n"
"  -k, --kill-after=DURATION\n"
"                 also send a KILL signal if COMMAND is still running\n"
"                   this long after the initial signal was sent\n"
"  -s, --signal=SIGNAL\n"
"                 specify the signal to be sent on timeout;\n"
"                   SIGNAL may be a name like 'HUP' or a number;\n"
"                   see 'kill -l' for a list of signals\n"
msgstr ""
"      --preserve-status\n"
"                 명령 처리 제한 시간이 지나더라도 <명령> 종료 상태와\n"
"                   동일한 상태로 나갑니다\n"
"      --foreground\n"
"                 셸 프롬프트에서 직접 시간 초과를 하지 않을 때, <명령>이 "
"<TTY>\n"
"                   를 읽어 <TTY> 시그널을 가져오게 합니다.\n"
"                   이 모드에서 <명령>의 하위 요소는 시간 제한을 두지 않습니"
"다\n"
"  -k, --kill-after=<경과시간>\n"
"                 <명령>을 여전히 실행하고 있다 하더라도 초기 시그널을 보낸 "
"후\n"
"                   이 시간 길이를 지나고 KILL 시그널을 보냅니다\n"
"  -s, --signal=<시그널>\n"
"                 시간이 지났을 때 보낼 시그널을 지정합니다.\n"
"                   <시그널>은 'HUP'과 같은 이름 또는 숫자입니다.\n"
"                   시그널 목록은 'kill -l' 명령을 참고하십시오\n"

#: src/timeout.c:284
msgid "  -v, --verbose  diagnose to stderr any signal sent upon timeout\n"
msgstr "  -v, --verbose  지정 시간 이후 보낸 시그널을 표준 오류로 분석합니다\n"

#: src/timeout.c:290
msgid ""
"\n"
"DURATION is a floating point number with an optional suffix:\n"
"'s' for seconds (the default), 'm' for minutes, 'h' for hours or 'd' for "
"days.\n"
"A duration of 0 disables the associated timeout.\n"
msgstr ""
"\n"
"<경과시간> 은 추가 접미사를 붙인 소숫점 숫자입니다:\n"
"초의 's' (기본값), 분의 'm', 시간의 'h', 일의 'd'를 쓸 수 있습니다.\n"
"<경과시간>에 0 값을 넣으면 관련 제한 시간을 걸어두지 않습니다.\n"

#: src/timeout.c:295
msgid ""
"\n"
"Upon timeout, send the TERM signal to COMMAND, if no other SIGNAL "
"specified.\n"
"The TERM signal kills any process that does not block or catch that signal.\n"
"It may be necessary to use the KILL signal, since this signal can't be "
"caught.\n"
msgstr ""
"\n"
"제한 시간 초과시, 다른 <시그널>을 지정하지 않았다면, <명령>에 TERM 시그널을 "
"보냅니다.\n"
"TERM 시그널은 이 시그널을 블로킹하지 않았거나 잡지 않은 프로세스를 강제 종료"
"합니다.\n"
"KILL 시그널은 잡을 수 없기 때문에 TERM 시그널이 필요할 때가 있습니다.\n"

#: src/timeout.c:301
msgid ""
"\n"
"EXIT status:\n"
"  124  if COMMAND times out, and --preserve-status is not specified\n"
"  125  if the timeout command itself fails\n"
"  126  if COMMAND is found but cannot be invoked\n"
"  127  if COMMAND cannot be found\n"
"  137  if COMMAND (or timeout itself) is sent the KILL (9) signal (128+9)\n"
"  -    the exit status of COMMAND otherwise\n"
msgstr ""
"\n"
"<종료> 상태:\n"
"  124  <명령> 시간이 초과하였으며, --preserve-status 옵션을 지정하지 않았을 "
"경우\n"
"  125  명령 자체 처리 시간 초과 처리에 실패했을 경우\n"
"  126  <명령>을 찾았으나 실행할 수 없을 경우\n"
"  127  <명령>을 찾을 수 없을 경우\n"
"  137  <명령>(또는 자체 시간 초과)으로 KILL (9) 시그널(128+9)을 보냈을 경우\n"
"  -    <명령>을 빠져나간 다른 경우\n"

#: src/timeout.c:379 src/timeout.c:436
#, c-format
msgid "warning: sigprocmask"
msgstr "경고: sigprocmask"

#: src/timeout.c:458
#, c-format
msgid "warning: disabling core dumps failed"
msgstr "경고: 코어 덤핑 비활성 실패"

#: src/timeout.c:577
#, c-format
msgid "error waiting for command"
msgstr "명령 대기 중 오류"

#: src/timeout.c:588
#, c-format
msgid "the monitored command dumped core"
msgstr "감시 중인 명령에서 코어 덤프"

#: src/timeout.c:606
#, c-format
msgid "unknown status from command (%d)"
msgstr "명령에서 알 수 없는 상태 반환(%d)"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:44
msgid "Jim Kingdon"
msgstr "Jim Kingdon"

#. This is a proper name. See the gettext manual, section Names.
#: src/touch.c:46
msgid "Randy Smith"
msgstr "Randy Smith"

#: src/touch.c:116 src/touch.c:314
#, c-format
msgid "invalid date format %s"
msgstr "잘못된 %s 날짜 형식"

#: src/touch.c:196
#, c-format
msgid "cannot touch %s"
msgstr "%s에 touch 명령 실행 불가"

#: src/touch.c:202
#, c-format
msgid "setting times of %s"
msgstr "%s의 시간 설정"

#: src/touch.c:218
msgid ""
"Update the access and modification times of each FILE to the current time.\n"
"\n"
"A FILE argument that does not exist is created empty, unless -c or -h\n"
"is supplied.\n"
"\n"
"A FILE argument string of - is handled specially and causes touch to\n"
"change the times of the file associated with standard output.\n"
msgstr ""
"각 <파일> 의 접근, 수정 시각을 현재 시각으로 업데이트합니다.\n"
"\n"
"<파일> 인자가 없으면 -c 또는 -h 옵션을 혼용하지 않는 한 빈 파일을\n"
"만듭니다.\n"
"\n"
"- 값 <파일> 인자는 별도로 취급하며 표준 출력과 관련이 있는 파일의\n"
"시각 정보를 건드립니다.\n"

#: src/touch.c:230
msgid ""
"  -a                     change only the access time\n"
"  -c, --no-create        do not create any files\n"
"  -d, --date=STRING      parse STRING and use it instead of current time\n"
"  -f                     (ignored)\n"
msgstr ""
"  -a                     접근 시각만 바꿉니다\n"
"  -c, --no-create        어떤 파일도 만들지 않습니다\n"
"  -d, --date=<문자열>    <문자열>을 해석하여 현재 시각 대신 활용합니다\n"
"  -f                     (무시)\n"

#: src/touch.c:236
msgid ""
"  -h, --no-dereference   affect each symbolic link instead of any "
"referenced\n"
"                         file (useful only on systems that can change the\n"
"                         timestamps of a symlink)\n"
"  -m                     change only the modification time\n"
msgstr ""
"  -h, --no-dereference   참조 대상 파일이 아닌 심볼릭 링크 자체에 영향을 줍니"
"다\n"
"                         (심볼릭 링크 타임 스탬프를 바꿀 수 있는 시스템에만 "
"요긴함)\n"
"  -m                     수정 시각만 바꿈\n"

#: src/touch.c:242
msgid ""
"  -r, --reference=FILE   use this file's times instead of current time\n"
"  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time\n"
"      --time=WORD        change the specified time:\n"
"                           WORD is access, atime, or use: equivalent to -a\n"
"                           WORD is modify or mtime: equivalent to -m\n"
msgstr ""
"  -r, --reference=<파일>  현재 시각 대신 지정 파일의 시각을 활용합니다\n"
"  -t <스탬프>             현재 시각 대신 [[CC]YY]MMDDhhmm[.ss] 형식 문자열을 "
"활용합니다\n"
"      --time=<단어>       지정 부분의 시각을 바꿉니다:\n"
"                            <단어>에 access, atime, use 지정: -a와 동일\n"
"                            <단어>에 modify, mtime 지정: -m과 동일\n"

#: src/touch.c:251
msgid ""
"\n"
"Note that the -d and -t options accept different time-date formats.\n"
msgstr ""
"\n"
"참고로 -d 옵션과 -t 옵션으로 다른 날짜와 시간을 지정할 수 있습니다.\n"

#: src/touch.c:340
#, c-format
msgid "cannot specify times from more than one source"
msgstr "둘 이상의 원본에 시각을 지정할 수 없습니다"

#: src/touch.c:414
#, c-format
msgid ""
"warning: 'touch %s' is obsolete; use 'touch -t %04ld%02d%02d%02d%02d.%02d'"
msgstr ""
"경고: 낡은 'touch %s' 명령 방식입니다. 'touch -t %04ld%02d%02d%02d%02d.%02d' "
"명령을 사용하십시오"

#: src/tr.c:287
#, c-format
msgid "Usage: %s [OPTION]... STRING1 [STRING2]\n"
msgstr "사용법: %s [<옵션>]... <문자열1> [<문자열2>]\n"

#: src/tr.c:291
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.  STRING1 and STRING2 specify arrays of\n"
"characters ARRAY1 and ARRAY2 that control the action.\n"
"\n"
"  -c, -C, --complement    use the complement of ARRAY1\n"
"  -d, --delete            delete characters in ARRAY1, do not translate\n"
"  -s, --squeeze-repeats   replace each sequence of a repeated character\n"
"                            that is listed in the last specified ARRAY,\n"
"                            with a single occurrence of that character\n"
"  -t, --truncate-set1     first truncate ARRAY1 to length of ARRAY2\n"
msgstr ""
"표준 입력으로부터 문자를 옮기고, 줄이고, 그리고/또는 지워서\n"
"표준 출력에 기록합니다. <문자열1>과 <문자열2>는 동작을 제어\n"
"하는 문자 <배열1>과 문자 <배열2>를 지정합니다.\n"
"\n"
"  -c, --complement        <배열1>의 여집합을 취합니다\n"
"  -d, --delete            <배열11>의 문자를 지우고, 옮기지 않습니다\n"
"  -s, --squeeze-repeats   같은 문자의 반복을 하나의 문자로 만듭니다\n"
"                            <배열>에서 해당 문자가 한 번만 나타납니다\n"
"  -t, --truncate-set1     먼저 <배열1>을 <배열2>의 길이에 맞게 자릅니다\n"

#: src/tr.c:305
msgid ""
"\n"
"ARRAYs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
msgstr ""
"\n"
"<배열>은 문자로 이루어진 문자열 지정 값입니다.  대부분의 경우 그 자체를 의미"
"합니다.\n"
"해석 대상 시퀀스는 다음과 같습니다:\n"
"\n"
"  \\NNN            8진수 값 NNN의 문자 (1개에서 3개의 8진수 숫자)\n"
"  \\\\              역슬래시\n"
"  \a              소리나는 BEL\n"
"  \\b              백스페이스\n"
"  \\f              폼피드\n"
"  \\n              줄 바꿈\n"
"  \\r              리턴\n"
"  \\t              수평 탭\n"

#: src/tr.c:319
msgid ""
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR*]         in ARRAY2, copies of CHAR until length of ARRAY1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
msgstr ""
"  \\v              수직 탭\n"
"  <문자1>-<문자2>  <문자1>에서 <문자2>까지의 (커지는 순서대로) 모든 문자\n"
"  [<문자>*]        <배열2>에서, <배열1>의 길이만큼 <문자>를 복사\n"
"  [<문자>*<반복횟수>]   <문자>의 <반복횟수>번 반복, <반복횟수>가 0으로 시작하"
"면 8진수\n"
"  [:alnum:]       모든 문자 및 숫자\n"
"  [:alpha:]       모든 문자\n"
"  [:blank:]       모든 수평 공백문자\n"
"  [:cntrl:]       모든 컨트롤 문자\n"
"  [:digit:]       모든 숫자\n"

#: src/tr.c:330
msgid ""
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"  [:graph:]       모든 표시 가능한 문자, 공백은 포함하지 않음\n"
"  [:lower:]       모든 소문자\n"
"  [:print:]       모든 표시 가능한 문자, 공백 포함\n"
"  [:punct:]       모든 문장 기호 문자\n"
"  [:space:]       모든 수평 및 수직 공백문자\n"
"  [:upper:]       모든 대문자\n"
"  [:xdigit:]      모든 16진수 숫자\n"
"  [=<문자>=]        <문자>와 동일한 모든 문자\n"

#: src/tr.c:340
msgid ""
"\n"
"Translation occurs if -d is not given and both STRING1 and STRING2 appear.\n"
"-t may be used only when translating.  ARRAY2 is extended to length of\n"
"ARRAY1 by repeating its last character as necessary.  Excess characters\n"
"of ARRAY2 are ignored.  Character classes expand in unspecified order;\n"
"while translating, [:lower:] and [:upper:] may be used in pairs to\n"
"specify case conversion.  Squeezing occurs after translation or deletion.\n"
msgstr ""
"\n"
"-d 옵션을 지정하지 않고 <문자열1> <문자열2>가 나타났을 경우 변환 동작이\n"
"일어납니다. -t 옵션은 변환 동작 진행시에만 활용합니다. <배열2>는 필요\n"
"에 따라 마지막 문자를 반복하여 <배열1> 만큼 길이가 늘어납니다. <배열2>\n"
"의 문자가 더 많을 경우 더 많은 문자는 무시합니다.  문자 클래스는 지정하지 \n"
"않은 순서대로 확장합니다. 변환을 진행하는 동안, [:upper:]와 [:lower:]는\n"
"대소문자 변환을 용도로 쌍으로 사용합니다.  변환 또는 삭제 처리 후 문자\n"
"줄이기 동작이 일어납니다.\n"
"\n"

#: src/tr.c:508
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, %c"
msgstr ""
"경고: 애매한 8진수 이스케이프 \\%c%c%c은(는) 2바이트 시퀀스\n"
"\t\\0%c%c, %c(으)로 해석합니다"

#: src/tr.c:517
#, c-format
msgid "warning: an unescaped backslash at end of string is not portable"
msgstr ""
"경고: 문자열 마지막 역슬래시를 이스케이핑하지 않으면 타 시스템에서 동작하지 "
"않을 수도 있습니다"

#: src/tr.c:668
#, c-format
msgid "range-endpoints of '%s-%s' are in reverse collating sequence order"
msgstr "'%s-%s' 범위 지정 순서가 사전 순서의 역방향입니다"

#: src/tr.c:814
#, c-format
msgid "invalid repeat count %s in [c*n] construct"
msgstr "[c*n] 구문에 부적절한 반복 회수 %s"

#: src/tr.c:891
#, c-format
msgid "missing character class name '[::]'"
msgstr "'[::]' 문자 클래스 이름이 빠졌습니다"

#: src/tr.c:894
#, c-format
msgid "missing equivalence class character '[==]'"
msgstr "'[==]' 동격 클래스 문자가 빠졌습니다"

#: src/tr.c:909
#, c-format
msgid "invalid character class %s"
msgstr "부적절한 문자 클래스 %s"

#: src/tr.c:928
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: 동일 클래스 피연산자는 하나의 문자이어야 합니다"

#: src/tr.c:1208
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "맞지 않는 [:upper:] 그리고/또는 [:lower:] 구성"

#: src/tr.c:1312
msgid "too many characters in set"
msgstr "세트에 문자가 너무 많습니다"

#: src/tr.c:1396
msgid ""
"when translating with string1 longer than string2,\n"
"the latter string must not end with a character class"
msgstr ""
"문자열2보다 긴 문자열1을 변환할 때,\n"
"문자열2는 가독문자 계열로 끝나면 안됩니다"

#: src/tr.c:1452
msgid "the [c*] repeat construct may not appear in string1"
msgstr "[c*] 반복 구성문은 문자열1에서는 쓸 수 없습니다"

#: src/tr.c:1462
msgid "only one [c*] repeat construct may appear in string2"
msgstr "[c*] 반복 구성문은 문자열2에서 오직 한 개만 쓸 수 있습니다"

#: src/tr.c:1470
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "[=c=] 표현은 옮김의 경우 문자열2에서 쓸 수 없습니다"

#: src/tr.c:1477
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are 'upper' and 'lower'"
msgstr ""
"변환할 때, 문자열2에 나타날 수 있는 문자 클래스는 `upper'와 \n"
"`lower'뿐입니다"

#: src/tr.c:1492
msgid "when not truncating set1, string2 must be non-empty"
msgstr "집합1이 잘려나가지 않는다면, 문자열2는 빈 집합이어서는 안 됩니다"

#: src/tr.c:1501
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"문자 클래스의 여집합으로 옮길 경우에는,\n"
"string2는 그 도메인의 모든 문자를 하나의 문자로 매핑해야 합니다"

#: src/tr.c:1510
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "번역할 때에만 [c*] 구문이 문자열2에 나타날 수 있습니다"

#: src/tr.c:1762
msgid "Two strings must be given when both deleting and squeezing repeats."
msgstr "지움과 반복 줄임을 동시에 하는 경우 문자열 두개를 제시해야 합니다."

#: src/tr.c:1764
msgid "Two strings must be given when translating."
msgstr "변환할 때 문자열 두개를 제시해야 합니다."

#: src/tr.c:1774
msgid "Only one string may be given when deleting without squeezing repeats."
msgstr "반복 줄임 없이 지울 때는 문자열 한 개만 제시해야 합니다."

#: src/true.c:38
#, c-format
msgid ""
"Usage: %s [ignored command line arguments]\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s [<명령행_인자_무시>]...\n"
"  또는: %s <옵션>\n"

#: src/true.c:45
msgid "Exit with a status code indicating success."
msgstr "성공 상태 코드를 반환하며 빠져나갑니다."

#: src/true.c:46
msgid "Exit with a status code indicating failure."
msgstr "실패 상태 코드를 반환하며 빠져나갑니다."

#: src/truncate.c:70
#, c-format
msgid "Usage: %s OPTION... FILE...\n"
msgstr "사용법: %s <옵션>... <파일>...\n"

#: src/truncate.c:71
msgid ""
"Shrink or extend the size of each FILE to the specified size\n"
"\n"
"A FILE argument that does not exist is created.\n"
"\n"
"If a FILE is larger than the specified size, the extra data is lost.\n"
"If a FILE is shorter, it is extended and the sparse extended part (hole)\n"
"reads as zero bytes.\n"
msgstr ""
"각 <파일>의 크기를 지정 크기로 줄이거나 늘입니다.\n"
"\n"
"<파일> 인자에 지정한 파일이 없으면 만듭니다.\n"
"\n"
"<파일>이 지정한 크기보다 크면, 추가 데이터를 잃습니다.\n"
"<파일>이 지정한 크기보다 작으면, 길이를 확장하고 확장 부분(홀)을\n"
"0 바이트로 읽습니다.\n"

#: src/truncate.c:83
msgid "  -c, --no-create        do not create any files\n"
msgstr "  -c, --no-create        어떤 파일도 만들지 않음\n"

#: src/truncate.c:86
msgid ""
"  -o, --io-blocks        treat SIZE as number of IO blocks instead of bytes\n"
msgstr "  -o, --io-blocks        <크기>를 바이트가 아닌 IO 블록 갯수로 취급\n"

#: src/truncate.c:89
msgid ""
"  -r, --reference=RFILE  base size on RFILE\n"
"  -s, --size=SIZE        set or adjust the file size by SIZE bytes\n"
msgstr ""
"  -r, --reference=<참조파일>  <참조파일>의 크기를 기준으로 함\n"
"  -s, --size=<크기>      <크기> 바이트로 파일 크기 설정 또는 조정\n"

#: src/truncate.c:95
msgid ""
"\n"
"SIZE may also be prefixed by one of the following modifying characters:\n"
"'+' extend by, '-' reduce by, '<' at most, '>' at least,\n"
"'/' round down to multiple of, '%' round up to multiple of.\n"
msgstr ""
"\n"
"<크기>에는 다음 수정자 문자를 앞에 붙일 수 있습니다:\n"
"확장은 '+', 축소는 '-', 최대한 '<', 최소한 '>',\n"
"배수 내림 '/', 배수 올림'%'.\n"

#: src/truncate.c:124
#, c-format
msgid "overflow in %<PRIdMAX> * %<PRIdPTR> byte blocks for file %s"
msgstr "%3$s 파일에 대해 %1$<PRIdMAX> * %2$<PRIdPTR> 바이트 블록 오버플로우"

#: src/truncate.c:145
#, c-format
msgid "%s has unusable, apparently negative size"
msgstr "%s이(가) 음의 크기를 가져 활용할 수 없습니다"

#: src/truncate.c:155 src/truncate.c:346
#, c-format
msgid "cannot get the size of %s"
msgstr "%s 크기를 가져올 수 없습니다"

#: src/truncate.c:179
#, c-format
msgid "overflow extending size of file %s"
msgstr "%s 파일의 확장 크기 초과"

#: src/truncate.c:193
#, c-format
msgid "failed to truncate %s at %<PRIdMAX> bytes"
msgstr "%2$<PRIdMAX> 바이트에서 %1$s 자르기 실패"

#: src/truncate.c:264
#, c-format
msgid "multiple relative modifiers specified"
msgstr "다중 상대 수정자를 지정했습니다"

#: src/truncate.c:273
msgid "Invalid number"
msgstr "부적절한 숫자"

#: src/truncate.c:295
#, c-format
msgid "you must specify either %s or %s"
msgstr "%s 또는 %s을(를) 지정해야 합니다"

#: src/truncate.c:302
#, c-format
msgid "you must specify a relative %s with %s"
msgstr "상대 %s을(를) %s(으)로 지정해야 합니다"

#: src/truncate.c:309
#, c-format
msgid "%s was specified but %s was not"
msgstr "%s을(를) 지정했습니다만 %s은(는) 아닙니다"

#: src/truncate.c:368
#, c-format
msgid "cannot open %s for writing"
msgstr "%s을(를) 기록 용도로 열 수 없습니다"

#. This is a proper name. See the gettext manual, section Names.
#: src/tsort.c:40
msgid "Mark Kettenis"
msgstr "Mark Kettenis"

#: src/tsort.c:83
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
msgstr ""
"사용법: %s [<옵션>] [<파일>]\n"
"일부 정렬 상태와 일관된 상태를 유지하는 완전 정렬 목록을 <파일>에 기록합니"
"다.\n"

#: src/tsort.c:90 src/uptime.c:213
#, c-format
msgid "\n"
msgstr "\n"

#: src/tsort.c:472
#, c-format
msgid "%s: input contains an odd number of tokens"
msgstr "%s: 입력에 홀수개의 토큰이 들어있습니다"

#: src/tsort.c:513
#, c-format
msgid "%s: input contains a loop:"
msgstr "%s: 입력에 루프가 들어가 있습니다 loop:"

#: src/tty.c:66
msgid ""
"Print the file name of the terminal connected to standard input.\n"
"\n"
"  -s, --silent, --quiet   print nothing, only return an exit status\n"
msgstr ""
"표준 입력에 연결한 터미널 파일 이름을 출력합니다.\n"
"\n"
"  -s, --silent, --quiet   아무 내용도 출력하지 않고 종료 상태코드만 반환\n"

#: src/tty.c:127
msgid "not a tty"
msgstr "tty 아님"

#: src/uname.c:120
msgid ""
"Print certain system information.  With no OPTION, same as -s.\n"
"\n"
"  -a, --all                print all information, in the following order,\n"
"                             except omit -p and -i if unknown:\n"
"  -s, --kernel-name        print the kernel name\n"
"  -n, --nodename           print the network node hostname\n"
"  -r, --kernel-release     print the kernel release\n"
msgstr ""
"각 시스템 정보를 출력합니다. <옵션>이 없으면 -s 옵션을 준 상태와 동일합니"
"다.\n"
"\n"
"  -a, --all                모든 정보를 다음 순서대로 출력합니다.\n"
"                             알 수 없는 경우 -p와 -i 옵션 생략을 제외합니"
"다:\n"
"  -s, --kernel-name        커널 이름을 출력합니다\n"
"  -n, --nodename           네트워크 노드 호스트 이름을 출력합니다\n"
"  -r, --kernel-release     커널 릴리스 버전을 출력합니다\n"

#: src/uname.c:129
msgid ""
"  -v, --kernel-version     print the kernel version\n"
"  -m, --machine            print the machine hardware name\n"
"  -p, --processor          print the processor type (non-portable)\n"
"  -i, --hardware-platform  print the hardware platform (non-portable)\n"
"  -o, --operating-system   print the operating system\n"
msgstr ""
"  -v, --kernel-version     커널 버전을 출력합니다\n"
"  -m, --machine            머신 하드웨어 이름을 출력합니다\n"
"  -p, --processor          프로세서 형식을 출력합니다 (이식 불가)\n"
"  -i, --hardware-platform  하드웨어 기반 이름을 출력합니다 (이식 불가)\n"
"  -o, --operating-system   운영체제 이름을 출력합니다\n"

#: src/uname.c:139
msgid ""
"Print machine architecture.\n"
"\n"
msgstr ""
"머신 아키텍처를 출력합니다.\n"
"\n"

#: src/uname.c:300
msgid "cannot get system name"
msgstr "시스템 이름을 가져올 수 없습니다"

#: src/unexpand.c:81
msgid "Convert blanks in each FILE to tabs, writing to standard output.\n"
msgstr "각 <파일>의 빈 칸을 탭으로 변환하여 표준 출력에 기록합니다.\n"

#: src/unexpand.c:88
msgid ""
"  -a, --all        convert all blanks, instead of just initial blanks\n"
"      --first-only  convert only leading sequences of blanks (overrides -a)\n"
"  -t, --tabs=N     have tabs N characters apart instead of 8 (enables -a)\n"
msgstr ""
"  -a, --all        초기 빈칸이 아닌 모든 빈칸을 변환합니다\n"
"      --first-only  빈칸의 처음 부분만 변환합니다 (-a 설정 덮어씀)\n"
"  -t, --tabs=<횟수>  8칸 대신 <횟수>칸 만큼 탭 입력을 표시합니다 (-a 활성)\n"

#: src/unexpand.c:305
msgid "tab stop value is too large"
msgstr "탭 간격 값이 너무 큽니다"

#: src/uniq.c:166
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "사용법: %s [<옵션>]... [<입력> [<출력>]]\n"

#: src/uniq.c:170
msgid ""
"Filter adjacent matching lines from INPUT (or standard input),\n"
"writing to OUTPUT (or standard output).\n"
"\n"
"With no options, matching lines are merged to the first occurrence.\n"
msgstr ""
"<입력>(또는 표준 입력)에 인접 일치하는 행을 찾아냅니다,\n"
"그리고 <출력> (또는 표준 출력)에 씁니다.\n"
"\n"
"그 어떤 옵션도 주지 않으면, 처음 일치하는 행은 합칩니다.\n"

#: src/uniq.c:179
msgid ""
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines, one for each group\n"
msgstr ""
"  -c, --count           발생 횟수를 행 앞에 표시합니다.\n"
"  -d, --repeated        중복 행을 그룹별로 출력합니다.\n"

#: src/uniq.c:183
msgid ""
"  -D                    print all duplicate lines\n"
"      --all-repeated[=METHOD]  like -D, but allow separating groups\n"
"                                 with an empty line;\n"
"                                 METHOD={none(default),prepend,separate}\n"
msgstr ""
"  -D                    모든 중복 행을 출력합니다\n"
"      --all-repeated[=<방식>]  -D와 유사하나, 빈칸으로 분리한\n"
"                                 그룹 입력을 허용합니다\n"
"                                 <방식>={none(기본값),prepend,separate}\n"

#: src/uniq.c:189
msgid "  -f, --skip-fields=N   avoid comparing the first N fields\n"
msgstr ""
"  -f, --skip-fields=<횟수>   처음 <횟수>개의 필드를 비교 대상에서 제외\n"

#: src/uniq.c:192
msgid ""
"      --group[=METHOD]  show all items, separating groups with an empty "
"line;\n"
"                          METHOD={separate(default),prepend,append,both}\n"
msgstr ""
"      --group[=<방식>]  모든 항목을 보여주며, 빈 줄로 그룹을 구분합니다.\n"
"                          <방식>={separate(기본값),prepend,append,both}\n"

#: src/uniq.c:196
msgid ""
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
msgstr ""
"  -i, --ignore-case     비교시 대소문자 차이 무시\n"
"  -s, --skip-chars=<개수>  <개수>개 만큼의 처음 문자를 비교 대상에서 제외\n"
"  -u, --unique          유일한 행만 화면에 출력합니다\n"

#: src/uniq.c:204
msgid "  -w, --check-chars=N   compare no more than N characters in lines\n"
msgstr ""
"  -w, --check-chars=<개수>   한 줄에 <개수>개의 문자까지만 비교합니다\n"

# ??
#: src/uniq.c:209
msgid ""
"\n"
"A field is a run of blanks (usually spaces and/or TABs), then non-blank\n"
"characters.  Fields are skipped before chars.\n"
msgstr ""
"\n"
"필드 하나는 공백으로 구분하며 (보통 간격 과/또는 탭), 그 다음은 비공백\n"
"문자로 구분합니다.  이 문자가 나타나기 전 열 항목은 건너뜁니다.\n"

#: src/uniq.c:214
msgid ""
"\n"
"Note: 'uniq' does not detect repeated lines unless they are adjacent.\n"
"You may want to sort the input first, or use 'sort -u' without 'uniq'.\n"
msgstr ""
"\n"
"참고: 'uniq'는 행이 인접하지 않으면 반복 행을 찾아낼 수 없습니다.\n"
"우선 입력 내용을 정렬하거나 'uniq' 명령을 사용하지 않고 'sort -u'\n"
"명령을 사용하시는게 좋습니다.\n"

#: src/uniq.c:426
msgid "too many repeated lines"
msgstr "반복 행이 너무 많음"

#: src/uniq.c:601
msgid "invalid number of fields to skip"
msgstr "건너 뛸 필드의 개수가 부적절합니다"

#: src/uniq.c:610
msgid "invalid number of bytes to skip"
msgstr "건너 뛸 바이트 수가 부적절합니다"

#: src/uniq.c:620
msgid "invalid number of bytes to compare"
msgstr "비교할 바이트의 개수가 부적절합니다"

#: src/uniq.c:642
#, c-format
msgid "--group is mutually exclusive with -c/-d/-D/-u"
msgstr "--group은 -c/-d/-D/-u 옵션을 함께 사용할 수 없습니다"

#: src/uniq.c:649
#, c-format
msgid "grouping and printing repeat counts is meaningless"
msgstr "반복 갯수를 모아 출력하는 동작은 무의미합니다"

#: src/uniq.c:656
#, c-format
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr "반복 행을 표시하고 반복 회수를 세는 동작은 무의미합니다"

#: src/unlink.c:45
#, c-format
msgid ""
"Usage: %s FILE\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s <파일>\n"
"  또는: %s <옵션>\n"

#: src/unlink.c:48
msgid ""
"Call the unlink function to remove the specified FILE.\n"
"\n"
msgstr ""
"지정 <파일>을 제거할 unlink() 함수를 호출합니다.\n"
"\n"

#: src/uptime.c:126
msgid "couldn't get boot time"
msgstr "부팅 시각을 가져올 수 없습니다"

#. TRANSLATORS: This prints the current clock time.
#: src/uptime.c:137
msgid " %H:%M:%S  "
msgstr " %H:%M:%S  "

#: src/uptime.c:139
#, c-format
msgid " ??:????  "
msgstr " ??:????  "

#: src/uptime.c:141
#, c-format
msgid "up ???? days ??:??,  "
msgstr "가동시간 ???? 일 ??:??,  "

#: src/uptime.c:145
#, c-format
msgid "up %ld day %2d:%02d,  "
msgid_plural "up %ld days %2d:%02d,  "
msgstr[0] "가동시간 %ld 일 %2d:%02d,  "

#: src/uptime.c:150
#, c-format
msgid "up  %2d:%02d,  "
msgstr "가동시간  %2d:%02d,  "

#: src/uptime.c:152
#, c-format
msgid "%lu user"
msgid_plural "%lu users"
msgstr[0] "사용자 %lu명"

#: src/uptime.c:162
#, c-format
msgid ",  load average: %.2f"
msgstr ",  평균 부하: %.2f"

#: src/uptime.c:200
#, c-format
msgid ""
"Print the current time, the length of time the system has been up,\n"
"the number of users on the system, and the average number of jobs\n"
"in the run queue over the last 1, 5 and 15 minutes."
msgstr ""
"현재 시각, 시스템 가동 이후 경과 시간, 시스템 사용자 수, 최근 1, 5, 15분 전"
"의\n"
"실행 큐에 대기하는 평균 작업 수를 출력합니다."

#: src/uptime.c:209
#, c-format
msgid ""
"  Processes in\n"
"an uninterruptible sleep state also contribute to the load average.\n"
msgstr ""
"  가동 프로세스 중\n"
"멈출 수 없는 대기 상태 또한 부하 평균에 반영합니다.\n"

#: src/uptime.c:215
#, c-format
msgid ""
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"<파일>을 지정하지 않았다면, %s을(를) 사용하십시오. %s값은\n"
"<파일> 일반 지정 값입니다.\n"
"\n"

#: src/users.c:106
#, c-format
msgid ""
"Output who is currently logged in according to FILE.\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"\n"
msgstr ""
"<파일>에 따라 현재 로그인한 사용자를 출력합니다.\n"
"<파일>을 지정하지 않았다면, %s을(를) 사용하십시오.\n"
"%s 파일이 일반적입니다.\n"
"\n"

#: src/wc.c:172
msgid "avx2 support not detected"
msgstr "AVX2 지원을 발견하지 못했습니다"

#: src/wc.c:178
msgid "using avx2 hardware support"
msgstr "AVX2 하드웨어 지원 사용"

#: src/wc.c:196
msgid ""
"Print newline, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  A word is a non-zero-length sequence of\n"
"printable characters delimited by white space.\n"
msgstr ""
"각 <파일>에 대한 개행 문자, 단어, 바이트 수, 그리고 하나 이상의 <파일>을\n"
"지정했을 때 전체 줄 수를 출력합니다.  단어는 공백문자로 구분한 0 길이가 아"
"닌\n"
"문자의 배열입니다.\n"

#: src/wc.c:204
msgid ""
"\n"
"The options below may be used to select which counts are printed, always in\n"
"the following order: newline, word, character, byte, maximum line length.\n"
"  -c, --bytes            print the byte counts\n"
"  -m, --chars            print the character counts\n"
"  -l, --lines            print the newline counts\n"
msgstr ""
"\n"
"아래 옵션은 어떤 요소의 갯수를 출력할 지 선택할 때 사용하며, 다음 순서를 따릅"
"니다:\n"
"개행문자, 단어, 문자, 바이트, 최대 행길이.\n"
"  -c, --bytes            바이트 수를 출력합니다\n"
"  -m, --chars            문자 갯수를 출력합니다\n"
"  -l, --lines            개행 문자 수를 출력합니다\n"

#: src/wc.c:212
msgid ""
"      --files0-from=F    read input from the files specified by\n"
"                           NUL-terminated names in file F;\n"
"                           If F is - then read names from standard input\n"
"  -L, --max-line-length  print the maximum display width\n"
"  -w, --words            print the word counts\n"
msgstr ""
"      --files0-from=<파일>    <파일>에서 NUL로 끝난 이름으로 \n"
"                           지정한 파일의 입력을 읽습니다\n"
"                           <파일>을 - 기호로 설정하면, 표준 입력에서 이름을\n"
"                           읽어옵니다\n"
"  -L, --max-line-length  최대 표시 너비 출력\n"
"  -w, --words            단어 수 출력\n"

#: src/who.c:213
msgid " old "
msgstr " 오래됨 "

#: src/who.c:443
msgid "system boot"
msgstr "시스템 부팅"

#: src/who.c:451 src/who.c:453
msgid "id="
msgstr "ID="

#: src/who.c:466 src/who.c:471
msgid "term="
msgstr "term="

#: src/who.c:468 src/who.c:472
msgid "exit="
msgstr "exit="

#: src/who.c:489
msgid "LOGIN"
msgstr "로그인"

#: src/who.c:509
msgid "clock change"
msgstr "시계 변경"

#: src/who.c:521 src/who.c:522
msgid "run-level"
msgstr "런레벨"

#: src/who.c:525 src/who.c:526
msgid "last="
msgstr "last="

#: src/who.c:557
#, c-format
msgid ""
"\n"
"# users=%lu\n"
msgstr ""
"\n"
"사용자 수=%lu\n"

#: src/who.c:563
msgid "NAME"
msgstr "이름"

#: src/who.c:563
msgid "LINE"
msgstr "행"

#: src/who.c:563
msgid "TIME"
msgstr "시각"

#: src/who.c:563
msgid "IDLE"
msgstr "대기"

#: src/who.c:564
msgid "PID"
msgstr "PID"

#: src/who.c:564
msgid "COMMENT"
msgstr "설명"

#: src/who.c:564
msgid "EXIT"
msgstr "나감"

#: src/who.c:644
#, c-format
msgid "Usage: %s [OPTION]... [ FILE | ARG1 ARG2 ]\n"
msgstr "사용법: %s [<옵션>]... [ <파일> | <인자1> <인자2> ]\n"

#: src/who.c:645
msgid "Print information about users who are currently logged in.\n"
msgstr "현재 로그인한 사용자 정보를 출력합니다.\n"

#: src/who.c:648
msgid ""
"\n"
"  -a, --all         same as -b -d --login -p -r -t -T -u\n"
"  -b, --boot        time of last system boot\n"
"  -d, --dead        print dead processes\n"
"  -H, --heading     print line of column headings\n"
msgstr ""
"\n"
"  -a, --all         -b -d --login -p -r -t -T -u와 동일\n"
"  -b, --boot        최종 시스템 부팅 시각 출력\n"
"  -d, --dead        죽은 프로세스 출력\n"
"  -H, --heading     열 항목 제목 행 출력\n"

#: src/who.c:655
msgid "  -l, --login       print system login processes\n"
msgstr "  -l, --login       시스템 로그인 프로세스를 출력합니다\n"

#: src/who.c:658
msgid ""
"      --lookup      attempt to canonicalize hostnames via DNS\n"
"  -m                only hostname and user associated with stdin\n"
"  -p, --process     print active processes spawned by init\n"
msgstr ""
"      --lookup      DNS로 호스트 이름 정규화 시도\n"
"  -m                표준 입력에 관련된 호스트 이름과 사용자만 출력\n"
"  -p, --process     init으로 실행한 활성 프로세스만 출력\n"

#: src/who.c:663
msgid ""
"  -q, --count       all login names and number of users logged on\n"
"  -r, --runlevel    print current runlevel\n"
"  -s, --short       print only name, line, and time (default)\n"
"  -t, --time        print last system clock change\n"
msgstr ""
"  -q, --count       모든 로그인 이름과 로그인한 사용자 수\n"
"  -r, --runlevel    현재 런레벨 출력\n"
"  -s, --short       이름 행 시각만 출력(기본값)\n"
"  -t, --time        최근 바뀐 시스템 시계 출력\n"

#: src/who.c:669
msgid ""
"  -T, -w, --mesg    add user's message status as +, - or ?\n"
"  -u, --users       list users logged in\n"
"      --message     same as -T\n"
"      --writable    same as -T\n"
msgstr ""
"  -T, -w, --mesg    사용자 메시지 상태를 +, -, ? 기호로 추가\n"
"  -u, --users       로그인한 사용자 표시\n"
"      --message     -T와 동일\n"
"      --writable    -T와 동일\n"

#: src/who.c:677
#, c-format
msgid ""
"\n"
"If FILE is not specified, use %s.  %s as FILE is common.\n"
"If ARG1 ARG2 given, -m presumed: 'am i' or 'mom likes' are usual.\n"
msgstr ""
"\n"
"<파일>을 지정하지 않았다면 %s을(를) 사용하십시오. %s  <파일>이 일반적입니"
"다.\n"
"<인자1> <인자2> 값을 지정했다면 -m 옵션을 지정한 것으로 간주합니다.\n"
"보통 'am i' 또는 'mom likes'가 들어갈 수 있습니다 \n"

#: src/whoami.c:45
msgid ""
"Print the user name associated with the current effective user ID.\n"
"Same as id -un.\n"
"\n"
msgstr ""
"현재 유효한 사용자 ID와 사용자 이름을 출력합니다.\n"
"id -un과 동일합니다\n"
"\n"

#: src/whoami.c:86
#, c-format
msgid "cannot find name for user ID %lu"
msgstr "사용자 ID %lu의 이름을 찾을 수 없습니다"

#: src/yes.c:41
#, c-format
msgid ""
"Usage: %s [STRING]...\n"
"  or:  %s OPTION\n"
msgstr ""
"사용법: %s [<문자열>]...\n"
"  또는: %s [<옵션>]\n"

#: src/yes.c:47
msgid ""
"Repeatedly output a line with all specified STRING(s), or 'y'.\n"
"\n"
msgstr ""
"지정 <문자열> 또는 'y' 행을 반복 출력합니다.\n"
"\n"

#~ msgid "  count_bytes  treat 'count=N' as a byte count (iflag only)\n"
#~ msgstr ""
#~ "  count_bytes  바이트 단위로 'count=<번호>' 옵션 취급 (iflag 전용)\n"

#~ msgid "  skip_bytes  treat 'skip=N' as a byte count (iflag only)\n"
#~ msgstr "  skip_bytes  바이트 단위로 'skip=<번호>' 옵션 취급 (iflag 전용)\n"

#~ msgid "  seek_bytes  treat 'seek=N' as a byte count (oflag only)\n"
#~ msgstr "  seek_bytes  바이트 단위로 'seek=<번호>' 취급 (oflag 전용)\n"

#~ msgid "failed to truncate to %<PRIuMAX> bytes in output file %s"
#~ msgstr "%2$s 출력 파일을 %1$<PRIuMAX> 바이트로 잘라내기 실패"

#~ msgid "cannot set hostname; this system lacks the functionality"
#~ msgstr ""
#~ "호스트 이름을 설정할 수 없습니다. 이 시스템에 해당 기능이 빠졌습니다"

#~ msgid ""
#~ "  -f                         list all entries in directory order\n"
#~ "  -F, --classify[=WHEN]      append indicator (one of */=>@|) to "
#~ "entries;\n"
#~ "                               WHEN can be 'always' (default if "
#~ "omitted),\n"
#~ "                               'auto', or 'never'\n"
#~ "      --file-type            likewise, except do not append '*'\n"
#~ "      --format=WORD          across -x, commas -m, horizontal -x, long -"
#~ "l,\n"
#~ "                               single-column -1, verbose -l, vertical -C\n"
#~ "      --full-time            like -l --time-style=full-iso\n"
#~ msgstr ""
#~ "  -f                         모든 항목을 디렉터리 순서대로 나열합니다\n"
#~ "  -F, --classify[=<시기>]    항목에 표시(*/=>@| 중 하나)를 붙입니다\n"
#~ "                               <시기>는 'always'(생략하면 기본), 'auto',\n"
#~ "                               'never' 중 한가지 값이 들어갑니다.\n"
#~ "      --file-type            위와 비슷하나, '*'은 붙이지 않습니다\n"
#~ "      --format=<단어>          across -x, commas -m, horizontal -x, long -"
#~ "l,\n"
#~ "                               single-column -1, verbose -l, vertical -C\n"
#~ "      --full-time            -l --time-style=full-iso과 동일합니다\n"

#~ msgid ""
#~ "  -H, --dereference-command-line\n"
#~ "                             follow symbolic links listed on the command "
#~ "line\n"
#~ "      --dereference-command-line-symlink-to-dir\n"
#~ "                             follow each command line symbolic link\n"
#~ "                               that points to a directory\n"
#~ "      --hide=PATTERN         do not list implied entries matching shell "
#~ "PATTERN\n"
#~ "                               (overridden by -a or -A)\n"
#~ msgstr ""
#~ "  -H, --dereference-command-line\n"
#~ "                             명령행에 나열한 심볼릭 링크를 따라갑니다\n"
#~ "      --dereference-command-line-symlink-to-dir\n"
#~ "                             디렉터리를 가리키는 각 명령행 심볼릭 링크를\n"
#~ "                               따라갑니다\n"
#~ "      --hide=<패턴>          셸 <패턴>에 일치하는 암시 항목을 나타내지 않"
#~ "습니다\n"
#~ "                             (-a 또는 -A로 동작 덮어씀)\n"

#~ msgid ""
#~ "      --hyperlink[=WHEN]     hyperlink file names; WHEN can be 'always'\n"
#~ "                               (default if omitted), 'auto', or 'never'\n"
#~ msgstr ""
#~ "      --hyperlink[=<시기>]     파일 이름의 하이퍼링크를 만듭니다.\n"
#~ "                               <시기>에는 'always'(생략시 기본) 또는\n"
#~ "                               'auto', 'never'가 들어갑니다.\n"
